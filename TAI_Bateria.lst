CCS PCH C Compiler, Version 5.015, 5967               15-nov-18 19:50

               Filename:   C:\Users\Vitor\Desktop\Monitor_Estado_Baterias\TAI_Bateria.lst

               ROM used:   13564 bytes (41%)
                           Largest free fragment is 19200
               RAM used:   1606 (78%) at main() level
                           1846 (90%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   331C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.4
004A:  GOTO   0054
004E:  BTFSC  FF2.1
0050:  GOTO   0922
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   05DC
0060:  BTFSS  FF2.5
0062:  GOTO   006C
0066:  BTFSC  FF2.2
0068:  GOTO   07A4
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Projeto Monitor do Estado de Baterias - TAI  
.................... // Data: Setembro de 2018 
....................  
....................  
.................... //******************* Interrupção do Timer 0 / RTCC ************************** 
.................... //   
.................... //  Cristal externo = 16 MHz - Uso de PLL*4 -> Frequencia de trabalho = 16MHz  
.................... //  Prescaler = 1:16 
.................... //  Tout =(4*prescaler* (256-TMR0))/fclk   
.................... //  Para interrup��o a cada 1 ms 
.................... //  TMR0 = 6  
.................... //  
.................... //**************************************************************************** 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  MOVFF  FF2,0D
00B2:  BCF    FF2.7
00B4:  CLRF   FF7
00B6:  ADDLW  C8
00B8:  MOVWF  FF6
00BA:  MOVLW  00
00BC:  ADDWFC FF7,F
00BE:  TBLRD*+
00C0:  MOVF   FF5,W
00C2:  BTFSC  0D.7
00C4:  BSF    FF2.7
00C6:  RETURN 0
00C8:  DATA 2B,43
00CA:  DATA 4D,54
00CC:  DATA 49,00
00CE:  MOVFF  FF2,0D
00D2:  BCF    FF2.7
00D4:  CLRF   FF7
00D6:  ADDLW  E8
00D8:  MOVWF  FF6
00DA:  MOVLW  00
00DC:  ADDWFC FF7,F
00DE:  TBLRD*+
00E0:  MOVF   FF5,W
00E2:  BTFSC  0D.7
00E4:  BSF    FF2.7
00E6:  RETURN 0
00E8:  DATA 2B,43
00EA:  DATA 4D,47
00EC:  DATA 4C,00
00EE:  MOVFF  FF2,0D
00F2:  BCF    FF2.7
00F4:  CLRF   FF7
00F6:  ADDLW  08
00F8:  MOVWF  FF6
00FA:  MOVLW  01
00FC:  ADDWFC FF7,F
00FE:  TBLRD*+
0100:  MOVF   FF5,W
0102:  BTFSC  0D.7
0104:  BSF    FF2.7
0106:  RETURN 0
0108:  DATA 4F,49
010A:  DATA 54,41
010C:  DATA 49,00
010E:  MOVFF  FF2,0D
0112:  BCF    FF2.7
0114:  CLRF   FF7
0116:  ADDLW  28
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  BTFSC  0D.7
0124:  BSF    FF2.7
0126:  RETURN 0
0128:  DATA 48,45
012A:  DATA 41,52
012C:  DATA 54,42
012E:  DATA 45,41
0130:  DATA 54,28
0132:  DATA 29,00
0134:  MOVFF  FF2,0D
0138:  BCF    FF2.7
013A:  CLRF   FF7
013C:  ADDLW  4E
013E:  MOVWF  FF6
0140:  MOVLW  01
0142:  ADDWFC FF7,F
0144:  TBLRD*+
0146:  MOVF   FF5,W
0148:  BTFSC  0D.7
014A:  BSF    FF2.7
014C:  RETURN 0
014E:  DATA 2B,4E
0150:  DATA 55,4D
0152:  DATA 41,44
0154:  DATA 44,00
0156:  MOVFF  FF2,0D
015A:  BCF    FF2.7
015C:  CLRF   FF7
015E:  ADDLW  70
0160:  MOVWF  FF6
0162:  MOVLW  01
0164:  ADDWFC FF7,F
0166:  TBLRD*+
0168:  MOVF   FF5,W
016A:  BTFSC  0D.7
016C:  BSF    FF2.7
016E:  RETURN 0
0170:  DATA 2B,4E
0172:  DATA 55,4D
0174:  DATA 44,45
0176:  DATA 4C,00
0178:  MOVFF  FF2,0D
017C:  BCF    FF2.7
017E:  CLRF   FF7
0180:  ADDLW  92
0182:  MOVWF  FF6
0184:  MOVLW  01
0186:  ADDWFC FF7,F
0188:  TBLRD*+
018A:  MOVF   FF5,W
018C:  BTFSC  0D.7
018E:  BSF    FF2.7
0190:  RETURN 0
0192:  DATA 4F,4B
0194:  DATA 20,43
0196:  DATA 4C,45
0198:  DATA 41,52
019A:  DATA 20,41
019C:  DATA 4C,4C
019E:  DATA 00,00
01A0:  MOVFF  FF2,0D
01A4:  BCF    FF2.7
01A6:  CLRF   FF7
01A8:  ADDLW  BA
01AA:  MOVWF  FF6
01AC:  MOVLW  01
01AE:  ADDWFC FF7,F
01B0:  TBLRD*+
01B2:  MOVF   FF5,W
01B4:  BTFSC  0D.7
01B6:  BSF    FF2.7
01B8:  RETURN 0
01BA:  DATA 2B,47
01BC:  DATA 53,4D
01BE:  DATA 4C,4F
01C0:  DATA 43,41
01C2:  DATA 54,45
01C4:  DATA 00,00
01C6:  MOVFF  FF2,0D
01CA:  BCF    FF2.7
01CC:  CLRF   FF7
01CE:  ADDLW  E0
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  BTFSC  0D.7
01DC:  BSF    FF2.7
01DE:  RETURN 0
01E0:  DATA 2B,43
01E2:  DATA 55,52
01E4:  DATA 4C,49
01E6:  DATA 4D,00
01E8:  MOVFF  FF2,0D
01EC:  BCF    FF2.7
01EE:  CLRF   FF7
01F0:  ADDLW  02
01F2:  MOVWF  FF6
01F4:  MOVLW  02
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  BTFSC  0D.7
01FE:  BSF    FF2.7
0200:  RETURN 0
0202:  DATA 2B,43
0204:  DATA 55,52
0206:  DATA 41,4C
0208:  DATA 4D,00
020A:  MOVFF  FF2,0D
020E:  BCF    FF2.7
0210:  CLRF   FF7
0212:  ADDLW  24
0214:  MOVWF  FF6
0216:  MOVLW  02
0218:  ADDWFC FF7,F
021A:  TBLRD*+
021C:  MOVF   FF5,W
021E:  BTFSC  0D.7
0220:  BSF    FF2.7
0222:  RETURN 0
0224:  DATA 2B,43
0226:  DATA 53,54
0228:  DATA 41,54
022A:  DATA 53,00
022C:  MOVFF  FF2,0D
0230:  BCF    FF2.7
0232:  CLRF   FF7
0234:  ADDLW  46
0236:  MOVWF  FF6
0238:  MOVLW  02
023A:  ADDWFC FF7,F
023C:  TBLRD*+
023E:  MOVF   FF5,W
0240:  BTFSC  0D.7
0242:  BSF    FF2.7
0244:  RETURN 0
0246:  DATA 2B,53
0248:  DATA 45,54
024A:  DATA 5A,45
024C:  DATA 52,4F
024E:  DATA 00,00
0250:  MOVFF  FF2,0D
0254:  BCF    FF2.7
0256:  CLRF   FF7
0258:  ADDLW  6A
025A:  MOVWF  FF6
025C:  MOVLW  02
025E:  ADDWFC FF7,F
0260:  TBLRD*+
0262:  MOVF   FF5,W
0264:  BTFSC  0D.7
0266:  BSF    FF2.7
0268:  RETURN 0
026A:  DATA 5A,45
026C:  DATA 52,4F
026E:  DATA 20,53
0270:  DATA 45,54
0272:  DATA 45,44
0274:  DATA 00,00
0276:  MOVFF  FF2,0D
027A:  BCF    FF2.7
027C:  CLRF   FF7
027E:  ADDLW  90
0280:  MOVWF  FF6
0282:  MOVLW  02
0284:  ADDWFC FF7,F
0286:  TBLRD*+
0288:  MOVF   FF5,W
028A:  BTFSC  0D.7
028C:  BSF    FF2.7
028E:  RETURN 0
0290:  DATA 41,54
0292:  DATA 2B,43
0294:  DATA 4D,47
0296:  DATA 46,3D
0298:  DATA 31,0D
029A:  DATA 0A,00
029C:  MOVFF  FF2,0D
02A0:  BCF    FF2.7
02A2:  CLRF   FF7
02A4:  ADDLW  B6
02A6:  MOVWF  FF6
02A8:  MOVLW  02
02AA:  ADDWFC FF7,F
02AC:  TBLRD*+
02AE:  MOVF   FF5,W
02B0:  BTFSC  0D.7
02B2:  BSF    FF2.7
02B4:  RETURN 0
02B6:  DATA 41,54
02B8:  DATA 2B,43
02BA:  DATA 53,4D
02BC:  DATA 50,3D
02BE:  DATA 31,37
02C0:  DATA 2C,32
02C2:  DATA 35,35
02C4:  DATA 2C,30
02C6:  DATA 2C,30
02C8:  DATA 0D,0A
02CA:  DATA 00,00
02CC:  MOVFF  FF2,0D
02D0:  BCF    FF2.7
02D2:  CLRF   FF7
02D4:  ADDLW  E6
02D6:  MOVWF  FF6
02D8:  MOVLW  02
02DA:  ADDWFC FF7,F
02DC:  TBLRD*+
02DE:  MOVF   FF5,W
02E0:  BTFSC  0D.7
02E2:  BSF    FF2.7
02E4:  RETURN 0
02E6:  DATA 2B,43
02E8:  DATA 4D,47
02EA:  DATA 53,3A
02EC:  DATA 00,00
02EE:  MOVFF  FF2,0D
02F2:  BCF    FF2.7
02F4:  CLRF   FF7
02F6:  ADDLW  08
02F8:  MOVWF  FF6
02FA:  MOVLW  03
02FC:  ADDWFC FF7,F
02FE:  TBLRD*+
0300:  MOVF   FF5,W
0302:  BTFSC  0D.7
0304:  BSF    FF2.7
0306:  RETURN 0
0308:  DATA 41,54
030A:  DATA 2B,43
030C:  DATA 4D,47
030E:  DATA 4C,3D
0310:  DATA 22,52
0312:  DATA 45,43
0314:  DATA 20,55
0316:  DATA 4E,52
0318:  DATA 45,41
031A:  DATA 44,22
031C:  DATA 0D,0A
031E:  DATA 00,00
0320:  MOVFF  FF2,0D
0324:  BCF    FF2.7
0326:  CLRF   FF7
0328:  ADDLW  3A
032A:  MOVWF  FF6
032C:  MOVLW  03
032E:  ADDWFC FF7,F
0330:  TBLRD*+
0332:  MOVF   FF5,W
0334:  BTFSC  0D.7
0336:  BSF    FF2.7
0338:  RETURN 0
033A:  DATA 41,54
033C:  DATA 2B,43
033E:  DATA 47,41
0340:  DATA 54,54
0342:  DATA 3D,31
0344:  DATA 0D,0A
0346:  DATA 00,00
0348:  MOVFF  FF2,0D
034C:  BCF    FF2.7
034E:  CLRF   FF7
0350:  ADDLW  62
0352:  MOVWF  FF6
0354:  MOVLW  03
0356:  ADDWFC FF7,F
0358:  TBLRD*+
035A:  MOVF   FF5,W
035C:  BTFSC  0D.7
035E:  BSF    FF2.7
0360:  RETURN 0
0362:  DATA 41,54
0364:  DATA 2B,53
0366:  DATA 41,50
0368:  DATA 42,52
036A:  DATA 3D,33
036C:  DATA 2C,31
036E:  DATA 2C,22
0370:  DATA 43,4F
0372:  DATA 4E,54
0374:  DATA 59,50
0376:  DATA 45,22
0378:  DATA 2C,22
037A:  DATA 47,50
037C:  DATA 52,53
037E:  DATA 22,0D
0380:  DATA 0A,00
0382:  MOVFF  FF2,0D
0386:  BCF    FF2.7
0388:  CLRF   FF7
038A:  ADDLW  9C
038C:  MOVWF  FF6
038E:  MOVLW  03
0390:  ADDWFC FF7,F
0392:  TBLRD*+
0394:  MOVF   FF5,W
0396:  BTFSC  0D.7
0398:  BSF    FF2.7
039A:  RETURN 0
039C:  DATA 41,54
039E:  DATA 2B,53
03A0:  DATA 41,50
03A2:  DATA 42,52
03A4:  DATA 3D,33
03A6:  DATA 2C,31
03A8:  DATA 2C,22
03AA:  DATA 41,50
03AC:  DATA 4E,22
03AE:  DATA 2C,22
03B0:  DATA 43,4D
03B2:  DATA 4E,45
03B4:  DATA 54,22
03B6:  DATA 0D,0A
03B8:  DATA 00,00
03BA:  MOVFF  FF2,0D
03BE:  BCF    FF2.7
03C0:  CLRF   FF7
03C2:  ADDLW  D4
03C4:  MOVWF  FF6
03C6:  MOVLW  03
03C8:  ADDWFC FF7,F
03CA:  TBLRD*+
03CC:  MOVF   FF5,W
03CE:  BTFSC  0D.7
03D0:  BSF    FF2.7
03D2:  RETURN 0
03D4:  DATA 41,54
03D6:  DATA 2B,53
03D8:  DATA 41,50
03DA:  DATA 42,52
03DC:  DATA 3D,31
03DE:  DATA 2C,31
03E0:  DATA 0D,0A
03E2:  DATA 00,00
03E4:  MOVFF  FF2,0D
03E8:  BCF    FF2.7
03EA:  CLRF   FF7
03EC:  ADDLW  FE
03EE:  MOVWF  FF6
03F0:  MOVLW  03
03F2:  ADDWFC FF7,F
03F4:  TBLRD*+
03F6:  MOVF   FF5,W
03F8:  BTFSC  0D.7
03FA:  BSF    FF2.7
03FC:  RETURN 0
03FE:  DATA 41,54
0400:  DATA 2B,53
0402:  DATA 41,50
0404:  DATA 42,52
0406:  DATA 3D,32
0408:  DATA 2C,31
040A:  DATA 0D,0A
040C:  DATA 00,00
040E:  MOVFF  FF2,0D
0412:  BCF    FF2.7
0414:  CLRF   FF7
0416:  ADDLW  28
0418:  MOVWF  FF6
041A:  MOVLW  04
041C:  ADDWFC FF7,F
041E:  TBLRD*+
0420:  MOVF   FF5,W
0422:  BTFSC  0D.7
0424:  BSF    FF2.7
0426:  RETURN 0
0428:  DATA 2B,53
042A:  DATA 41,50
042C:  DATA 42,52
042E:  DATA 3A,00
0430:  MOVFF  FF2,0D
0434:  BCF    FF2.7
0436:  CLRF   FF7
0438:  ADDLW  4A
043A:  MOVWF  FF6
043C:  MOVLW  04
043E:  ADDWFC FF7,F
0440:  TBLRD*+
0442:  MOVF   FF5,W
0444:  BTFSC  0D.7
0446:  BSF    FF2.7
0448:  RETURN 0
044A:  DATA 41,54
044C:  DATA 2B,43
044E:  DATA 4C,42
0450:  DATA 53,43
0452:  DATA 46,47
0454:  DATA 3D,30
0456:  DATA 2C,31
0458:  DATA 0D,0A
045A:  DATA 00,00
045C:  MOVFF  FF2,0D
0460:  BCF    FF2.7
0462:  CLRF   FF7
0464:  ADDLW  76
0466:  MOVWF  FF6
0468:  MOVLW  04
046A:  ADDWFC FF7,F
046C:  TBLRD*+
046E:  MOVF   FF5,W
0470:  BTFSC  0D.7
0472:  BSF    FF2.7
0474:  RETURN 0
0476:  DATA 2B,43
0478:  DATA 4C,42
047A:  DATA 53,43
047C:  DATA 46,47
047E:  DATA 3A,00
0480:  MOVFF  FF2,0D
0484:  BCF    FF2.7
0486:  CLRF   FF7
0488:  ADDLW  9A
048A:  MOVWF  FF6
048C:  MOVLW  04
048E:  ADDWFC FF7,F
0490:  TBLRD*+
0492:  MOVF   FF5,W
0494:  BTFSC  0D.7
0496:  BSF    FF2.7
0498:  RETURN 0
049A:  DATA 41,54
049C:  DATA 2B,43
049E:  DATA 4C,42
04A0:  DATA 53,3D
04A2:  DATA 31,2C
04A4:  DATA 31,0D
04A6:  DATA 0A,00
04A8:  MOVFF  FF2,0D
04AC:  BCF    FF2.7
04AE:  CLRF   FF7
04B0:  ADDLW  C2
04B2:  MOVWF  FF6
04B4:  MOVLW  04
04B6:  ADDWFC FF7,F
04B8:  TBLRD*+
04BA:  MOVF   FF5,W
04BC:  BTFSC  0D.7
04BE:  BSF    FF2.7
04C0:  RETURN 0
04C2:  DATA 2B,43
04C4:  DATA 4C,42
04C6:  DATA 53,3A
04C8:  DATA 00,00
04CA:  MOVFF  FF2,0D
04CE:  BCF    FF2.7
04D0:  CLRF   FF7
04D2:  ADDLW  E4
04D4:  MOVWF  FF6
04D6:  MOVLW  04
04D8:  ADDWFC FF7,F
04DA:  TBLRD*+
04DC:  MOVF   FF5,W
04DE:  BTFSC  0D.7
04E0:  BSF    FF2.7
04E2:  RETURN 0
04E4:  DATA 41,54
04E6:  DATA 2B,53
04E8:  DATA 41,50
04EA:  DATA 42,52
04EC:  DATA 3D,30
04EE:  DATA 2C,31
04F0:  DATA 0D,0A
04F2:  DATA 00,00
04F4:  MOVFF  FF2,0D
04F8:  BCF    FF2.7
04FA:  CLRF   FF7
04FC:  ADDLW  0E
04FE:  MOVWF  FF6
0500:  MOVLW  05
0502:  ADDWFC FF7,F
0504:  TBLRD*+
0506:  MOVF   FF5,W
0508:  BTFSC  0D.7
050A:  BSF    FF2.7
050C:  RETURN 0
050E:  DATA 30,33
0510:  DATA 31,39
0512:  DATA 39,35
0514:  DATA 38,32
0516:  DATA 32,37
0518:  DATA 33,39
051A:  DATA 00,00
051C:  MOVFF  FF2,0D
0520:  BCF    FF2.7
0522:  CLRF   FF7
0524:  ADDLW  36
0526:  MOVWF  FF6
0528:  MOVLW  05
052A:  ADDWFC FF7,F
052C:  TBLRD*+
052E:  MOVF   FF5,W
0530:  BTFSC  0D.7
0532:  BSF    FF2.7
0534:  RETURN 0
0536:  DATA 49,4E
0538:  DATA 49,43
053A:  DATA 49,41
053C:  DATA 4E,44
053E:  DATA 4F,2E
0540:  DATA 2E,2E
0542:  DATA 00,00
0544:  MOVFF  FF2,0D
0548:  BCF    FF2.7
054A:  CLRF   FF7
054C:  ADDLW  5E
054E:  MOVWF  FF6
0550:  MOVLW  05
0552:  ADDWFC FF7,F
0554:  TBLRD*+
0556:  MOVF   FF5,W
0558:  BTFSC  0D.7
055A:  BSF    FF2.7
055C:  RETURN 0
055E:  DATA 41,54
0560:  DATA 2B,43
0562:  DATA 4D,47
0564:  DATA 44,3D
0566:  DATA 31,2C
0568:  DATA 31,0D
056A:  DATA 0A,00
056C:  MOVFF  FF2,0D
0570:  BCF    FF2.7
0572:  CLRF   FF7
0574:  ADDLW  86
0576:  MOVWF  FF6
0578:  MOVLW  05
057A:  ADDWFC FF7,F
057C:  TBLRD*+
057E:  MOVF   FF5,W
0580:  BTFSC  0D.7
0582:  BSF    FF2.7
0584:  RETURN 0
0586:  DATA 21,21
0588:  DATA 21,21
058A:  DATA 41,4C
058C:  DATA 45,52
058E:  DATA 54,41
0590:  DATA 3A,20
0592:  DATA 42,61
0594:  DATA 74,65
0596:  DATA 72,69
0598:  DATA 61,20
059A:  DATA 65,6D
059C:  DATA 20,64
059E:  DATA 65,73
05A0:  DATA 63,61
05A2:  DATA 72,67
05A4:  DATA 61,20
05A6:  DATA 72,61
05A8:  DATA 70,69
05AA:  DATA 64,61
05AC:  DATA 20,56
05AE:  DATA 45,52
05B0:  DATA 49,46
05B2:  DATA 49,51
05B4:  DATA 55,45
05B6:  DATA 20,53
05B8:  DATA 45,55
05BA:  DATA 20,56
05BC:  DATA 45,49
05BE:  DATA 43,55
05C0:  DATA 4C,4F
05C2:  DATA 21,21
05C4:  DATA 21,00
*
0694:  DATA 43,6F
0696:  DATA 72,72
0698:  DATA 65,6E
069A:  DATA 74,65
069C:  DATA 20,4C
069E:  DATA 69,6D
06A0:  DATA 69,74
06A2:  DATA 65,20
06A4:  DATA 3D,20
06A6:  DATA 25,4C
06A8:  DATA 75,20
06AA:  DATA 6D,41
06AC:  DATA 00,00
06AE:  DATA 54,65
06B0:  DATA 6D,70
06B2:  DATA 6F,20
06B4:  DATA 45,6E
06B6:  DATA 74,72
06B8:  DATA 65,20
06BA:  DATA 41,6C
06BC:  DATA 65,72
06BE:  DATA 74,61
06C0:  DATA 73,20
06C2:  DATA 3D,20
06C4:  DATA 25,4C
06C6:  DATA 75,20
06C8:  DATA 6D,69
06CA:  DATA 6E,00
06CC:  DATA 54,65
06CE:  DATA 6D,70
06D0:  DATA 6F,20
06D2:  DATA 45,6E
06D4:  DATA 74,72
06D6:  DATA 65,20
06D8:  DATA 41,6C
06DA:  DATA 65,72
06DC:  DATA 74,61
06DE:  DATA 73,20
06E0:  DATA 3D,20
06E2:  DATA 25,4C
06E4:  DATA 75,20
06E6:  DATA 6D,69
06E8:  DATA 6E,20
06EA:  DATA 2F,20
06EC:  DATA 43,6F
06EE:  DATA 72,72
06F0:  DATA 65,6E
06F2:  DATA 74,65
06F4:  DATA 20,4C
06F6:  DATA 69,6D
06F8:  DATA 69,74
06FA:  DATA 65,20
06FC:  DATA 3D,20
06FE:  DATA 25,4C
0700:  DATA 75,20
0702:  DATA 6D,41
0704:  DATA 20,2F
0706:  DATA 20,43
0708:  DATA 6F,72
070A:  DATA 72,65
070C:  DATA 6E,74
070E:  DATA 65,20
0710:  DATA 41,74
0712:  DATA 75,61
0714:  DATA 6C,3A
0716:  DATA 20,25
0718:  DATA 36,2E
071A:  DATA 30,66
071C:  DATA 20,6D
071E:  DATA 41,20
0720:  DATA 2F,20
0722:  DATA 54,65
0724:  DATA 6E,73
0726:  DATA 61,6F
0728:  DATA 20,41
072A:  DATA 74,75
072C:  DATA 61,6C
072E:  DATA 3A,20
0730:  DATA 25,32
0732:  DATA 2E,32
0734:  DATA 66,20
0736:  DATA 56,20
0738:  DATA 2F,20
073A:  DATA 51,74
073C:  DATA 64,20
073E:  DATA 54,65
0740:  DATA 6C,65
0742:  DATA 66,6F
0744:  DATA 6E,65
0746:  DATA 73,3A
0748:  DATA 20,25
074A:  DATA 75,00
074C:  DATA 41,54
074E:  DATA 2B,43
0750:  DATA 4D,47
0752:  DATA 53,3D
0754:  DATA 22,25
0756:  DATA 73,22
0758:  DATA 0D,0A
075A:  DATA 00,00
075C:  CLRF   01
075E:  CLRF   02
0760:  CLRF   00
0762:  CLRF   03
0764:  MOVLB  7
0766:  MOVF   x34,W
0768:  BNZ   076E
076A:  MOVF   x33,W
076C:  BZ    079E
076E:  MOVLW  10
0770:  MOVWF  x35
0772:  BCF    FD8.0
0774:  RLCF   x31,F
0776:  RLCF   x32,F
0778:  RLCF   00,F
077A:  RLCF   03,F
077C:  MOVF   x34,W
077E:  SUBWF  03,W
0780:  BNZ   0786
0782:  MOVF   x33,W
0784:  SUBWF  00,W
0786:  BNC   0796
0788:  MOVF   x33,W
078A:  SUBWF  00,F
078C:  BTFSS  FD8.0
078E:  DECF   03,F
0790:  MOVF   x34,W
0792:  SUBWF  03,F
0794:  BSF    FD8.0
0796:  RLCF   01,F
0798:  RLCF   02,F
079A:  DECFSZ x35,F
079C:  BRA    0772
079E:  MOVLB  0
07A0:  GOTO   0824 (RETURN)
*
0948:  DATA 44,65
094A:  DATA 74,65
094C:  DATA 63,74
094E:  DATA 20,48
0950:  DATA 69,67
0952:  DATA 68,20
0954:  DATA 43,75
0956:  DATA 72,72
0958:  DATA 65,6E
095A:  DATA 74,0D
095C:  DATA 0A,00
095E:  DATA 44,65
0960:  DATA 74,65
0962:  DATA 63,74
0964:  DATA 20,4C
0966:  DATA 6F,77
0968:  DATA 20,43
096A:  DATA 75,72
096C:  DATA 72,65
096E:  DATA 6E,74
0970:  DATA 0D,0A
0972:  DATA 00,00
0974:  DATA 54,65
0976:  DATA 6D,70
0978:  DATA 6F,20
097A:  DATA 45,6E
097C:  DATA 74,72
097E:  DATA 65,20
0980:  DATA 41,6C
0982:  DATA 65,72
0984:  DATA 74,61
0986:  DATA 73,20
0988:  DATA 25,4C
098A:  DATA 75,20
098C:  DATA 2C,20
098E:  DATA 54,65
0990:  DATA 6D,70
0992:  DATA 6F,20
0994:  DATA 55,6C
0996:  DATA 74,69
0998:  DATA 6D,6F
099A:  DATA 69,20
099C:  DATA 41,6C
099E:  DATA 65,72
09A0:  DATA 74,61
09A2:  DATA 20,25
09A4:  DATA 4C,75
09A6:  DATA 20,0D
09A8:  DATA 0A,00
09AA:  DATA 53,65
09AC:  DATA 6E,64
09AE:  DATA 20,53
09B0:  DATA 4D,53
09B2:  DATA 20,4E
09B4:  DATA 75,6D
09B6:  DATA 65,72
09B8:  DATA 6F,20
09BA:  DATA 28,25
09BC:  DATA 75,2F
09BE:  DATA 25,75
09C0:  DATA 29,3A
09C2:  DATA 20,25
09C4:  DATA 73,0D
09C6:  DATA 0A,00
09C8:  DATA 43,6F
09CA:  DATA 72,72
09CC:  DATA 65,6E
09CE:  DATA 74,65
09D0:  DATA 3A,20
09D2:  DATA 25,36
09D4:  DATA 2E,30
09D6:  DATA 66,20
09D8:  DATA 54,65
09DA:  DATA 6E,73
09DC:  DATA 61,6F
09DE:  DATA 3A,20
09E0:  DATA 25,32
09E2:  DATA 2E,32
09E4:  DATA 66,20
09E6:  DATA 0D,0A
09E8:  DATA 00,00
*
0B1C:  MOVFF  19C,FEA
0B20:  MOVFF  19B,FE9
0B24:  MOVLB  7
0B26:  MOVFF  71A,FEF
0B2A:  INCF   FE9,F
0B2C:  BTFSC  FD8.2
0B2E:  INCF   FEA,F
0B30:  CLRF   FEF
0B32:  MOVLB  1
0B34:  INCF   x9B,F
0B36:  BTFSC  FD8.2
0B38:  INCF   x9C,F
0B3A:  MOVLB  0
0B3C:  RETURN 0
0B3E:  TBLRD*+
0B40:  MOVFF  FF6,718
0B44:  MOVFF  FF7,719
0B48:  MOVFF  FF5,71A
0B4C:  RCALL  0B1C
0B4E:  MOVFF  718,FF6
0B52:  MOVFF  719,FF7
0B56:  MOVLB  7
0B58:  DECFSZ x17,F
0B5A:  BRA    0B5E
0B5C:  BRA    0B62
0B5E:  MOVLB  0
0B60:  BRA    0B3E
0B62:  MOVLB  0
0B64:  RETURN 0
0B66:  MOVF   FEF,F
0B68:  BZ    0B88
0B6A:  MOVFF  FEA,718
0B6E:  MOVFF  FE9,717
0B72:  MOVFF  FEF,71A
0B76:  RCALL  0B1C
0B78:  MOVFF  718,FEA
0B7C:  MOVFF  717,FE9
0B80:  INCF   FE9,F
0B82:  BTFSC  FD8.2
0B84:  INCF   FEA,F
0B86:  BRA    0B66
0B88:  GOTO   0D62 (RETURN)
0B8C:  MOVF   FEF,F
0B8E:  BZ    0BB0
0B90:  MOVFF  FEA,727
0B94:  MOVFF  FE9,726
0B98:  MOVF   FEF,W
0B9A:  BTFSS  F9E.4
0B9C:  BRA    0B9A
0B9E:  MOVWF  FAD
0BA0:  MOVFF  727,FEA
0BA4:  MOVFF  726,FE9
0BA8:  INCF   FE9,F
0BAA:  BTFSC  FD8.2
0BAC:  INCF   FEA,F
0BAE:  BRA    0B8C
0BB0:  GOTO   0C78 (RETURN)
*
0FA4:  MOVLW  8E
0FA6:  MOVWF  00
0FA8:  MOVFF  69F,01
0FAC:  MOVFF  69E,02
0FB0:  CLRF   03
0FB2:  MOVF   01,F
0FB4:  BNZ   0FC8
0FB6:  MOVFF  02,01
0FBA:  CLRF   02
0FBC:  MOVLW  08
0FBE:  SUBWF  00,F
0FC0:  MOVF   01,F
0FC2:  BNZ   0FC8
0FC4:  CLRF   00
0FC6:  BRA    0FD8
0FC8:  BCF    FD8.0
0FCA:  BTFSC  01.7
0FCC:  BRA    0FD6
0FCE:  RLCF   02,F
0FD0:  RLCF   01,F
0FD2:  DECF   00,F
0FD4:  BRA    0FC8
0FD6:  BCF    01.7
0FD8:  RETURN 0
0FDA:  MOVLB  6
0FDC:  MOVF   xC0,W
0FDE:  BTFSC  FD8.2
0FE0:  BRA    10C4
0FE2:  MOVWF  00
0FE4:  MOVF   xC4,W
0FE6:  BTFSC  FD8.2
0FE8:  BRA    10C4
0FEA:  ADDWF  00,F
0FEC:  BNC   0FF6
0FEE:  MOVLW  81
0FF0:  ADDWF  00,F
0FF2:  BC    10C4
0FF4:  BRA    0FFE
0FF6:  MOVLW  7F
0FF8:  SUBWF  00,F
0FFA:  BNC   10C4
0FFC:  BZ    10C4
0FFE:  MOVFF  6C1,6C8
1002:  MOVF   xC5,W
1004:  XORWF  xC8,F
1006:  BSF    xC1.7
1008:  BSF    xC5.7
100A:  MOVF   xC3,W
100C:  MULWF  xC7
100E:  MOVFF  FF4,6CA
1012:  MOVF   xC2,W
1014:  MULWF  xC6
1016:  MOVFF  FF4,03
101A:  MOVFF  FF3,6C9
101E:  MULWF  xC7
1020:  MOVF   FF3,W
1022:  ADDWF  xCA,F
1024:  MOVF   FF4,W
1026:  ADDWFC xC9,F
1028:  MOVLW  00
102A:  ADDWFC 03,F
102C:  MOVF   xC3,W
102E:  MULWF  xC6
1030:  MOVF   FF3,W
1032:  ADDWF  xCA,F
1034:  MOVF   FF4,W
1036:  ADDWFC xC9,F
1038:  MOVLW  00
103A:  CLRF   02
103C:  ADDWFC 03,F
103E:  ADDWFC 02,F
1040:  MOVF   xC1,W
1042:  MULWF  xC7
1044:  MOVF   FF3,W
1046:  ADDWF  xC9,F
1048:  MOVF   FF4,W
104A:  ADDWFC 03,F
104C:  MOVLW  00
104E:  ADDWFC 02,F
1050:  MOVF   xC1,W
1052:  MULWF  xC6
1054:  MOVF   FF3,W
1056:  ADDWF  03,F
1058:  MOVF   FF4,W
105A:  ADDWFC 02,F
105C:  MOVLW  00
105E:  CLRF   01
1060:  ADDWFC 01,F
1062:  MOVF   xC3,W
1064:  MULWF  xC5
1066:  MOVF   FF3,W
1068:  ADDWF  xC9,F
106A:  MOVF   FF4,W
106C:  ADDWFC 03,F
106E:  MOVLW  00
1070:  ADDWFC 02,F
1072:  ADDWFC 01,F
1074:  MOVF   xC2,W
1076:  MULWF  xC5
1078:  MOVF   FF3,W
107A:  ADDWF  03,F
107C:  MOVF   FF4,W
107E:  ADDWFC 02,F
1080:  MOVLW  00
1082:  ADDWFC 01,F
1084:  MOVF   xC1,W
1086:  MULWF  xC5
1088:  MOVF   FF3,W
108A:  ADDWF  02,F
108C:  MOVF   FF4,W
108E:  ADDWFC 01,F
1090:  INCF   00,F
1092:  BTFSC  01.7
1094:  BRA    10A0
1096:  RLCF   xC9,F
1098:  RLCF   03,F
109A:  RLCF   02,F
109C:  RLCF   01,F
109E:  DECF   00,F
10A0:  MOVLW  00
10A2:  BTFSS  xC9.7
10A4:  BRA    10BA
10A6:  INCF   03,F
10A8:  ADDWFC 02,F
10AA:  ADDWFC 01,F
10AC:  MOVF   01,W
10AE:  BNZ   10BA
10B0:  MOVF   02,W
10B2:  BNZ   10BA
10B4:  MOVF   03,W
10B6:  BNZ   10BA
10B8:  INCF   00,F
10BA:  BTFSC  xC8.7
10BC:  BSF    01.7
10BE:  BTFSS  xC8.7
10C0:  BCF    01.7
10C2:  BRA    10CC
10C4:  CLRF   00
10C6:  CLRF   01
10C8:  CLRF   02
10CA:  CLRF   03
10CC:  MOVLB  0
10CE:  RETURN 0
10D0:  MOVLW  80
10D2:  BTFSS  FD8.1
10D4:  BRA    10DA
10D6:  MOVLB  6
10D8:  XORWF  xA3,F
10DA:  MOVLB  6
10DC:  CLRF   xA8
10DE:  CLRF   xA9
10E0:  MOVFF  69F,6A7
10E4:  MOVF   xA3,W
10E6:  XORWF  xA7,F
10E8:  MOVF   x9E,W
10EA:  BTFSC  FD8.2
10EC:  BRA    12AC
10EE:  MOVWF  xA6
10F0:  MOVWF  00
10F2:  MOVF   xA2,W
10F4:  BTFSC  FD8.2
10F6:  BRA    12BE
10F8:  SUBWF  xA6,F
10FA:  BTFSC  FD8.2
10FC:  BRA    1204
10FE:  BNC   117C
1100:  MOVFF  6A3,6AC
1104:  BSF    xAC.7
1106:  MOVFF  6A4,6AB
110A:  MOVFF  6A5,6AA
110E:  CLRF   xA9
1110:  BCF    FD8.0
1112:  RRCF   xAC,F
1114:  RRCF   xAB,F
1116:  RRCF   xAA,F
1118:  RRCF   xA9,F
111A:  DECFSZ xA6,F
111C:  BRA    110E
111E:  BTFSS  xA7.7
1120:  BRA    1128
1122:  BSF    xA8.0
1124:  BRA    12E6
1126:  BCF    xA8.0
1128:  BCF    xA6.0
112A:  BSF    xA8.4
112C:  MOVLW  06
112E:  MOVWF  FEA
1130:  MOVLW  A1
1132:  MOVWF  FE9
1134:  BRA    130C
1136:  BCF    xA8.4
1138:  BTFSC  xA7.7
113A:  BRA    1150
113C:  BTFSS  xA6.0
113E:  BRA    1166
1140:  RRCF   xAC,F
1142:  RRCF   xAB,F
1144:  RRCF   xAA,F
1146:  RRCF   xA9,F
1148:  INCF   00,F
114A:  BTFSC  FD8.2
114C:  BRA    12DC
114E:  BRA    1166
1150:  BTFSC  xAC.7
1152:  BRA    116C
1154:  BCF    FD8.0
1156:  RLCF   xA9,F
1158:  RLCF   xAA,F
115A:  RLCF   xAB,F
115C:  RLCF   xAC,F
115E:  DECF   00,F
1160:  BTFSC  FD8.2
1162:  BRA    12DC
1164:  BRA    1150
1166:  BSF    xA8.6
1168:  BRA    1244
116A:  BCF    xA8.6
116C:  MOVFF  69F,6A7
1170:  BTFSS  x9F.7
1172:  BRA    1178
1174:  BSF    xAC.7
1176:  BRA    12CE
1178:  BCF    xAC.7
117A:  BRA    12CE
117C:  MOVFF  6A2,6A6
1180:  MOVFF  6A2,00
1184:  MOVF   x9E,W
1186:  SUBWF  xA6,F
1188:  MOVFF  69F,6AC
118C:  BSF    xAC.7
118E:  MOVFF  6A0,6AB
1192:  MOVFF  6A1,6AA
1196:  CLRF   xA9
1198:  BCF    FD8.0
119A:  RRCF   xAC,F
119C:  RRCF   xAB,F
119E:  RRCF   xAA,F
11A0:  RRCF   xA9,F
11A2:  DECFSZ xA6,F
11A4:  BRA    1196
11A6:  BTFSS  xA7.7
11A8:  BRA    11B0
11AA:  BSF    xA8.1
11AC:  BRA    12E6
11AE:  BCF    xA8.1
11B0:  BCF    xA6.0
11B2:  BSF    xA8.5
11B4:  MOVLW  06
11B6:  MOVWF  FEA
11B8:  MOVLW  A5
11BA:  MOVWF  FE9
11BC:  BRA    130C
11BE:  BCF    xA8.5
11C0:  BTFSC  xA7.7
11C2:  BRA    11D8
11C4:  BTFSS  xA6.0
11C6:  BRA    11EE
11C8:  RRCF   xAC,F
11CA:  RRCF   xAB,F
11CC:  RRCF   xAA,F
11CE:  RRCF   xA9,F
11D0:  INCF   00,F
11D2:  BTFSC  FD8.2
11D4:  BRA    12DC
11D6:  BRA    11EE
11D8:  BTFSC  xAC.7
11DA:  BRA    11F4
11DC:  BCF    FD8.0
11DE:  RLCF   xA9,F
11E0:  RLCF   xAA,F
11E2:  RLCF   xAB,F
11E4:  RLCF   xAC,F
11E6:  DECF   00,F
11E8:  BTFSC  FD8.2
11EA:  BRA    12DC
11EC:  BRA    11D8
11EE:  BSF    xA8.7
11F0:  BRA    1244
11F2:  BCF    xA8.7
11F4:  MOVFF  6A3,6A7
11F8:  BTFSS  xA3.7
11FA:  BRA    1200
11FC:  BSF    xAC.7
11FE:  BRA    12CE
1200:  BCF    xAC.7
1202:  BRA    12CE
1204:  MOVFF  6A3,6AC
1208:  BSF    xAC.7
120A:  MOVFF  6A4,6AB
120E:  MOVFF  6A5,6AA
1212:  BTFSS  xA7.7
1214:  BRA    121E
1216:  BCF    xAC.7
1218:  BSF    xA8.2
121A:  BRA    12E6
121C:  BCF    xA8.2
121E:  CLRF   xA9
1220:  BCF    xA6.0
1222:  MOVLW  06
1224:  MOVWF  FEA
1226:  MOVLW  A1
1228:  MOVWF  FE9
122A:  BRA    130C
122C:  BTFSC  xA7.7
122E:  BRA    1268
1230:  MOVFF  69F,6A7
1234:  BTFSS  xA6.0
1236:  BRA    1244
1238:  RRCF   xAC,F
123A:  RRCF   xAB,F
123C:  RRCF   xAA,F
123E:  RRCF   xA9,F
1240:  INCF   00,F
1242:  BZ    12DC
1244:  BTFSS  xA9.7
1246:  BRA    125E
1248:  INCF   xAA,F
124A:  BNZ   125E
124C:  INCF   xAB,F
124E:  BNZ   125E
1250:  INCF   xAC,F
1252:  BNZ   125E
1254:  RRCF   xAC,F
1256:  RRCF   xAB,F
1258:  RRCF   xAA,F
125A:  INCF   00,F
125C:  BZ    12DC
125E:  BTFSC  xA8.6
1260:  BRA    116A
1262:  BTFSC  xA8.7
1264:  BRA    11F2
1266:  BRA    12A0
1268:  MOVLW  80
126A:  XORWF  xAC,F
126C:  BTFSS  xAC.7
126E:  BRA    1278
1270:  BRA    12E6
1272:  MOVFF  6A3,6A7
1276:  BRA    128C
1278:  MOVFF  69F,6A7
127C:  MOVF   xAC,F
127E:  BNZ   128C
1280:  MOVF   xAB,F
1282:  BNZ   128C
1284:  MOVF   xAA,F
1286:  BNZ   128C
1288:  CLRF   00
128A:  BRA    12CE
128C:  BTFSC  xAC.7
128E:  BRA    12A0
1290:  BCF    FD8.0
1292:  RLCF   xA9,F
1294:  RLCF   xAA,F
1296:  RLCF   xAB,F
1298:  RLCF   xAC,F
129A:  DECFSZ 00,F
129C:  BRA    128C
129E:  BRA    12DC
12A0:  BTFSS  xA7.7
12A2:  BRA    12A8
12A4:  BSF    xAC.7
12A6:  BRA    12CE
12A8:  BCF    xAC.7
12AA:  BRA    12CE
12AC:  MOVFF  6A2,00
12B0:  MOVFF  6A3,6AC
12B4:  MOVFF  6A4,6AB
12B8:  MOVFF  6A5,6AA
12BC:  BRA    12CE
12BE:  MOVFF  69E,00
12C2:  MOVFF  69F,6AC
12C6:  MOVFF  6A0,6AB
12CA:  MOVFF  6A1,6AA
12CE:  MOVFF  6AC,01
12D2:  MOVFF  6AB,02
12D6:  MOVFF  6AA,03
12DA:  BRA    1344
12DC:  CLRF   00
12DE:  CLRF   01
12E0:  CLRF   02
12E2:  CLRF   03
12E4:  BRA    1344
12E6:  CLRF   xA9
12E8:  COMF   xAA,F
12EA:  COMF   xAB,F
12EC:  COMF   xAC,F
12EE:  COMF   xA9,F
12F0:  INCF   xA9,F
12F2:  BNZ   12FE
12F4:  INCF   xAA,F
12F6:  BNZ   12FE
12F8:  INCF   xAB,F
12FA:  BNZ   12FE
12FC:  INCF   xAC,F
12FE:  BTFSC  xA8.0
1300:  BRA    1126
1302:  BTFSC  xA8.1
1304:  BRA    11AE
1306:  BTFSC  xA8.2
1308:  BRA    121C
130A:  BRA    1272
130C:  MOVF   FEF,W
130E:  ADDWF  xAA,F
1310:  BNC   131C
1312:  INCF   xAB,F
1314:  BNZ   131C
1316:  INCF   xAC,F
1318:  BTFSC  FD8.2
131A:  BSF    xA6.0
131C:  MOVF   FED,F
131E:  MOVF   FEF,W
1320:  ADDWF  xAB,F
1322:  BNC   132A
1324:  INCF   xAC,F
1326:  BTFSC  FD8.2
1328:  BSF    xA6.0
132A:  MOVF   FED,F
132C:  MOVF   FEF,W
132E:  BTFSC  FEF.7
1330:  BRA    1334
1332:  XORLW  80
1334:  ADDWF  xAC,F
1336:  BTFSC  FD8.0
1338:  BSF    xA6.0
133A:  BTFSC  xA8.4
133C:  BRA    1136
133E:  BTFSC  xA8.5
1340:  BRA    11BE
1342:  BRA    122C
1344:  MOVLB  0
1346:  RETURN 0
1348:  MOVFF  69F,6A6
134C:  MOVLB  6
134E:  MOVF   xA3,W
1350:  XORWF  xA6,F
1352:  BTFSS  xA6.7
1354:  BRA    1360
1356:  BCF    FD8.2
1358:  BCF    FD8.0
135A:  BTFSC  x9F.7
135C:  BSF    FD8.0
135E:  BRA    13BE
1360:  MOVFF  69F,6A6
1364:  MOVFF  6A2,6A7
1368:  MOVF   x9E,W
136A:  SUBWF  xA7,F
136C:  BZ    137A
136E:  BTFSS  xA6.7
1370:  BRA    13BE
1372:  MOVF   FD8,W
1374:  XORLW  01
1376:  MOVWF  FD8
1378:  BRA    13BE
137A:  MOVFF  6A3,6A7
137E:  MOVF   x9F,W
1380:  SUBWF  xA7,F
1382:  BZ    1390
1384:  BTFSS  xA6.7
1386:  BRA    13BE
1388:  MOVF   FD8,W
138A:  XORLW  01
138C:  MOVWF  FD8
138E:  BRA    13BE
1390:  MOVFF  6A4,6A7
1394:  MOVF   xA0,W
1396:  SUBWF  xA7,F
1398:  BZ    13A6
139A:  BTFSS  xA6.7
139C:  BRA    13BE
139E:  MOVF   FD8,W
13A0:  XORLW  01
13A2:  MOVWF  FD8
13A4:  BRA    13BE
13A6:  MOVFF  6A5,6A7
13AA:  MOVF   xA1,W
13AC:  SUBWF  xA7,F
13AE:  BZ    13BC
13B0:  BTFSS  xA6.7
13B2:  BRA    13BE
13B4:  MOVF   FD8,W
13B6:  XORLW  01
13B8:  MOVWF  FD8
13BA:  BRA    13BE
13BC:  BCF    FD8.0
13BE:  MOVLB  0
13C0:  RETURN 0
13C2:  MOVLB  6
13C4:  MOVF   xC0,W
13C6:  SUBLW  B6
13C8:  MOVWF  xC0
13CA:  CLRF   03
13CC:  MOVFF  6C1,6C4
13D0:  BSF    xC1.7
13D2:  BCF    FD8.0
13D4:  RRCF   xC1,F
13D6:  RRCF   xC2,F
13D8:  RRCF   xC3,F
13DA:  RRCF   03,F
13DC:  RRCF   02,F
13DE:  RRCF   01,F
13E0:  RRCF   00,F
13E2:  DECFSZ xC0,F
13E4:  BRA    13D2
13E6:  BTFSS  xC4.7
13E8:  BRA    1400
13EA:  COMF   00,F
13EC:  COMF   01,F
13EE:  COMF   02,F
13F0:  COMF   03,F
13F2:  INCF   00,F
13F4:  BTFSC  FD8.2
13F6:  INCF   01,F
13F8:  BTFSC  FD8.2
13FA:  INCF   02,F
13FC:  BTFSC  FD8.2
13FE:  INCF   03,F
1400:  MOVLB  0
1402:  GOTO   14F0 (RETURN)
1406:  BTFSC  FD8.1
1408:  BRA    1412
140A:  MOVLW  06
140C:  MOVWF  FEA
140E:  MOVLW  C8
1410:  MOVWF  FE9
1412:  CLRF   00
1414:  CLRF   01
1416:  CLRF   02
1418:  CLRF   03
141A:  MOVLB  6
141C:  CLRF   xC8
141E:  CLRF   xC9
1420:  CLRF   xCA
1422:  CLRF   xCB
1424:  MOVF   xC7,W
1426:  IORWF  xC6,W
1428:  IORWF  xC5,W
142A:  IORWF  xC4,W
142C:  BZ    1486
142E:  MOVLW  20
1430:  MOVWF  xCC
1432:  BCF    FD8.0
1434:  RLCF   xC0,F
1436:  RLCF   xC1,F
1438:  RLCF   xC2,F
143A:  RLCF   xC3,F
143C:  RLCF   xC8,F
143E:  RLCF   xC9,F
1440:  RLCF   xCA,F
1442:  RLCF   xCB,F
1444:  MOVF   xC7,W
1446:  SUBWF  xCB,W
1448:  BNZ   145A
144A:  MOVF   xC6,W
144C:  SUBWF  xCA,W
144E:  BNZ   145A
1450:  MOVF   xC5,W
1452:  SUBWF  xC9,W
1454:  BNZ   145A
1456:  MOVF   xC4,W
1458:  SUBWF  xC8,W
145A:  BNC   147A
145C:  MOVF   xC4,W
145E:  SUBWF  xC8,F
1460:  MOVF   xC5,W
1462:  BTFSS  FD8.0
1464:  INCFSZ xC5,W
1466:  SUBWF  xC9,F
1468:  MOVF   xC6,W
146A:  BTFSS  FD8.0
146C:  INCFSZ xC6,W
146E:  SUBWF  xCA,F
1470:  MOVF   xC7,W
1472:  BTFSS  FD8.0
1474:  INCFSZ xC7,W
1476:  SUBWF  xCB,F
1478:  BSF    FD8.0
147A:  RLCF   00,F
147C:  RLCF   01,F
147E:  RLCF   02,F
1480:  RLCF   03,F
1482:  DECFSZ xCC,F
1484:  BRA    1432
1486:  MOVFF  6C8,FEF
148A:  MOVFF  6C9,FEC
148E:  MOVFF  6CA,FEC
1492:  MOVFF  6CB,FEC
1496:  MOVLB  0
1498:  RETURN 0
149A:  MOVF   FE9,W
149C:  MOVLB  6
149E:  MOVWF  xB8
14A0:  MOVF   xB7,W
14A2:  MOVWF  xBA
14A4:  BZ    14DC
14A6:  MOVFF  6B6,6C3
14AA:  MOVFF  6B5,6C2
14AE:  MOVFF  6B4,6C1
14B2:  MOVFF  6B3,6C0
14B6:  CLRF   xC7
14B8:  CLRF   xC6
14BA:  MOVLW  20
14BC:  MOVWF  xC5
14BE:  MOVLW  82
14C0:  MOVWF  xC4
14C2:  MOVLB  0
14C4:  RCALL  0FDA
14C6:  MOVFF  03,6B6
14CA:  MOVFF  02,6B5
14CE:  MOVFF  01,6B4
14D2:  MOVFF  00,6B3
14D6:  MOVLB  6
14D8:  DECFSZ xBA,F
14DA:  BRA    14A6
14DC:  MOVFF  6B6,6C3
14E0:  MOVFF  6B5,6C2
14E4:  MOVFF  6B4,6C1
14E8:  MOVFF  6B3,6C0
14EC:  MOVLB  0
14EE:  BRA    13C2
14F0:  MOVFF  03,6B6
14F4:  MOVFF  02,6B5
14F8:  MOVFF  01,6B4
14FC:  MOVFF  00,6B3
1500:  MOVLB  6
1502:  BTFSS  xB6.7
1504:  BRA    1520
1506:  DECF   xB8,F
1508:  BSF    xB8.5
150A:  COMF   xB3,F
150C:  COMF   xB4,F
150E:  COMF   xB5,F
1510:  COMF   xB6,F
1512:  INCF   xB3,F
1514:  BTFSC  FD8.2
1516:  INCF   xB4,F
1518:  BTFSC  FD8.2
151A:  INCF   xB5,F
151C:  BTFSC  FD8.2
151E:  INCF   xB6,F
1520:  MOVLW  3B
1522:  MOVWF  xBF
1524:  MOVLW  9A
1526:  MOVWF  xBE
1528:  MOVLW  CA
152A:  MOVWF  xBD
152C:  CLRF   xBC
152E:  MOVLW  0A
1530:  MOVWF  xBA
1532:  MOVF   xB7,W
1534:  BTFSC  FD8.2
1536:  INCF   xB8,F
1538:  BSF    FD8.1
153A:  MOVLW  06
153C:  MOVWF  FEA
153E:  MOVLW  B3
1540:  MOVWF  FE9
1542:  MOVFF  6B6,6C3
1546:  MOVFF  6B5,6C2
154A:  MOVFF  6B4,6C1
154E:  MOVFF  6B3,6C0
1552:  MOVFF  6BF,6C7
1556:  MOVFF  6BE,6C6
155A:  MOVFF  6BD,6C5
155E:  MOVFF  6BC,6C4
1562:  MOVLB  0
1564:  RCALL  1406
1566:  MOVF   01,W
1568:  MOVF   00,F
156A:  BNZ   1592
156C:  MOVLB  6
156E:  INCF   xB7,W
1570:  SUBWF  xBA,W
1572:  BTFSS  FD8.2
1574:  BRA    157A
1576:  MOVLB  0
1578:  BRA    1592
157A:  MOVF   xB8,W
157C:  BZ    1598
157E:  ANDLW  0F
1580:  SUBWF  xBA,W
1582:  BZ    1586
1584:  BC    1614
1586:  BTFSC  xB8.7
1588:  BRA    1614
158A:  BTFSC  xB8.6
158C:  BRA    1598
158E:  MOVLW  20
1590:  BRA    1606
1592:  MOVLW  20
1594:  MOVLB  6
1596:  ANDWF  xB8,F
1598:  BTFSS  xB8.5
159A:  BRA    15BC
159C:  BCF    xB8.5
159E:  MOVF   xB7,W
15A0:  BTFSS  FD8.2
15A2:  DECF   xB8,F
15A4:  MOVF   00,W
15A6:  MOVWF  xB8
15A8:  MOVLW  2D
15AA:  MOVLB  7
15AC:  MOVWF  x1A
15AE:  MOVLB  0
15B0:  CALL   0B1C
15B4:  MOVLB  6
15B6:  MOVF   xB8,W
15B8:  MOVWF  00
15BA:  CLRF   xB8
15BC:  MOVF   xB7,W
15BE:  SUBWF  xBA,W
15C0:  BNZ   15DE
15C2:  MOVF   00,W
15C4:  MOVWF  xB8
15C6:  MOVLW  2E
15C8:  MOVLB  7
15CA:  MOVWF  x1A
15CC:  MOVLB  0
15CE:  CALL   0B1C
15D2:  MOVLB  6
15D4:  MOVF   xB8,W
15D6:  MOVWF  00
15D8:  MOVLW  20
15DA:  ANDWF  xB8,F
15DC:  MOVLW  00
15DE:  MOVLW  30
15E0:  BTFSS  xB8.5
15E2:  BRA    1606
15E4:  BCF    xB8.5
15E6:  MOVF   xB7,W
15E8:  BTFSS  FD8.2
15EA:  DECF   xB8,F
15EC:  MOVF   00,W
15EE:  MOVWF  xB8
15F0:  MOVLW  2D
15F2:  MOVLB  7
15F4:  MOVWF  x1A
15F6:  MOVLB  0
15F8:  CALL   0B1C
15FC:  MOVLB  6
15FE:  MOVF   xB8,W
1600:  MOVWF  00
1602:  CLRF   xB8
1604:  MOVLW  30
1606:  ADDWF  00,F
1608:  MOVFF  00,71A
160C:  MOVLB  0
160E:  CALL   0B1C
1612:  MOVLB  6
1614:  BCF    FD8.1
1616:  MOVFF  6BF,6C3
161A:  MOVFF  6BE,6C2
161E:  MOVFF  6BD,6C1
1622:  MOVFF  6BC,6C0
1626:  CLRF   xC7
1628:  CLRF   xC6
162A:  CLRF   xC5
162C:  MOVLW  0A
162E:  MOVWF  xC4
1630:  MOVLB  0
1632:  RCALL  1406
1634:  MOVFF  03,6BF
1638:  MOVFF  02,6BE
163C:  MOVFF  01,6BD
1640:  MOVFF  00,6BC
1644:  MOVLB  6
1646:  DECFSZ xBA,F
1648:  BRA    1538
164A:  MOVLB  0
164C:  RETURN 0
*
1694:  MOVF   FEF,F
1696:  BZ    16B6
1698:  MOVFF  FEA,69F
169C:  MOVFF  FE9,69E
16A0:  MOVFF  FEF,6A6
16A4:  RCALL  164E
16A6:  MOVFF  69F,FEA
16AA:  MOVFF  69E,FE9
16AE:  INCF   FE9,F
16B0:  BTFSC  FD8.2
16B2:  INCF   FEA,F
16B4:  BRA    1694
16B6:  RETURN 0
*
19F8:  MOVLW  B6
19FA:  MOVWF  00
19FC:  CLRF   03
19FE:  CLRF   02
1A00:  CLRF   01
1A02:  MOVLB  6
1A04:  MOVF   x6B,W
1A06:  IORWF  x6C,W
1A08:  IORWF  x6D,W
1A0A:  IORWF  x6E,W
1A0C:  BNZ   1A12
1A0E:  CLRF   00
1A10:  BRA    1A2C
1A12:  BCF    FD8.0
1A14:  BTFSC  01.7
1A16:  BRA    1A2A
1A18:  RLCF   x6B,F
1A1A:  RLCF   x6C,F
1A1C:  RLCF   x6D,F
1A1E:  RLCF   x6E,F
1A20:  RLCF   03,F
1A22:  RLCF   02,F
1A24:  RLCF   01,F
1A26:  DECFSZ 00,F
1A28:  BRA    1A12
1A2A:  BCF    01.7
1A2C:  MOVLB  0
1A2E:  GOTO   2E16 (RETURN)
1A32:  TBLRD*+
1A34:  MOVF   FF5,F
1A36:  BZ    1A50
1A38:  MOVFF  FF6,66B
1A3C:  MOVFF  FF7,66C
1A40:  MOVFF  FF5,6A6
1A44:  RCALL  164E
1A46:  MOVFF  66B,FF6
1A4A:  MOVFF  66C,FF7
1A4E:  BRA    1A32
1A50:  RETURN 0
*
1DC4:  TSTFSZ 01
1DC6:  BRA    1DCE
1DC8:  TSTFSZ 02
1DCA:  BRA    1DD0
1DCC:  BRA    1DDC
1DCE:  INCF   02,F
1DD0:  MOVFF  00,FEE
1DD4:  DECFSZ 01,F
1DD6:  BRA    1DD0
1DD8:  DECFSZ 02,F
1DDA:  BRA    1DD0
1DDC:  RETURN 0
*
2326:  MOVLB  6
2328:  CLRF   xCF
232A:  CLRF   xD0
232C:  MOVLW  01
232E:  MOVWF  xD1
2330:  CLRF   FDA
2332:  CLRF   FD9
2334:  MOVLW  06
2336:  MOVWF  xD4
2338:  MOVLW  C7
233A:  MOVWF  xD3
233C:  MOVLW  06
233E:  MOVWF  FEA
2340:  MOVLW  CB
2342:  MOVWF  FE9
2344:  MOVFF  6D4,FE2
2348:  MOVFF  6D3,FE1
234C:  MOVFF  6D1,6D2
2350:  BCF    FD8.0
2352:  MOVF   FE5,W
2354:  MULWF  FEE
2356:  MOVF   FF3,W
2358:  ADDWFC xCF,F
235A:  MOVF   FF4,W
235C:  ADDWFC xD0,F
235E:  DECFSZ xD2,F
2360:  BRA    2350
2362:  MOVFF  6CF,FDE
2366:  MOVFF  6D0,6CF
236A:  CLRF   xD0
236C:  BTFSC  FD8.0
236E:  INCF   xD0,F
2370:  INCF   xD3,F
2372:  BTFSC  FD8.2
2374:  INCF   xD4,F
2376:  INCF   xD1,F
2378:  MOVF   xD1,W
237A:  SUBLW  05
237C:  BNZ   233C
237E:  MOVLB  0
2380:  RETURN 0
*
2474:  MOVF   FE9,W
2476:  MOVLB  6
2478:  MOVWF  xB7
247A:  MOVLW  3B
247C:  MOVWF  xBE
247E:  MOVLW  9A
2480:  MOVWF  xBD
2482:  MOVLW  CA
2484:  MOVWF  xBC
2486:  CLRF   xBB
2488:  MOVLW  0A
248A:  MOVWF  xB9
248C:  BSF    FD8.1
248E:  MOVLW  06
2490:  MOVWF  FEA
2492:  MOVLW  B3
2494:  MOVWF  FE9
2496:  MOVFF  6B6,6C3
249A:  MOVFF  6B5,6C2
249E:  MOVFF  6B4,6C1
24A2:  MOVFF  6B3,6C0
24A6:  MOVFF  6BE,6C7
24AA:  MOVFF  6BD,6C6
24AE:  MOVFF  6BC,6C5
24B2:  MOVFF  6BB,6C4
24B6:  MOVLB  0
24B8:  CALL   1406
24BC:  MOVF   01,W
24BE:  MOVF   00,F
24C0:  BNZ   24E8
24C2:  MOVLB  6
24C4:  MOVF   xB9,W
24C6:  XORLW  01
24C8:  BTFSS  FD8.2
24CA:  BRA    24D0
24CC:  MOVLB  0
24CE:  BRA    24E8
24D0:  MOVF   xB7,W
24D2:  BZ    24EC
24D4:  ANDLW  0F
24D6:  SUBWF  xB9,W
24D8:  BZ    24DC
24DA:  BC    24FC
24DC:  BTFSC  xB7.7
24DE:  BRA    24FC
24E0:  BTFSC  xB7.6
24E2:  BRA    24EC
24E4:  MOVLW  20
24E6:  BRA    24EE
24E8:  MOVLB  6
24EA:  CLRF   xB7
24EC:  MOVLW  30
24EE:  ADDWF  00,F
24F0:  MOVFF  00,71A
24F4:  MOVLB  0
24F6:  CALL   0B1C
24FA:  MOVLB  6
24FC:  BCF    FD8.1
24FE:  MOVFF  6BE,6C3
2502:  MOVFF  6BD,6C2
2506:  MOVFF  6BC,6C1
250A:  MOVFF  6BB,6C0
250E:  CLRF   xC7
2510:  CLRF   xC6
2512:  CLRF   xC5
2514:  MOVLW  0A
2516:  MOVWF  xC4
2518:  MOVLB  0
251A:  CALL   1406
251E:  MOVFF  03,6BE
2522:  MOVFF  02,6BD
2526:  MOVFF  01,6BC
252A:  MOVFF  00,6BB
252E:  MOVLB  6
2530:  DECFSZ xB9,F
2532:  BRA    248C
2534:  MOVLB  0
2536:  RETURN 0
2538:  MOVLB  6
253A:  MOVF   xB6,W
253C:  CLRF   01
253E:  SUBWF  xB5,W
2540:  BC    2548
2542:  MOVFF  6B5,00
2546:  BRA    2560
2548:  CLRF   00
254A:  MOVLW  08
254C:  MOVWF  xB7
254E:  RLCF   xB5,F
2550:  RLCF   00,F
2552:  MOVF   xB6,W
2554:  SUBWF  00,W
2556:  BTFSC  FD8.0
2558:  MOVWF  00
255A:  RLCF   01,F
255C:  DECFSZ xB7,F
255E:  BRA    254E
2560:  MOVLB  0
2562:  RETURN 0
2564:  MOVF   01,W
2566:  MOVFF  6B3,6B5
256A:  MOVLW  64
256C:  MOVLB  6
256E:  MOVWF  xB6
2570:  MOVLB  0
2572:  RCALL  2538
2574:  MOVFF  00,6B3
2578:  MOVF   01,W
257A:  MOVLW  30
257C:  BNZ   258E
257E:  MOVLB  6
2580:  BTFSS  xB4.1
2582:  BRA    25A4
2584:  BTFSC  xB4.3
2586:  BRA    25A4
2588:  BTFSC  xB4.4
258A:  MOVLW  20
258C:  BRA    2596
258E:  MOVLB  6
2590:  BCF    xB4.3
2592:  BCF    xB4.4
2594:  BSF    xB4.0
2596:  ADDWF  01,F
2598:  MOVFF  01,71A
259C:  MOVLB  0
259E:  CALL   0B1C
25A2:  MOVLB  6
25A4:  MOVFF  6B3,6B5
25A8:  MOVLW  0A
25AA:  MOVWF  xB6
25AC:  MOVLB  0
25AE:  RCALL  2538
25B0:  MOVFF  00,6B3
25B4:  MOVF   01,W
25B6:  MOVLW  30
25B8:  BNZ   25CA
25BA:  MOVLB  6
25BC:  BTFSC  xB4.3
25BE:  BRA    25D6
25C0:  BTFSS  xB4.0
25C2:  BRA    25D6
25C4:  BTFSC  xB4.4
25C6:  MOVLW  20
25C8:  MOVLB  0
25CA:  ADDWF  01,F
25CC:  MOVFF  01,71A
25D0:  CALL   0B1C
25D4:  MOVLB  6
25D6:  MOVLW  30
25D8:  ADDWF  xB3,F
25DA:  MOVFF  6B3,71A
25DE:  MOVLB  0
25E0:  CALL   0B1C
25E4:  GOTO   2CA6 (RETURN)
*
2F5A:  TBLRD*+
2F5C:  MOVFF  FF6,69C
2F60:  MOVFF  FF7,69D
2F64:  MOVFF  FF5,6A6
2F68:  CALL   164E
2F6C:  MOVFF  69C,FF6
2F70:  MOVFF  69D,FF7
2F74:  MOVLB  6
2F76:  DECFSZ x9B,F
2F78:  BRA    2F7C
2F7A:  BRA    2F80
2F7C:  MOVLB  0
2F7E:  BRA    2F5A
2F80:  MOVLB  0
2F82:  RETURN 0
2F84:  MOVF   FE9,W
2F86:  MOVLB  6
2F88:  MOVWF  x9E
2F8A:  MOVLW  3B
2F8C:  MOVWF  xA5
2F8E:  MOVLW  9A
2F90:  MOVWF  xA4
2F92:  MOVLW  CA
2F94:  MOVWF  xA3
2F96:  CLRF   xA2
2F98:  MOVLW  0A
2F9A:  MOVWF  xA0
2F9C:  BSF    FD8.1
2F9E:  MOVLW  06
2FA0:  MOVWF  FEA
2FA2:  MOVLW  9A
2FA4:  MOVWF  FE9
2FA6:  MOVFF  69D,6C3
2FAA:  MOVFF  69C,6C2
2FAE:  MOVFF  69B,6C1
2FB2:  MOVFF  69A,6C0
2FB6:  MOVFF  6A5,6C7
2FBA:  MOVFF  6A4,6C6
2FBE:  MOVFF  6A3,6C5
2FC2:  MOVFF  6A2,6C4
2FC6:  MOVLB  0
2FC8:  CALL   1406
2FCC:  MOVF   01,W
2FCE:  MOVF   00,F
2FD0:  BNZ   2FF8
2FD2:  MOVLB  6
2FD4:  MOVF   xA0,W
2FD6:  XORLW  01
2FD8:  BTFSS  FD8.2
2FDA:  BRA    2FE0
2FDC:  MOVLB  0
2FDE:  BRA    2FF8
2FE0:  MOVF   x9E,W
2FE2:  BZ    2FFC
2FE4:  ANDLW  0F
2FE6:  SUBWF  xA0,W
2FE8:  BZ    2FEC
2FEA:  BC    300C
2FEC:  BTFSC  x9E.7
2FEE:  BRA    300C
2FF0:  BTFSC  x9E.6
2FF2:  BRA    2FFC
2FF4:  MOVLW  20
2FF6:  BRA    2FFE
2FF8:  MOVLB  6
2FFA:  CLRF   x9E
2FFC:  MOVLW  30
2FFE:  ADDWF  00,F
3000:  MOVFF  00,6A6
3004:  MOVLB  0
3006:  CALL   164E
300A:  MOVLB  6
300C:  BCF    FD8.1
300E:  MOVFF  6A5,6C3
3012:  MOVFF  6A4,6C2
3016:  MOVFF  6A3,6C1
301A:  MOVFF  6A2,6C0
301E:  CLRF   xC7
3020:  CLRF   xC6
3022:  CLRF   xC5
3024:  MOVLW  0A
3026:  MOVWF  xC4
3028:  MOVLB  0
302A:  CALL   1406
302E:  MOVFF  03,6A5
3032:  MOVFF  02,6A4
3036:  MOVFF  01,6A3
303A:  MOVFF  00,6A2
303E:  MOVLB  6
3040:  DECFSZ xA0,F
3042:  BRA    2F9C
3044:  MOVLB  0
3046:  RETURN 0
*
30A6:  MOVF   01,W
30A8:  MOVFF  69B,6B5
30AC:  MOVLW  64
30AE:  MOVLB  6
30B0:  MOVWF  xB6
30B2:  MOVLB  0
30B4:  CALL   2538
30B8:  MOVFF  00,69B
30BC:  MOVF   01,W
30BE:  MOVLW  30
30C0:  BNZ   30D2
30C2:  MOVLB  6
30C4:  BTFSS  x9C.1
30C6:  BRA    30E8
30C8:  BTFSC  x9C.3
30CA:  BRA    30E8
30CC:  BTFSC  x9C.4
30CE:  MOVLW  20
30D0:  BRA    30DA
30D2:  MOVLB  6
30D4:  BCF    x9C.3
30D6:  BCF    x9C.4
30D8:  BSF    x9C.0
30DA:  ADDWF  01,F
30DC:  MOVFF  01,6A6
30E0:  MOVLB  0
30E2:  CALL   164E
30E6:  MOVLB  6
30E8:  MOVFF  69B,6B5
30EC:  MOVLW  0A
30EE:  MOVWF  xB6
30F0:  MOVLB  0
30F2:  CALL   2538
30F6:  MOVFF  00,69B
30FA:  MOVF   01,W
30FC:  MOVLW  30
30FE:  BNZ   3110
3100:  MOVLB  6
3102:  BTFSC  x9C.3
3104:  BRA    311C
3106:  BTFSS  x9C.0
3108:  BRA    311C
310A:  BTFSC  x9C.4
310C:  MOVLW  20
310E:  MOVLB  0
3110:  ADDWF  01,F
3112:  MOVFF  01,6A6
3116:  CALL   164E
311A:  MOVLB  6
311C:  MOVLW  30
311E:  ADDWF  x9B,F
3120:  MOVFF  69B,6A6
3124:  MOVLB  0
3126:  CALL   164E
312A:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,NOPROTECT,NOLVP,MCLR,HSPLL,PLL4 
.................... #device PASS_STRINGS=IN_RAM,adc=10 
.................... #use delay(clock=16000000) 
*
0AF2:  MOVLW  07
0AF4:  MOVWF  FEA
0AF6:  MOVLW  26
0AF8:  MOVWF  FE9
0AFA:  MOVF   FEF,W
0AFC:  BZ    0B1A
0AFE:  MOVLW  05
0B00:  MOVWF  01
0B02:  CLRF   00
0B04:  DECFSZ 00,F
0B06:  BRA    0B04
0B08:  DECFSZ 01,F
0B0A:  BRA    0B02
0B0C:  MOVLW  2E
0B0E:  MOVWF  00
0B10:  DECFSZ 00,F
0B12:  BRA    0B10
0B14:  BRA    0B16
0B16:  DECFSZ FEF,F
0B18:  BRA    0AFE
0B1A:  RETURN 0
.................... #use rs232(uart1,baud=115200, xmit=PIN_C6, rcv=PIN_C7, stream = SIM800L_SERIAL, ERRORS) 
*
05C6:  BTFSS  F9E.5
05C8:  BRA    05C6
05CA:  MOVFF  FAB,16
05CE:  MOVFF  FAE,01
05D2:  BTFSS  16.1
05D4:  BRA    05DA
05D6:  BCF    FAB.4
05D8:  BSF    FAB.4
05DA:  RETURN 0
*
0C42:  BTFSS  F9E.4
0C44:  BRA    0C42
0C46:  MOVWF  FAD
0C48:  GOTO   0CC2 (RETURN)
.................... #use rs232(baud=9600, xmit=PIN_B2, rcv=PIN_B3, stream = MONITOR_SERIAL) 
*
164E:  BCF    F93.2
1650:  BCF    F8A.2
1652:  MOVLW  08
1654:  MOVWF  01
1656:  BRA    1658
1658:  NOP   
165A:  BSF    01.7
165C:  BRA    167E
165E:  BCF    01.7
1660:  MOVLB  6
1662:  RRCF   xA6,F
1664:  MOVLB  0
1666:  BTFSC  FD8.0
1668:  BSF    F8A.2
166A:  BTFSS  FD8.0
166C:  BCF    F8A.2
166E:  BSF    01.6
1670:  BRA    167E
1672:  BCF    01.6
1674:  DECFSZ 01,F
1676:  BRA    1660
1678:  BRA    167A
167A:  NOP   
167C:  BSF    F8A.2
167E:  MOVLW  84
1680:  MOVWF  FE9
1682:  DECFSZ FE9,F
1684:  BRA    1682
1686:  BRA    1688
1688:  NOP   
168A:  BTFSC  01.7
168C:  BRA    165E
168E:  BTFSC  01.6
1690:  BRA    1672
1692:  RETURN 0
.................... #use fast_io (ALL) 
.................... #priority ext,rda, rtcc, 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0BB4:  MOVFF  729,03
0BB8:  MOVLB  7
0BBA:  MOVFF  728,FE9
0BBE:  MOVFF  729,FEA
0BC2:  MOVF   FEF,F
0BC4:  BZ    0C38
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0BC6:  MOVFF  729,72D
0BCA:  MOVFF  728,72C
0BCE:  MOVFF  72B,72F
0BD2:  MOVFF  72A,72E
0BD6:  MOVFF  72F,03
0BDA:  MOVFF  72E,FE9
0BDE:  MOVFF  72F,FEA
0BE2:  MOVF   FEF,F
0BE4:  BZ    0C12
0BE6:  MOVFF  72C,FE9
0BEA:  MOVFF  72D,FEA
0BEE:  MOVFF  FEF,730
0BF2:  MOVFF  72F,03
0BF6:  MOVFF  72E,FE9
0BFA:  MOVFF  72F,FEA
0BFE:  MOVF   FEF,W
0C00:  SUBWF  x30,W
0C02:  BNZ   0C12
0C04:  INCF   x2C,F
0C06:  BTFSC  FD8.2
0C08:  INCF   x2D,F
0C0A:  INCF   x2E,F
0C0C:  BTFSC  FD8.2
0C0E:  INCF   x2F,F
0C10:  BRA    0BD6
....................  
....................       if (*t == '\0') 
0C12:  MOVFF  72F,03
0C16:  MOVFF  72E,FE9
0C1A:  MOVFF  03,FEA
0C1E:  MOVF   FEF,F
0C20:  BNZ   0C2C
....................          return s1; 
0C22:  MOVFF  728,01
0C26:  MOVFF  729,02
0C2A:  BRA    0C3E
....................       ++s1; 
0C2C:  INCF   x28,F
0C2E:  BTFSC  FD8.2
0C30:  INCF   x29,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0C32:  MOVLB  0
0C34:  BRA    0BB4
0C36:  MOVLB  7
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
0C38:  MOVLW  00
0C3A:  MOVWF  01
0C3C:  MOVWF  02
0C3E:  MOVLB  0
0C40:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam); 
.................... void Calcula_SOC(); 
.................... void Obtem_SOH(); 
.................... void le_EEPROM (void); 
....................  
.................... #ENDIF 
....................  
.................... #include "SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
.................... #include"Serial.h" 
.................... #IFNDEF SERIAL_H 
.................... #DEFINE SERIAL_H 
....................  
.................... #define  SMS_COMMAND             1 
.................... #define  SMS_READ_COMMAND        2            
....................  
.................... void Executa_Comando(char comando); 
.................... char Get_Comando(); 
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao); 
.................... void get_numero(int nro_caracteres, int posicao, char *destino); 
.................... void clear_command(); 
....................  
.................... #include"Serial.c" 
.................... #include"SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
....................  
.................... #ENDIF 
....................  
.................... #include"TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam); 
.................... void Calcula_SOC(); 
.................... void Obtem_SOH(); 
.................... void le_EEPROM (void); 
....................  
.................... #ENDIF 
....................  
.................... #include"numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
.................... void obtem_numero(int8 pos_num, char *numero); 
....................  
.................... #include"numeros.c" 
.................... char numeros[50]; 
.................... extern int8 qtd_numeros; 
.................... char *posicao_numero; 
....................  
.................... int1 insere_numero(char *numero){ // >+5531995822739>+5531995822739>+5531995822739 
*
1C68:  MOVF   4F,W
1C6A:  MULLW  0F
1C6C:  MOVFF  FF3,6B5
1C70:  MOVLB  6
1C72:  CLRF   xB6
....................   
....................   int8 index = qtd_numeros*15; 
....................   int8 index_2 = 0; 
....................  
....................   if(qtd_numeros == 3){ 
1C74:  MOVF   4F,W
1C76:  SUBLW  03
1C78:  BNZ   1C80
....................  
....................     return 0; 
1C7A:  MOVLW  00
1C7C:  MOVWF  01
1C7E:  BRA    1D24
....................  
....................   } 
....................  
....................   posicao_numero = strstr(numeros,numero); 
1C80:  MOVLB  7
1C82:  CLRF   x29
1C84:  MOVLW  1D
1C86:  MOVWF  x28
1C88:  MOVFF  6B4,72B
1C8C:  MOVFF  6B3,72A
1C90:  MOVLB  0
1C92:  CALL   0BB4
1C96:  MOVFF  02,51
1C9A:  MOVFF  01,50
....................    
....................   if(posicao_numero == 0){ 
1C9E:  MOVF   50,F
1CA0:  BNZ   1D1E
1CA2:  MOVF   51,F
1CA4:  BNZ   1D1E
....................  
....................     numeros[index] ='>'; 
1CA6:  CLRF   03
1CA8:  MOVLB  6
1CAA:  MOVF   xB5,W
1CAC:  ADDLW  1D
1CAE:  MOVWF  FE9
1CB0:  MOVLW  00
1CB2:  ADDWFC 03,W
1CB4:  MOVWF  FEA
1CB6:  MOVLW  3E
1CB8:  MOVWF  FEF
....................      
....................     for(index = index+1;numero[index_2]!='\0';index++){ 
1CBA:  MOVLW  01
1CBC:  ADDWF  xB5,F
1CBE:  CLRF   03
1CC0:  MOVF   xB6,W
1CC2:  ADDWF  xB3,W
1CC4:  MOVWF  FE9
1CC6:  MOVF   xB4,W
1CC8:  ADDWFC 03,W
1CCA:  MOVWF  FEA
1CCC:  MOVF   FEF,F
1CCE:  BZ    1D04
....................       
....................       numeros[index] = numero[index_2]; 
1CD0:  CLRF   03
1CD2:  MOVF   xB5,W
1CD4:  ADDLW  1D
1CD6:  MOVWF  01
1CD8:  MOVLW  00
1CDA:  ADDWFC 03,F
1CDC:  MOVFF  03,6B8
1CE0:  CLRF   03
1CE2:  MOVF   xB6,W
1CE4:  ADDWF  xB3,W
1CE6:  MOVWF  FE9
1CE8:  MOVF   xB4,W
1CEA:  ADDWFC 03,W
1CEC:  MOVWF  FEA
1CEE:  MOVFF  FEF,6B9
1CF2:  MOVFF  6B8,FEA
1CF6:  MOVFF  01,FE9
1CFA:  MOVFF  6B9,FEF
....................       index_2++; 
1CFE:  INCF   xB6,F
1D00:  INCF   xB5,F
1D02:  BRA    1CBE
....................         
....................     } 
....................     numeros[index]='\0'; 
1D04:  CLRF   03
1D06:  MOVF   xB5,W
1D08:  ADDLW  1D
1D0A:  MOVWF  FE9
1D0C:  MOVLW  00
1D0E:  ADDWFC 03,W
1D10:  MOVWF  FEA
1D12:  CLRF   FEF
....................     qtd_numeros++; 
1D14:  INCF   4F,F
....................     return 1; 
1D16:  MOVLW  01
1D18:  MOVWF  01
1D1A:  BRA    1D24
1D1C:  MOVLB  0
....................    
....................   } 
....................   return 0; 
1D1E:  MOVLW  00
1D20:  MOVWF  01
1D22:  MOVLB  6
1D24:  MOVLB  0
1D26:  GOTO   272E (RETURN)
.................... } 
....................  
.................... void obtem_numero(int8 pos_num, char *numero){ 
*
3048:  MOVLB  6
304A:  CLRF   x9D
304C:  CLRF   x9E
....................  
....................   int8 index = 0; 
....................   int8 index_2 = 0; 
....................  
....................   if(pos_num>qtd_numeros) return; 
304E:  MOVF   x9A,W
3050:  SUBWF  4F,W
3052:  BTFSS  FD8.0
3054:  BRA    30A0
....................  
....................   for(index = ((pos_num*15)+1); index<(pos_num+1)*15;index++){ 
3056:  MOVF   x9A,W
3058:  MULLW  0F
305A:  MOVF   FF3,W
305C:  ADDLW  01
305E:  MOVWF  x9D
3060:  MOVLW  01
3062:  ADDWF  x9A,W
3064:  MULLW  0F
3066:  MOVF   FF3,W
3068:  SUBWF  x9D,W
306A:  BC    30A0
....................  
....................     numero[index_2] = numeros[index]; 
306C:  CLRF   03
306E:  MOVF   x9E,W
3070:  ADDWF  x9B,W
3072:  MOVWF  01
3074:  MOVF   x9C,W
3076:  ADDWFC 03,F
3078:  MOVFF  03,6A0
307C:  CLRF   03
307E:  MOVF   x9D,W
3080:  ADDLW  1D
3082:  MOVWF  FE9
3084:  MOVLW  00
3086:  ADDWFC 03,W
3088:  MOVWF  FEA
308A:  MOVFF  FEF,6A1
308E:  MOVFF  6A0,FEA
3092:  MOVFF  01,FE9
3096:  MOVFF  6A1,FEF
....................     index_2++; 
309A:  INCF   x9E,F
309C:  INCF   x9D,F
309E:  BRA    3060
....................   }   
....................    
....................   return; 
30A0:  MOVLB  0
30A2:  GOTO   324A (RETURN)
....................  
.................... } 
....................  
.................... void limpa_numeros(){ 
....................  
....................   qtd_numeros = 0; 
*
1DDE:  CLRF   4F
....................   memset (numeros, 0x00, sizeof(numeros)); 
1DE0:  CLRF   FEA
1DE2:  MOVLW  1D
1DE4:  MOVWF  FE9
1DE6:  CLRF   00
1DE8:  CLRF   02
1DEA:  MOVLW  32
1DEC:  MOVWF  01
1DEE:  RCALL  1DC4
1DF0:  GOTO   27F2 (RETURN)
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include "Memory.h" 
.................... #IFNDEF MEMORY_H 
.................... #DEFINE MEMORY_H 
....................  
.................... //*********************************** ENDERECOS EEPROM *******************************************  
....................  
.................... #define ADDR_tempo_entre_alertas              getenv("EEPROM_ADDRESS") + 0  //int32 
.................... #define ADDR_tempo_ultimo_alerta              getenv("EEPROM_ADDRESS") + 4  //int32 
.................... #define ADDR_corrente_limite                  getenv("EEPROM_ADDRESS") + 8  //int32 
.................... #define ADDR_zero_set                         getenv("EEPROM_ADDRESS") + 12 //int32 
.................... #define ADDR_qtd_numeros                      getenv("EEPROM_ADDRESS") + 16 //int8 
.................... #define ADDR_vector_numeros                   getenv("EEPROM_ADDRESS") + 17 //Vetor int 8 com 50 posicoes 
....................  
.................... //************************************************************************************************* 
....................  
.................... //************************************ DEAFULT EEPROM ********************************************* 
....................  
.................... #rom int32 ADDR_tempo_entre_alertas = {0} 
.................... #rom int32 ADDR_tempo_ultimo_alerta = {0}  
.................... #rom int32 ADDR_corrente_limite = {0}  
.................... #rom int32 ADDR_zero_set = {0}  
.................... #rom int8  ADDR_qtd_numeros = {0}  
.................... #rom int8  ADDR_vector_numeros = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} 
....................  
.................... //************************************************************************************************* 
....................  
....................  
.................... void read_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
.................... void write_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
....................  
.................... #include "Memory.c" 
.................... void write_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count) { 
....................     
....................   address -= getenv("EEPROM_ADDRESS"); 
*
1D2A:  MOVLW  00
1D2C:  MOVLB  6
1D2E:  SUBWF  xB3,F
1D30:  SUBWFB xB4,F
1D32:  MOVLW  F0
1D34:  SUBWFB xB5,F
1D36:  MOVLW  00
1D38:  SUBWFB xB6,F
....................   for(int8 i = 0; i < count; i++) { 
1D3A:  CLRF   xBA
1D3C:  MOVF   xB9,W
1D3E:  SUBWF  xBA,W
1D40:  BC    1DC0
....................     if(read_eeprom(address) != dataptr[i]) { 
1D42:  MOVFF  FF2,6BB
1D46:  BCF    FF2.7
1D48:  MOVFF  6B3,FA9
1D4C:  BCF    FA6.6
1D4E:  BCF    FA6.7
1D50:  BSF    FA6.0
1D52:  MOVF   FA8,W
1D54:  BTFSC  xBB.7
1D56:  BSF    FF2.7
1D58:  MOVWF  xBC
1D5A:  CLRF   03
1D5C:  MOVF   xBA,W
1D5E:  ADDWF  xB7,W
1D60:  MOVWF  FE9
1D62:  MOVF   xB8,W
1D64:  ADDWFC 03,W
1D66:  MOVWF  FEA
1D68:  MOVF   FEF,W
1D6A:  SUBWF  xBC,W
1D6C:  BZ    1DAC
....................        write_eeprom(address, dataptr[i]); 
1D6E:  CLRF   03
1D70:  MOVF   xBA,W
1D72:  ADDWF  xB7,W
1D74:  MOVWF  FE9
1D76:  MOVF   xB8,W
1D78:  ADDWFC 03,W
1D7A:  MOVWF  FEA
1D7C:  MOVFF  FEF,6BB
1D80:  MOVF   FF2,W
1D82:  MOVWF  00
1D84:  BCF    FF2.7
1D86:  MOVFF  6B3,FA9
1D8A:  MOVFF  6BB,FA8
1D8E:  BCF    FA6.6
1D90:  BCF    FA6.7
1D92:  BSF    FA6.2
1D94:  MOVLB  F
1D96:  MOVLW  55
1D98:  MOVWF  FA7
1D9A:  MOVLW  AA
1D9C:  MOVWF  FA7
1D9E:  BSF    FA6.1
1DA0:  BTFSC  FA6.1
1DA2:  BRA    1DA0
1DA4:  BCF    FA6.2
1DA6:  MOVF   00,W
1DA8:  IORWF  FF2,F
1DAA:  MOVLB  6
....................     } 
....................     address++; 
1DAC:  MOVLW  01
1DAE:  ADDWF  xB3,F
1DB0:  BTFSC  FD8.0
1DB2:  INCF   xB4,F
1DB4:  BTFSC  FD8.2
1DB6:  INCF   xB5,F
1DB8:  BTFSC  FD8.2
1DBA:  INCF   xB6,F
1DBC:  INCF   xBA,F
1DBE:  BRA    1D3C
....................   } 
1DC0:  MOVLB  0
1DC2:  RETURN 0
....................     
.................... } 
....................  
.................... void read_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count) { 
....................     
....................   address -= getenv("EEPROM_ADDRESS"); 
*
09EA:  MOVLW  00
09EC:  MOVLB  6
09EE:  SUBWF  x5A,F
09F0:  SUBWFB x5B,F
09F2:  MOVLW  F0
09F4:  SUBWFB x5C,F
09F6:  MOVLW  00
09F8:  SUBWFB x5D,F
....................   for(int8 i = 0; i < count; i++) { 
09FA:  CLRF   x61
09FC:  MOVF   x60,W
09FE:  SUBWF  x61,W
0A00:  BC    0A3C
....................     dataptr[i] = read_eeprom(address); 
0A02:  CLRF   03
0A04:  MOVF   x61,W
0A06:  ADDWF  x5E,W
0A08:  MOVWF  FE9
0A0A:  MOVF   x5F,W
0A0C:  ADDWFC 03,W
0A0E:  MOVWF  FEA
0A10:  MOVFF  FF2,664
0A14:  BCF    FF2.7
0A16:  MOVFF  65A,FA9
0A1A:  BCF    FA6.6
0A1C:  BCF    FA6.7
0A1E:  BSF    FA6.0
0A20:  MOVF   FA8,W
0A22:  BTFSC  x64.7
0A24:  BSF    FF2.7
0A26:  MOVWF  FEF
....................     address++; 
0A28:  MOVLW  01
0A2A:  ADDWF  x5A,F
0A2C:  BTFSC  FD8.0
0A2E:  INCF   x5B,F
0A30:  BTFSC  FD8.2
0A32:  INCF   x5C,F
0A34:  BTFSC  FD8.2
0A36:  INCF   x5D,F
0A38:  INCF   x61,F
0A3A:  BRA    09FC
....................   } 
0A3C:  MOVLB  0
0A3E:  RETURN 0
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define   UART_BUFFER_SIZE         150 
....................  
.................... char comando_recibido_UART[UART_BUFFER_SIZE]; 
.................... char comando_recibido_BUFF [UART_BUFFER_SIZE]; 
.................... int *posicao_valor_comando = 0; 
.................... int16 timeout_trama_UART = 100000; 
.................... extern int1 comando_disponivel_UART; 
.................... extern int32 corrente_limite; 
.................... extern int32 tempo_entre_alertas; 
.................... extern float aux_corrente; 
.................... extern float aux_tensao; 
.................... extern float zero_set; 
.................... extern float zero_set_aux; 
....................  
.................... #INT_RDA  
.................... void recepcao_UART() 
*
05DC:  MOVLW  01
05DE:  MOVLB  7
05E0:  MOVWF  x31
.................... { 
....................  int i = 1; 
....................  int8 caracterRx; 
....................    if(kbhit(SIM800L_SERIAL) && comando_disponivel_UART == 0) { 
05E2:  BTFSS  F9E.5
05E4:  BRA    068C
05E6:  MOVLB  1
05E8:  BTFSS  x82.0
05EA:  BRA    05F0
05EC:  MOVLB  7
05EE:  BRA    068C
....................       caracterRx = getc(SIM800L_SERIAL); 
05F0:  MOVLB  0
05F2:  RCALL  05C6
05F4:  MOVFF  01,732
....................       if(caracterRx == '>'||caracterRx == '+' ||caracterRx =='\n'||caracterRx =='\r') { 
05F8:  MOVLB  7
05FA:  MOVF   x32,W
05FC:  SUBLW  3E
05FE:  BZ    0612
0600:  MOVF   x32,W
0602:  SUBLW  2B
0604:  BZ    0612
0606:  MOVF   x32,W
0608:  SUBLW  0A
060A:  BZ    0612
060C:  MOVF   x32,W
060E:  SUBLW  0D
0610:  BNZ   068C
....................         comando_recibido_UART[0] = caracterRx; 
0612:  MOVFF  732,52
....................         while(i < (UART_BUFFER_SIZE-2) && timeout_trama_UART > 0) { 
0616:  MOVF   x31,W
0618:  SUBLW  93
061A:  BNC   066E
061C:  MOVLB  1
061E:  MOVF   x80,F
0620:  BNZ   062C
0622:  MOVF   x81,F
0624:  BTFSS  FD8.2
0626:  BRA    062C
0628:  MOVLB  7
062A:  BRA    066E
....................            if(kbhit(SIM800L_SERIAL)) { 
062C:  BTFSS  F9E.5
062E:  BRA    0662
....................              caracterRx = getc(SIM800L_SERIAL); 
0630:  MOVLB  0
0632:  RCALL  05C6
0634:  MOVFF  01,732
....................              comando_recibido_UART[i] = caracterRx; 
0638:  CLRF   03
063A:  MOVLB  7
063C:  MOVF   x31,W
063E:  ADDLW  52
0640:  MOVWF  FE9
0642:  MOVLW  00
0644:  ADDWFC 03,W
0646:  MOVWF  FEA
0648:  MOVFF  732,FEF
....................              if(caracterRx == ';') {  
064C:  MOVF   x32,W
064E:  SUBLW  3B
0650:  BNZ   0656
....................                i++; 
0652:  INCF   x31,F
....................                break; 
0654:  BRA    066E
....................              } 
....................              i++; 
0656:  INCF   x31,F
....................              timeout_trama_UART = 100000; 
0658:  MOVLW  86
065A:  MOVLB  1
065C:  MOVWF  x81
065E:  MOVLW  A0
0660:  MOVWF  x80
....................            } 
....................            timeout_trama_UART--; 
0662:  MOVF   x80,W
0664:  BTFSC  FD8.2
0666:  DECF   x81,F
0668:  DECF   x80,F
066A:  MOVLB  7
066C:  BRA    0616
....................         } 
....................         comando_disponivel_UART = 1; 
066E:  MOVLB  1
0670:  BSF    x82.0
....................         timeout_trama_UART = 100000; 
0672:  MOVLW  86
0674:  MOVWF  x81
0676:  MOVLW  A0
0678:  MOVWF  x80
....................         comando_recibido_UART[i] = 0; 
067A:  CLRF   03
067C:  MOVLB  7
067E:  MOVF   x31,W
0680:  ADDLW  52
0682:  MOVWF  FE9
0684:  MOVLW  00
0686:  ADDWFC 03,W
0688:  MOVWF  FEA
068A:  CLRF   FEF
....................       } 
....................    } 
....................   return; 
068C:  BCF    F9E.5
068E:  MOVLB  0
0690:  GOTO   006C
.................... } 
....................  
.................... char Get_Comando() 
.................... { 
....................   char CMD[15]; 
....................   strcpy (comando_recibido_BUFF, comando_recibido_UART);                            
*
1A9A:  CLRF   FEA
1A9C:  MOVLW  E8
1A9E:  MOVWF  FE9
1AA0:  CLRF   FE2
1AA2:  MOVLW  52
1AA4:  MOVWF  FE1
1AA6:  MOVF   FE7,F
1AA8:  MOVFF  FE6,FEE
1AAC:  BNZ   1AA6
....................   strcpy (CMD, "+CMTI"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_COMMAND); 
1AAE:  MOVLW  06
1AB0:  MOVWF  FEA
1AB2:  MOVLW  6B
1AB4:  MOVWF  FE9
1AB6:  MOVFF  FF2,67A
1ABA:  BCF    FF2.7
1ABC:  MOVLW  00
1ABE:  CALL   00AE
1AC2:  TBLRD*-
1AC4:  TBLRD*+
1AC6:  MOVF   FF5,W
1AC8:  MOVWF  FEE
1ACA:  IORLW  00
1ACC:  BNZ   1AC4
1ACE:  MOVLB  6
1AD0:  BTFSC  x7A.7
1AD2:  BSF    FF2.7
1AD4:  MOVLB  7
1AD6:  CLRF   x29
1AD8:  MOVLW  E8
1ADA:  MOVWF  x28
1ADC:  MOVLW  06
1ADE:  MOVWF  x2B
1AE0:  MOVLW  6B
1AE2:  MOVWF  x2A
1AE4:  MOVLB  0
1AE6:  CALL   0BB4
1AEA:  MOVFF  02,17F
1AEE:  MOVFF  01,17E
1AF2:  MOVLB  1
1AF4:  MOVF   x7E,F
1AF6:  BNZ   1AFC
1AF8:  MOVF   x7F,F
1AFA:  BZ    1B02
1AFC:  MOVLW  01
1AFE:  MOVWF  01
1B00:  BRA    1B5C
....................   strcpy (CMD, "+CMGL"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_READ_COMMAND); 
1B02:  MOVLW  06
1B04:  MOVWF  FEA
1B06:  MOVLW  6B
1B08:  MOVWF  FE9
1B0A:  MOVFF  FF2,67A
1B0E:  BCF    FF2.7
1B10:  MOVLW  00
1B12:  MOVLB  0
1B14:  CALL   00CE
1B18:  TBLRD*-
1B1A:  TBLRD*+
1B1C:  MOVF   FF5,W
1B1E:  MOVWF  FEE
1B20:  IORLW  00
1B22:  BNZ   1B1A
1B24:  MOVLB  6
1B26:  BTFSC  x7A.7
1B28:  BSF    FF2.7
1B2A:  MOVLB  7
1B2C:  CLRF   x29
1B2E:  MOVLW  E8
1B30:  MOVWF  x28
1B32:  MOVLW  06
1B34:  MOVWF  x2B
1B36:  MOVLW  6B
1B38:  MOVWF  x2A
1B3A:  MOVLB  0
1B3C:  CALL   0BB4
1B40:  MOVFF  02,17F
1B44:  MOVFF  01,17E
1B48:  MOVLB  1
1B4A:  MOVF   x7E,F
1B4C:  BNZ   1B52
1B4E:  MOVF   x7F,F
1B50:  BZ    1B58
1B52:  MOVLW  02
1B54:  MOVWF  01
1B56:  BRA    1B5C
....................  
....................   return(0); 
1B58:  MOVLW  00
1B5A:  MOVWF  01
1B5C:  MOVLB  0
1B5E:  RETURN 0
.................... } 
....................  
....................  
.................... void Executa_Comando(char comando){ 
....................  
....................   char CMD[15]; 
....................   char numero[20]; 
....................  
....................   disable_interrupts(GLOBAL); 
*
25E8:  BCF    FF2.6
25EA:  BCF    FF2.7
25EC:  BTFSC  FF2.7
25EE:  BRA    25EA
....................    
....................   switch(comando){ 
25F0:  MOVLB  6
25F2:  MOVF   x6B,W
25F4:  XORLW  01
25F6:  MOVLB  0
25F8:  BZ    2602
25FA:  XORLW  03
25FC:  BZ    260A
25FE:  GOTO   2DBA
....................       
....................     case SMS_COMMAND:       //+CMTI: "SM",10<CR><LF> 
....................       Read_SMS(); 
2602:  GOTO   1B60
....................     break; 
2606:  GOTO   2DBA
....................  
....................     case SMS_READ_COMMAND:  //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/13,21:57:54-12"<CR><LF> 
....................  
....................       strcpy (CMD, "OITAI");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); 
260A:  MOVLW  06
260C:  MOVWF  FEA
260E:  MOVLW  6C
2610:  MOVWF  FE9
2612:  MOVFF  FF2,6B3
2616:  BCF    FF2.7
2618:  MOVLW  00
261A:  CALL   00EE
261E:  TBLRD*-
2620:  TBLRD*+
2622:  MOVF   FF5,W
2624:  MOVWF  FEE
2626:  IORLW  00
2628:  BNZ   2620
262A:  MOVLB  6
262C:  BTFSC  xB3.7
262E:  BSF    FF2.7
2630:  MOVLB  7
2632:  CLRF   x29
2634:  MOVLW  E8
2636:  MOVWF  x28
2638:  MOVLW  06
263A:  MOVWF  x2B
263C:  MOVLW  6C
263E:  MOVWF  x2A
2640:  MOVLB  0
2642:  CALL   0BB4
2646:  MOVFF  02,17F
264A:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
264E:  MOVLB  1
2650:  MOVF   x7E,F
2652:  BNZ   2658
2654:  MOVF   x7F,F
2656:  BZ    26B6
....................  
....................         get_numero(14,25,numero); 
2658:  MOVLW  0E
265A:  MOVLB  6
265C:  MOVWF  xB3
265E:  MOVLW  19
2660:  MOVWF  xB4
2662:  MOVLW  06
2664:  MOVWF  xB6
2666:  MOVLW  7B
2668:  MOVWF  xB5
266A:  MOVLB  0
266C:  CALL   1C14
....................         Send_SMS(numero,"HEARTBEAT()"); 
2670:  MOVLW  06
2672:  MOVWF  FEA
2674:  MOVLW  8F
2676:  MOVWF  FE9
2678:  MOVFF  FF2,6B3
267C:  BCF    FF2.7
267E:  MOVLW  0C
2680:  MOVWF  01
2682:  CLRF   FF7
2684:  MOVLW  00
2686:  CALL   010E
268A:  TBLRD*-
268C:  TBLRD*+
268E:  MOVFF  FF5,FEE
2692:  DECFSZ 01,F
2694:  BRA    268C
2696:  MOVLB  6
2698:  BTFSC  xB3.7
269A:  BSF    FF2.7
269C:  MOVLW  06
269E:  MOVWF  xD9
26A0:  MOVLW  7B
26A2:  MOVWF  xD8
26A4:  MOVLW  06
26A6:  MOVWF  xDB
26A8:  MOVLW  8F
26AA:  MOVWF  xDA
26AC:  MOVLB  0
26AE:  CALL   0D3C
....................         break; 
26B2:  BRA    2DBA
26B4:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMADD");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/14,00:28:46-12"nr+NUMADD+5531995422738<CR><LF> 
26B6:  MOVLW  06
26B8:  MOVWF  FEA
26BA:  MOVLW  6C
26BC:  MOVWF  FE9
26BE:  MOVFF  FF2,6B3
26C2:  BCF    FF2.7
26C4:  MOVLW  00
26C6:  MOVLB  0
26C8:  CALL   0134
26CC:  TBLRD*-
26CE:  TBLRD*+
26D0:  MOVF   FF5,W
26D2:  MOVWF  FEE
26D4:  IORLW  00
26D6:  BNZ   26CE
26D8:  MOVLB  6
26DA:  BTFSC  xB3.7
26DC:  BSF    FF2.7
26DE:  MOVLB  7
26E0:  CLRF   x29
26E2:  MOVLW  E8
26E4:  MOVWF  x28
26E6:  MOVLW  06
26E8:  MOVWF  x2B
26EA:  MOVLW  6C
26EC:  MOVWF  x2A
26EE:  MOVLB  0
26F0:  CALL   0BB4
26F4:  MOVFF  02,17F
26F8:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
26FC:  MOVLB  1
26FE:  MOVF   x7E,F
2700:  BNZ   2706
2702:  MOVF   x7F,F
2704:  BZ    279C
....................          
....................         get_numero(14,75,numero); 
2706:  MOVLW  0E
2708:  MOVLB  6
270A:  MOVWF  xB3
270C:  MOVLW  4B
270E:  MOVWF  xB4
2710:  MOVLW  06
2712:  MOVWF  xB6
2714:  MOVLW  7B
2716:  MOVWF  xB5
2718:  MOVLB  0
271A:  CALL   1C14
....................         insere_numero(numero); 
271E:  MOVLW  06
2720:  MOVLB  6
2722:  MOVWF  xB4
2724:  MOVLW  7B
2726:  MOVWF  xB3
2728:  MOVLB  0
272A:  GOTO   1C68
....................         write_config(ADDR_qtd_numeros,&qtd_numeros,1); 
272E:  MOVLB  6
2730:  CLRF   xB6
2732:  MOVLW  F0
2734:  MOVWF  xB5
2736:  CLRF   xB4
2738:  MOVLW  10
273A:  MOVWF  xB3
273C:  CLRF   xB8
273E:  MOVLW  4F
2740:  MOVWF  xB7
2742:  MOVLW  01
2744:  MOVWF  xB9
2746:  MOVLB  0
2748:  CALL   1D2A
....................         write_config(ADDR_vector_numeros,&numeros,50); 
274C:  MOVLB  6
274E:  CLRF   xB6
2750:  MOVLW  F0
2752:  MOVWF  xB5
2754:  CLRF   xB4
2756:  MOVLW  11
2758:  MOVWF  xB3
275A:  CLRF   xB8
275C:  MOVLW  1D
275E:  MOVWF  xB7
2760:  MOVLW  32
2762:  MOVWF  xB9
2764:  MOVLB  0
2766:  CALL   1D2A
....................         get_numero(14,25,numero); 
276A:  MOVLW  0E
276C:  MOVLB  6
276E:  MOVWF  xB3
2770:  MOVLW  19
2772:  MOVWF  xB4
2774:  MOVLW  06
2776:  MOVWF  xB6
2778:  MOVLW  7B
277A:  MOVWF  xB5
277C:  MOVLB  0
277E:  CALL   1C14
....................         Send_SMS(numero,numeros); 
2782:  MOVLW  06
2784:  MOVLB  6
2786:  MOVWF  xD9
2788:  MOVLW  7B
278A:  MOVWF  xD8
278C:  CLRF   xDB
278E:  MOVLW  1D
2790:  MOVWF  xDA
2792:  MOVLB  0
2794:  CALL   0D3C
....................         break; 
2798:  BRA    2DBA
279A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMDEL");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+NUMDEL 
279C:  MOVLW  06
279E:  MOVWF  FEA
27A0:  MOVLW  6C
27A2:  MOVWF  FE9
27A4:  MOVFF  FF2,6B3
27A8:  BCF    FF2.7
27AA:  MOVLW  00
27AC:  MOVLB  0
27AE:  CALL   0156
27B2:  TBLRD*-
27B4:  TBLRD*+
27B6:  MOVF   FF5,W
27B8:  MOVWF  FEE
27BA:  IORLW  00
27BC:  BNZ   27B4
27BE:  MOVLB  6
27C0:  BTFSC  xB3.7
27C2:  BSF    FF2.7
27C4:  MOVLB  7
27C6:  CLRF   x29
27C8:  MOVLW  E8
27CA:  MOVWF  x28
27CC:  MOVLW  06
27CE:  MOVWF  x2B
27D0:  MOVLW  6C
27D2:  MOVWF  x2A
27D4:  MOVLB  0
27D6:  CALL   0BB4
27DA:  MOVFF  02,17F
27DE:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
27E2:  MOVLB  1
27E4:  MOVF   x7E,F
27E6:  BNZ   27EC
27E8:  MOVF   x7F,F
27EA:  BZ    288C
....................           
....................         limpa_numeros();  
27EC:  MOVLB  0
27EE:  GOTO   1DDE
....................         write_config(ADDR_qtd_numeros,&qtd_numeros,1); 
27F2:  MOVLB  6
27F4:  CLRF   xB6
27F6:  MOVLW  F0
27F8:  MOVWF  xB5
27FA:  CLRF   xB4
27FC:  MOVLW  10
27FE:  MOVWF  xB3
2800:  CLRF   xB8
2802:  MOVLW  4F
2804:  MOVWF  xB7
2806:  MOVLW  01
2808:  MOVWF  xB9
280A:  MOVLB  0
280C:  CALL   1D2A
....................         write_config(ADDR_vector_numeros,&numeros,50); 
2810:  MOVLB  6
2812:  CLRF   xB6
2814:  MOVLW  F0
2816:  MOVWF  xB5
2818:  CLRF   xB4
281A:  MOVLW  11
281C:  MOVWF  xB3
281E:  CLRF   xB8
2820:  MOVLW  1D
2822:  MOVWF  xB7
2824:  MOVLW  32
2826:  MOVWF  xB9
2828:  MOVLB  0
282A:  CALL   1D2A
....................         get_numero(14,25,numero); 
282E:  MOVLW  0E
2830:  MOVLB  6
2832:  MOVWF  xB3
2834:  MOVLW  19
2836:  MOVWF  xB4
2838:  MOVLW  06
283A:  MOVWF  xB6
283C:  MOVLW  7B
283E:  MOVWF  xB5
2840:  MOVLB  0
2842:  CALL   1C14
....................         Send_SMS(numero,"OK CLEAR ALL"); 
2846:  MOVLW  06
2848:  MOVWF  FEA
284A:  MOVLW  9B
284C:  MOVWF  FE9
284E:  MOVFF  FF2,6B3
2852:  BCF    FF2.7
2854:  MOVLW  0D
2856:  MOVWF  01
2858:  CLRF   FF7
285A:  MOVLW  00
285C:  CALL   0178
2860:  TBLRD*-
2862:  TBLRD*+
2864:  MOVFF  FF5,FEE
2868:  DECFSZ 01,F
286A:  BRA    2862
286C:  MOVLB  6
286E:  BTFSC  xB3.7
2870:  BSF    FF2.7
2872:  MOVLW  06
2874:  MOVWF  xD9
2876:  MOVLW  7B
2878:  MOVWF  xD8
287A:  MOVLW  06
287C:  MOVWF  xDB
287E:  MOVLW  9B
2880:  MOVWF  xDA
2882:  MOVLB  0
2884:  CALL   0D3C
....................         break; 
2888:  BRA    2DBA
288A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+GSMLOCATE");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+GSMLOCATE 
288C:  MOVLW  06
288E:  MOVWF  FEA
2890:  MOVLW  6C
2892:  MOVWF  FE9
2894:  MOVFF  FF2,6B3
2898:  BCF    FF2.7
289A:  MOVLW  00
289C:  MOVLB  0
289E:  CALL   01A0
28A2:  TBLRD*-
28A4:  TBLRD*+
28A6:  MOVF   FF5,W
28A8:  MOVWF  FEE
28AA:  IORLW  00
28AC:  BNZ   28A4
28AE:  MOVLB  6
28B0:  BTFSC  xB3.7
28B2:  BSF    FF2.7
28B4:  MOVLB  7
28B6:  CLRF   x29
28B8:  MOVLW  E8
28BA:  MOVWF  x28
28BC:  MOVLW  06
28BE:  MOVWF  x2B
28C0:  MOVLW  6C
28C2:  MOVWF  x2A
28C4:  MOVLB  0
28C6:  CALL   0BB4
28CA:  MOVFF  02,17F
28CE:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
28D2:  MOVLB  1
28D4:  MOVF   x7E,F
28D6:  BNZ   28DC
28D8:  MOVF   x7F,F
28DA:  BZ    2908
....................           
....................         get_numero(14,25,numero);  
28DC:  MOVLW  0E
28DE:  MOVLB  6
28E0:  MOVWF  xB3
28E2:  MOVLW  19
28E4:  MOVWF  xB4
28E6:  MOVLW  06
28E8:  MOVWF  xB6
28EA:  MOVLW  7B
28EC:  MOVWF  xB5
28EE:  MOVLB  0
28F0:  CALL   1C14
....................         Get_Locate(numero);  
28F4:  MOVLW  06
28F6:  MOVLB  6
28F8:  MOVWF  xB4
28FA:  MOVLW  7B
28FC:  MOVWF  xB3
28FE:  MOVLB  0
2900:  GOTO   1F56
....................         break; 
2904:  BRA    2DBA
2906:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CURLIM");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //rn+CMGL: 1,"REC UNREAD","+5531995822739","","18/11/10,18:12:21-08"rn+CURLIM000001rn 
2908:  MOVLW  06
290A:  MOVWF  FEA
290C:  MOVLW  6C
290E:  MOVWF  FE9
2910:  MOVFF  FF2,6B3
2914:  BCF    FF2.7
2916:  MOVLW  00
2918:  MOVLB  0
291A:  CALL   01C6
291E:  TBLRD*-
2920:  TBLRD*+
2922:  MOVF   FF5,W
2924:  MOVWF  FEE
2926:  IORLW  00
2928:  BNZ   2920
292A:  MOVLB  6
292C:  BTFSC  xB3.7
292E:  BSF    FF2.7
2930:  MOVLB  7
2932:  CLRF   x29
2934:  MOVLW  E8
2936:  MOVWF  x28
2938:  MOVLW  06
293A:  MOVWF  x2B
293C:  MOVLW  6C
293E:  MOVWF  x2A
2940:  MOVLB  0
2942:  CALL   0BB4
2946:  MOVFF  02,17F
294A:  MOVFF  01,17E
....................  
....................       if(posicao_valor_comando!= 0){ 
294E:  MOVLB  1
2950:  MOVF   x7E,F
2952:  BNZ   2958
2954:  MOVF   x7F,F
2956:  BZ    2A28
....................           
....................         get_numero(14,25,numero); 
2958:  MOVLW  0E
295A:  MOVLB  6
295C:  MOVWF  xB3
295E:  MOVLW  19
2960:  MOVWF  xB4
2962:  MOVLW  06
2964:  MOVWF  xB6
2966:  MOVLW  7B
2968:  MOVWF  xB5
296A:  MOVLB  0
296C:  CALL   1C14
....................         corrente_limite = get_value(posicao_valor_comando,6,7); //+CURALM001<CR><LF> 
2970:  MOVFF  17F,6B4
2974:  MOVFF  17E,6B3
2978:  MOVLW  06
297A:  MOVLB  6
297C:  MOVWF  xB5
297E:  MOVLW  07
2980:  MOVWF  xB6
2982:  MOVLB  0
2984:  RCALL  2382
2986:  MOVFF  03,186
298A:  MOVFF  02,185
298E:  MOVFF  01,184
2992:  MOVFF  00,183
....................         write_config(ADDR_corrente_limite,&corrente_limite,4); 
2996:  MOVLB  6
2998:  CLRF   xB6
299A:  MOVLW  F0
299C:  MOVWF  xB5
299E:  CLRF   xB4
29A0:  MOVLW  08
29A2:  MOVWF  xB3
29A4:  MOVLW  01
29A6:  MOVWF  xB8
29A8:  MOVLW  83
29AA:  MOVWF  xB7
29AC:  MOVLW  04
29AE:  MOVWF  xB9
29B0:  MOVLB  0
29B2:  CALL   1D2A
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
29B6:  CLRF   FEA
29B8:  MOVLW  E8
29BA:  MOVWF  FE9
29BC:  CLRF   00
29BE:  CLRF   02
29C0:  MOVLW  96
29C2:  MOVWF  01
29C4:  CALL   1DC4
....................         sprintf(comando_recibido_BUFF, "Corrente Limite = %Lu mA",corrente_limite); 
29C8:  MOVLB  1
29CA:  CLRF   x9C
29CC:  MOVLW  E8
29CE:  MOVWF  x9B
29D0:  MOVLW  94
29D2:  MOVWF  FF6
29D4:  MOVLW  06
29D6:  MOVWF  FF7
29D8:  MOVLW  12
29DA:  MOVLB  7
29DC:  MOVWF  x17
29DE:  MOVLB  0
29E0:  CALL   0B3E
29E4:  MOVLW  41
29E6:  MOVWF  FE9
29E8:  MOVFF  186,6B6
29EC:  MOVFF  185,6B5
29F0:  MOVFF  184,6B4
29F4:  MOVFF  183,6B3
29F8:  RCALL  2474
29FA:  MOVLW  A9
29FC:  MOVWF  FF6
29FE:  MOVLW  06
2A00:  MOVWF  FF7
2A02:  MOVLW  03
2A04:  MOVLB  7
2A06:  MOVWF  x17
2A08:  MOVLB  0
2A0A:  CALL   0B3E
....................         Send_SMS(numero,comando_recibido_BUFF); 
2A0E:  MOVLW  06
2A10:  MOVLB  6
2A12:  MOVWF  xD9
2A14:  MOVLW  7B
2A16:  MOVWF  xD8
2A18:  CLRF   xDB
2A1A:  MOVLW  E8
2A1C:  MOVWF  xDA
2A1E:  MOVLB  0
2A20:  CALL   0D3C
....................         break; 
2A24:  BRA    2DBA
2A26:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CURALM");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //rn+CMGL: 1,"REC UNREAD","+5531995822739","","18/11/10,18:09:52-08"rn+CURALM001rn 
2A28:  MOVLW  06
2A2A:  MOVWF  FEA
2A2C:  MOVLW  6C
2A2E:  MOVWF  FE9
2A30:  MOVFF  FF2,6B3
2A34:  BCF    FF2.7
2A36:  MOVLW  00
2A38:  MOVLB  0
2A3A:  CALL   01E8
2A3E:  TBLRD*-
2A40:  TBLRD*+
2A42:  MOVF   FF5,W
2A44:  MOVWF  FEE
2A46:  IORLW  00
2A48:  BNZ   2A40
2A4A:  MOVLB  6
2A4C:  BTFSC  xB3.7
2A4E:  BSF    FF2.7
2A50:  MOVLB  7
2A52:  CLRF   x29
2A54:  MOVLW  E8
2A56:  MOVWF  x28
2A58:  MOVLW  06
2A5A:  MOVWF  x2B
2A5C:  MOVLW  6C
2A5E:  MOVWF  x2A
2A60:  MOVLB  0
2A62:  CALL   0BB4
2A66:  MOVFF  02,17F
2A6A:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2A6E:  MOVLB  1
2A70:  MOVF   x7E,F
2A72:  BNZ   2A78
2A74:  MOVF   x7F,F
2A76:  BZ    2B46
....................           
....................         get_numero(14,25,numero); 
2A78:  MOVLW  0E
2A7A:  MOVLB  6
2A7C:  MOVWF  xB3
2A7E:  MOVLW  19
2A80:  MOVWF  xB4
2A82:  MOVLW  06
2A84:  MOVWF  xB6
2A86:  MOVLW  7B
2A88:  MOVWF  xB5
2A8A:  MOVLB  0
2A8C:  CALL   1C14
....................         tempo_entre_alertas = get_value(posicao_valor_comando,3,7); //+CURLIM000001<CR><LF> 
2A90:  MOVFF  17F,6B4
2A94:  MOVFF  17E,6B3
2A98:  MOVLW  03
2A9A:  MOVLB  6
2A9C:  MOVWF  xB5
2A9E:  MOVLW  07
2AA0:  MOVWF  xB6
2AA2:  MOVLB  0
2AA4:  RCALL  2382
2AA6:  MOVFF  03,18A
2AAA:  MOVFF  02,189
2AAE:  MOVFF  01,188
2AB2:  MOVFF  00,187
....................         write_config(ADDR_tempo_entre_alertas,&tempo_entre_alertas,4); 
2AB6:  MOVLB  6
2AB8:  CLRF   xB6
2ABA:  MOVLW  F0
2ABC:  MOVWF  xB5
2ABE:  CLRF   xB4
2AC0:  CLRF   xB3
2AC2:  MOVLW  01
2AC4:  MOVWF  xB8
2AC6:  MOVLW  87
2AC8:  MOVWF  xB7
2ACA:  MOVLW  04
2ACC:  MOVWF  xB9
2ACE:  MOVLB  0
2AD0:  CALL   1D2A
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2AD4:  CLRF   FEA
2AD6:  MOVLW  E8
2AD8:  MOVWF  FE9
2ADA:  CLRF   00
2ADC:  CLRF   02
2ADE:  MOVLW  96
2AE0:  MOVWF  01
2AE2:  CALL   1DC4
....................         sprintf(comando_recibido_BUFF, "Tempo Entre Alertas = %Lu min",tempo_entre_alertas); 
2AE6:  MOVLB  1
2AE8:  CLRF   x9C
2AEA:  MOVLW  E8
2AEC:  MOVWF  x9B
2AEE:  MOVLW  AE
2AF0:  MOVWF  FF6
2AF2:  MOVLW  06
2AF4:  MOVWF  FF7
2AF6:  MOVLW  16
2AF8:  MOVLB  7
2AFA:  MOVWF  x17
2AFC:  MOVLB  0
2AFE:  CALL   0B3E
2B02:  MOVLW  41
2B04:  MOVWF  FE9
2B06:  MOVFF  18A,6B6
2B0A:  MOVFF  189,6B5
2B0E:  MOVFF  188,6B4
2B12:  MOVFF  187,6B3
2B16:  RCALL  2474
2B18:  MOVLW  C7
2B1A:  MOVWF  FF6
2B1C:  MOVLW  06
2B1E:  MOVWF  FF7
2B20:  MOVLW  04
2B22:  MOVLB  7
2B24:  MOVWF  x17
2B26:  MOVLB  0
2B28:  CALL   0B3E
....................         Send_SMS(numero,comando_recibido_BUFF); 
2B2C:  MOVLW  06
2B2E:  MOVLB  6
2B30:  MOVWF  xD9
2B32:  MOVLW  7B
2B34:  MOVWF  xD8
2B36:  CLRF   xDB
2B38:  MOVLW  E8
2B3A:  MOVWF  xDA
2B3C:  MOVLB  0
2B3E:  CALL   0D3C
....................         break; 
2B42:  BRA    2DBA
2B44:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CSTATS");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CSTATS 
2B46:  MOVLW  06
2B48:  MOVWF  FEA
2B4A:  MOVLW  6C
2B4C:  MOVWF  FE9
2B4E:  MOVFF  FF2,6B3
2B52:  BCF    FF2.7
2B54:  MOVLW  00
2B56:  MOVLB  0
2B58:  CALL   020A
2B5C:  TBLRD*-
2B5E:  TBLRD*+
2B60:  MOVF   FF5,W
2B62:  MOVWF  FEE
2B64:  IORLW  00
2B66:  BNZ   2B5E
2B68:  MOVLB  6
2B6A:  BTFSC  xB3.7
2B6C:  BSF    FF2.7
2B6E:  MOVLB  7
2B70:  CLRF   x29
2B72:  MOVLW  E8
2B74:  MOVWF  x28
2B76:  MOVLW  06
2B78:  MOVWF  x2B
2B7A:  MOVLW  6C
2B7C:  MOVWF  x2A
2B7E:  MOVLB  0
2B80:  CALL   0BB4
2B84:  MOVFF  02,17F
2B88:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2B8C:  MOVLB  1
2B8E:  MOVF   x7E,F
2B90:  BNZ   2B98
2B92:  MOVF   x7F,F
2B94:  BTFSC  FD8.2
2B96:  BRA    2CDA
....................           
....................         get_numero(14,25,numero); 
2B98:  MOVLW  0E
2B9A:  MOVLB  6
2B9C:  MOVWF  xB3
2B9E:  MOVLW  19
2BA0:  MOVWF  xB4
2BA2:  MOVLW  06
2BA4:  MOVWF  xB6
2BA6:  MOVLW  7B
2BA8:  MOVWF  xB5
2BAA:  MOVLB  0
2BAC:  CALL   1C14
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2BB0:  CLRF   FEA
2BB2:  MOVLW  E8
2BB4:  MOVWF  FE9
2BB6:  CLRF   00
2BB8:  CLRF   02
2BBA:  MOVLW  96
2BBC:  MOVWF  01
2BBE:  CALL   1DC4
....................         sprintf(comando_recibido_BUFF, "Tempo Entre Alertas = %Lu min / Corrente Limite = %Lu mA / Corrente Atual: %6.0f mA / Tensao Atual: %2.2f V / Qtd Telefones: %u",tempo_entre_alertas,corrente_limite,aux_corrente,aux_tensao,qtd_numeros); 
2BC2:  MOVLB  1
2BC4:  CLRF   x9C
2BC6:  MOVLW  E8
2BC8:  MOVWF  x9B
2BCA:  MOVLW  CC
2BCC:  MOVWF  FF6
2BCE:  MOVLW  06
2BD0:  MOVWF  FF7
2BD2:  MOVLW  16
2BD4:  MOVLB  7
2BD6:  MOVWF  x17
2BD8:  MOVLB  0
2BDA:  CALL   0B3E
2BDE:  MOVLW  41
2BE0:  MOVWF  FE9
2BE2:  MOVFF  18A,6B6
2BE6:  MOVFF  189,6B5
2BEA:  MOVFF  188,6B4
2BEE:  MOVFF  187,6B3
2BF2:  RCALL  2474
2BF4:  MOVLW  E5
2BF6:  MOVWF  FF6
2BF8:  MOVLW  06
2BFA:  MOVWF  FF7
2BFC:  MOVLW  19
2BFE:  MOVLB  7
2C00:  MOVWF  x17
2C02:  MOVLB  0
2C04:  CALL   0B3E
2C08:  MOVLW  41
2C0A:  MOVWF  FE9
2C0C:  MOVFF  186,6B6
2C10:  MOVFF  185,6B5
2C14:  MOVFF  184,6B4
2C18:  MOVFF  183,6B3
2C1C:  RCALL  2474
2C1E:  MOVLW  01
2C20:  MOVWF  FF6
2C22:  MOVLW  07
2C24:  MOVWF  FF7
2C26:  MOVLW  16
2C28:  MOVLB  7
2C2A:  MOVWF  x17
2C2C:  MOVLB  0
2C2E:  CALL   0B3E
2C32:  MOVLW  05
2C34:  MOVWF  FE9
2C36:  MOVFF  18E,6B6
2C3A:  MOVFF  18D,6B5
2C3E:  MOVFF  18C,6B4
2C42:  MOVFF  18B,6B3
2C46:  MOVLB  6
2C48:  CLRF   xB7
2C4A:  MOVLB  0
2C4C:  CALL   149A
2C50:  MOVLW  1C
2C52:  MOVWF  FF6
2C54:  MOVLW  07
2C56:  MOVWF  FF7
2C58:  MOVLW  14
2C5A:  MOVLB  7
2C5C:  MOVWF  x17
2C5E:  MOVLB  0
2C60:  CALL   0B3E
2C64:  MOVLW  89
2C66:  MOVWF  FE9
2C68:  MOVFF  192,6B6
2C6C:  MOVFF  191,6B5
2C70:  MOVFF  190,6B4
2C74:  MOVFF  18F,6B3
2C78:  MOVLW  02
2C7A:  MOVLB  6
2C7C:  MOVWF  xB7
2C7E:  MOVLB  0
2C80:  CALL   149A
2C84:  MOVLW  35
2C86:  MOVWF  FF6
2C88:  MOVLW  07
2C8A:  MOVWF  FF7
2C8C:  MOVLW  14
2C8E:  MOVLB  7
2C90:  MOVWF  x17
2C92:  MOVLB  0
2C94:  CALL   0B3E
2C98:  MOVFF  4F,6B3
2C9C:  MOVLW  1B
2C9E:  MOVLB  6
2CA0:  MOVWF  xB4
2CA2:  MOVLB  0
2CA4:  BRA    2564
....................         Send_SMS(numero,comando_recibido_BUFF); 
2CA6:  MOVLW  06
2CA8:  MOVLB  6
2CAA:  MOVWF  xD9
2CAC:  MOVLW  7B
2CAE:  MOVWF  xD8
2CB0:  CLRF   xDB
2CB2:  MOVLW  E8
2CB4:  MOVWF  xDA
2CB6:  MOVLB  0
2CB8:  CALL   0D3C
....................         if(qtd_numeros>0) Send_SMS(numero,numeros);      
2CBC:  MOVF   4F,F
2CBE:  BZ    2CD6
2CC0:  MOVLW  06
2CC2:  MOVLB  6
2CC4:  MOVWF  xD9
2CC6:  MOVLW  7B
2CC8:  MOVWF  xD8
2CCA:  CLRF   xDB
2CCC:  MOVLW  1D
2CCE:  MOVWF  xDA
2CD0:  MOVLB  0
2CD2:  CALL   0D3C
....................             
....................         break; 
2CD6:  BRA    2DBA
2CD8:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+SETZERO");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+SETZERO 
2CDA:  MOVLW  06
2CDC:  MOVWF  FEA
2CDE:  MOVLW  6C
2CE0:  MOVWF  FE9
2CE2:  MOVFF  FF2,6B3
2CE6:  BCF    FF2.7
2CE8:  MOVLW  00
2CEA:  MOVLB  0
2CEC:  CALL   022C
2CF0:  TBLRD*-
2CF2:  TBLRD*+
2CF4:  MOVF   FF5,W
2CF6:  MOVWF  FEE
2CF8:  IORLW  00
2CFA:  BNZ   2CF2
2CFC:  MOVLB  6
2CFE:  BTFSC  xB3.7
2D00:  BSF    FF2.7
2D02:  MOVLB  7
2D04:  CLRF   x29
2D06:  MOVLW  E8
2D08:  MOVWF  x28
2D0A:  MOVLW  06
2D0C:  MOVWF  x2B
2D0E:  MOVLW  6C
2D10:  MOVWF  x2A
2D12:  MOVLB  0
2D14:  CALL   0BB4
2D18:  MOVFF  02,17F
2D1C:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2D20:  MOVLB  1
2D22:  MOVF   x7E,F
2D24:  BNZ   2D2A
2D26:  MOVF   x7F,F
2D28:  BZ    2DB8
....................           
....................         get_numero(14,25,numero); 
2D2A:  MOVLW  0E
2D2C:  MOVLB  6
2D2E:  MOVWF  xB3
2D30:  MOVLW  19
2D32:  MOVWF  xB4
2D34:  MOVLW  06
2D36:  MOVWF  xB6
2D38:  MOVLW  7B
2D3A:  MOVWF  xB5
2D3C:  MOVLB  0
2D3E:  CALL   1C14
....................         zero_set = zero_set_aux;  
2D42:  MOVFF  19A,196
2D46:  MOVFF  199,195
2D4A:  MOVFF  198,194
2D4E:  MOVFF  197,193
....................         write_config(ADDR_zero_set,&zero_set,4); 
2D52:  MOVLB  6
2D54:  CLRF   xB6
2D56:  MOVLW  F0
2D58:  MOVWF  xB5
2D5A:  CLRF   xB4
2D5C:  MOVLW  0C
2D5E:  MOVWF  xB3
2D60:  MOVLW  01
2D62:  MOVWF  xB8
2D64:  MOVLW  93
2D66:  MOVWF  xB7
2D68:  MOVLW  04
2D6A:  MOVWF  xB9
2D6C:  MOVLB  0
2D6E:  CALL   1D2A
....................         Send_SMS(numero,"ZERO SETED"); 
2D72:  MOVLW  06
2D74:  MOVWF  FEA
2D76:  MOVLW  A8
2D78:  MOVWF  FE9
2D7A:  MOVFF  FF2,6B3
2D7E:  BCF    FF2.7
2D80:  MOVLW  0B
2D82:  MOVWF  01
2D84:  CLRF   FF7
2D86:  MOVLW  00
2D88:  CALL   0250
2D8C:  TBLRD*-
2D8E:  TBLRD*+
2D90:  MOVFF  FF5,FEE
2D94:  DECFSZ 01,F
2D96:  BRA    2D8E
2D98:  MOVLB  6
2D9A:  BTFSC  xB3.7
2D9C:  BSF    FF2.7
2D9E:  MOVLW  06
2DA0:  MOVWF  xD9
2DA2:  MOVLW  7B
2DA4:  MOVWF  xD8
2DA6:  MOVLW  06
2DA8:  MOVWF  xDB
2DAA:  MOVLW  A8
2DAC:  MOVWF  xDA
2DAE:  MOVLB  0
2DB0:  CALL   0D3C
....................  
....................         break; 
2DB4:  BRA    2DBA
2DB6:  MOVLB  1
....................       } 
....................           
....................     break; 
2DB8:  MOVLB  0
....................  
....................  
....................   } 
....................  
....................   return; 
2DBA:  RETURN 0
....................  
.................... } 
....................  
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao) //get_value(posicao_valor_comando,3,6); 
*
2382:  MOVLB  6
2384:  CLRF   xBA
2386:  CLRF   xB9
2388:  CLRF   xB8
238A:  CLRF   xB7
238C:  CLRF   xBB
238E:  CLRF   xBF
2390:  CLRF   xBE
2392:  CLRF   xBD
2394:  MOVLW  01
2396:  MOVWF  xBC
2398:  CLRF   xC0
.................... { 
....................   int32 valor = 0; 
....................   int i = 0; 
....................   int32 aux = 1; 
....................   int potencia = 0; 
....................  
....................   while(nro_caracteres > 0) 
239A:  MOVF   xB5,F
239C:  BZ    2460
....................   { 
....................     if( pointer_to_string[posicao+i] != '.' ) 
239E:  MOVF   xBB,W
23A0:  ADDWF  xB6,W
23A2:  CLRF   03
23A4:  ADDWF  xB3,W
23A6:  MOVWF  FE9
23A8:  MOVF   xB4,W
23AA:  ADDWFC 03,W
23AC:  MOVWF  FEA
23AE:  MOVF   FEF,W
23B0:  SUBLW  2E
23B2:  BZ    245C
....................     { 
....................       nro_caracteres--; 
23B4:  DECF   xB5,F
....................       potencia = nro_caracteres; 
23B6:  MOVFF  6B5,6C0
....................       aux = 1; 
23BA:  CLRF   xBF
23BC:  CLRF   xBE
23BE:  CLRF   xBD
23C0:  MOVLW  01
23C2:  MOVWF  xBC
....................       while(potencia > 0) 
23C4:  MOVF   xC0,F
23C6:  BZ    23FC
....................       { 
....................         aux = aux * 10; 
23C8:  MOVFF  6BF,6CA
23CC:  MOVFF  6BE,6C9
23D0:  MOVFF  6BD,6C8
23D4:  MOVFF  6BC,6C7
23D8:  CLRF   xCE
23DA:  CLRF   xCD
23DC:  CLRF   xCC
23DE:  MOVLW  0A
23E0:  MOVWF  xCB
23E2:  MOVLB  0
23E4:  RCALL  2326
23E6:  MOVFF  03,6BF
23EA:  MOVFF  02,6BE
23EE:  MOVFF  01,6BD
23F2:  MOVFF  00,6BC
....................         potencia--; 
23F6:  MOVLB  6
23F8:  DECF   xC0,F
23FA:  BRA    23C4
....................       } 
....................       valor = valor + ((int32)(pointer_to_string[posicao+i]-48)*aux); 
23FC:  MOVF   xBB,W
23FE:  ADDWF  xB6,W
2400:  CLRF   03
2402:  ADDWF  xB3,W
2404:  MOVWF  FE9
2406:  MOVF   xB4,W
2408:  ADDWFC 03,W
240A:  MOVWF  FEA
240C:  MOVLW  30
240E:  SUBWF  FEF,W
2410:  CLRF   xC4
2412:  CLRF   xC3
2414:  CLRF   xC2
2416:  MOVWF  xC1
2418:  MOVFF  FEA,6C6
241C:  MOVFF  FE9,6C5
2420:  MOVFF  6C4,6CA
2424:  MOVFF  6C3,6C9
2428:  MOVFF  6C2,6C8
242C:  MOVWF  xC7
242E:  MOVFF  6BF,6CE
2432:  MOVFF  6BE,6CD
2436:  MOVFF  6BD,6CC
243A:  MOVFF  6BC,6CB
243E:  MOVLB  0
2440:  RCALL  2326
2442:  MOVFF  6C6,FEA
2446:  MOVFF  6C5,FE9
244A:  MOVF   00,W
244C:  MOVLB  6
244E:  ADDWF  xB7,F
2450:  MOVF   01,W
2452:  ADDWFC xB8,F
2454:  MOVF   02,W
2456:  ADDWFC xB9,F
2458:  MOVF   03,W
245A:  ADDWFC xBA,F
....................     } 
....................     i++; 
245C:  INCF   xBB,F
245E:  BRA    239A
....................   } 
....................  
....................   return(valor); 
2460:  MOVFF  6B7,00
2464:  MOVFF  6B8,01
2468:  MOVFF  6B9,02
246C:  MOVFF  6BA,03
2470:  MOVLB  0
2472:  RETURN 0
.................... } 
....................  
.................... void get_numero(int nro_caracteres, int posicao, char *destino){ 
*
1C14:  MOVLB  6
1C16:  CLRF   xB7
....................  
....................   int8 index = 0; 
....................  
....................   for(index = 0;index< nro_caracteres;index++){ 
1C18:  CLRF   xB7
1C1A:  MOVF   xB3,W
1C1C:  SUBWF  xB7,W
1C1E:  BC    1C54
....................  
....................     destino[index] = comando_recibido_BUFF[index+posicao]; 
1C20:  CLRF   03
1C22:  MOVF   xB7,W
1C24:  ADDWF  xB5,W
1C26:  MOVWF  01
1C28:  MOVF   xB6,W
1C2A:  ADDWFC 03,F
1C2C:  MOVFF  03,6B9
1C30:  MOVF   xB4,W
1C32:  ADDWF  xB7,W
1C34:  CLRF   03
1C36:  ADDLW  E8
1C38:  MOVWF  FE9
1C3A:  MOVLW  00
1C3C:  ADDWFC 03,W
1C3E:  MOVWF  FEA
1C40:  MOVFF  FEF,6BA
1C44:  MOVFF  6B9,FEA
1C48:  MOVFF  01,FE9
1C4C:  MOVFF  6BA,FEF
1C50:  INCF   xB7,F
1C52:  BRA    1C1A
....................  
....................   } 
....................  
....................   destino[index] = '\0'; 
1C54:  CLRF   03
1C56:  MOVF   xB7,W
1C58:  ADDWF  xB5,W
1C5A:  MOVWF  FE9
1C5C:  MOVF   xB6,W
1C5E:  ADDWFC 03,W
1C60:  MOVWF  FEA
1C62:  CLRF   FEF
....................  
....................   return; 
1C64:  MOVLB  0
1C66:  RETURN 0
.................... } 
....................  
.................... void clear_command(){ 
....................  
....................   delay_ms(200); 
*
2DBC:  MOVLW  C8
2DBE:  MOVLB  7
2DC0:  MOVWF  x26
2DC2:  MOVLB  0
2DC4:  CALL   0AF2
....................   memset (comando_recibido_UART, 0x00, sizeof(comando_recibido_UART)); 
2DC8:  CLRF   FEA
2DCA:  MOVLW  52
2DCC:  MOVWF  FE9
2DCE:  CLRF   00
2DD0:  CLRF   02
2DD2:  MOVLW  96
2DD4:  MOVWF  01
2DD6:  CALL   1DC4
....................   memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2DDA:  CLRF   FEA
2DDC:  MOVLW  E8
2DDE:  MOVWF  FE9
2DE0:  CLRF   00
2DE2:  CLRF   02
2DE4:  MOVLW  96
2DE6:  MOVWF  01
2DE8:  CALL   1DC4
....................  
....................   comando_disponivel_UART = FALSE; 
2DEC:  MOVLB  1
2DEE:  BCF    x82.0
....................   enable_interrupts(GLOBAL); 
2DF0:  MOVLW  C0
2DF2:  IORWF  FF2,F
....................   enable_interrupts(INT_RTCC); 
2DF4:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
2DF6:  BSF    F9D.5
....................    
....................   return; 
2DF8:  MOVLB  0
2DFA:  GOTO   2F52 (RETURN)
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... extern int1 resposta_SIM; 
.................... extern comando_disponivel_UART; 
.................... int32 timeout = 7000000; 
.................... char coordenada[40]; 
....................  
.................... int1 envia_SIM800L(char *send, char *recive){ 
*
0C4C:  MOVLW  02
0C4E:  MOVLB  7
0C50:  MOVWF  x1F
....................  
....................   int8 tentativas = 2; 
....................  
....................   disable_interrupts(INT_RTCC);  
0C52:  BCF    FF2.5
....................   enable_interrupts(INT_RDA);                                               
0C54:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
0C56:  MOVLW  C0
0C58:  IORWF  FF2,F
....................    
....................   do{ 
....................     timeout = 7000000;   
0C5A:  MOVLB  1
0C5C:  CLRF   xA0
0C5E:  MOVLW  6A
0C60:  MOVWF  x9F
0C62:  MOVLW  CF
0C64:  MOVWF  x9E
0C66:  MOVLW  C0
0C68:  MOVWF  x9D
....................     comando_disponivel_UART = 0; 
0C6A:  BCF    x82.0
....................  
....................     fprintf(SIM800L_SERIAL,send);                                             // Envia comando para o SIM800L  
0C6C:  MOVFF  71C,FEA
0C70:  MOVFF  71B,FE9
0C74:  MOVLB  0
0C76:  BRA    0B8C
....................     if(strstr(recive,"+CMGS")!=0){ 
0C78:  MOVLW  2B
0C7A:  MOVLB  7
0C7C:  MOVWF  x20
0C7E:  MOVLW  43
0C80:  MOVWF  x21
0C82:  MOVLW  4D
0C84:  MOVWF  x22
0C86:  MOVLW  47
0C88:  MOVWF  x23
0C8A:  MOVLW  53
0C8C:  MOVWF  x24
0C8E:  CLRF   x25
0C90:  MOVFF  71E,729
0C94:  MOVFF  71D,728
0C98:  MOVLW  07
0C9A:  MOVWF  x2B
0C9C:  MOVLW  20
0C9E:  MOVWF  x2A
0CA0:  MOVLB  0
0CA2:  RCALL  0BB4
0CA4:  MOVFF  02,729
0CA8:  MOVFF  01,728
0CAC:  MOVLB  7
0CAE:  MOVF   x28,F
0CB0:  BNZ   0CB6
0CB2:  MOVF   x29,F
0CB4:  BZ    0CC4
....................       delay_ms(150); 
0CB6:  MOVLW  96
0CB8:  MOVWF  x26
0CBA:  MOVLB  0
0CBC:  RCALL  0AF2
....................       fputc(0x1A,SIM800L_SERIAL); 
0CBE:  MOVLW  1A
0CC0:  BRA    0C42
0CC2:  MOVLB  7
....................     }                                                                                         
....................     while(!comando_disponivel_UART && --timeout > 0);                         // Aguarda o SIM800L responder por ~23 segundos caso nao responda retorna 0 
0CC4:  MOVLB  1
0CC6:  BTFSC  x82.0
0CC8:  BRA    0CEA
0CCA:  MOVLW  FF
0CCC:  ADDWF  x9D,F
0CCE:  BTFSS  FD8.0
0CD0:  ADDWF  x9E,F
0CD2:  BTFSS  FD8.0
0CD4:  ADDWF  x9F,F
0CD6:  BTFSS  FD8.0
0CD8:  ADDWF  xA0,F
0CDA:  MOVF   x9D,F
0CDC:  BNZ   0CC6
0CDE:  MOVF   x9E,F
0CE0:  BNZ   0CC6
0CE2:  MOVF   x9F,F
0CE4:  BNZ   0CC6
0CE6:  MOVF   xA0,F
0CE8:  BNZ   0CC6
....................                           
....................     if(comando_disponivel_UART){                                              // Caso receba a resposta  
0CEA:  BTFSS  x82.0
0CEC:  BRA    0D24
....................       comando_disponivel_UART = 0;                   
0CEE:  BCF    x82.0
....................       posicao_valor_comando = strstr(comando_recibido_UART,recive);           // Procura a palavra recive da funcao na resposta recebida 
0CF0:  MOVLB  7
0CF2:  CLRF   x29
0CF4:  MOVLW  52
0CF6:  MOVWF  x28
0CF8:  MOVFF  71E,72B
0CFC:  MOVFF  71D,72A
0D00:  MOVLB  0
0D02:  RCALL  0BB4
0D04:  MOVFF  02,17F
0D08:  MOVFF  01,17E
....................                  
....................       if(posicao_valor_comando!= 0){                                          // Caso encontre a resposta esperada 
0D0C:  MOVLB  1
0D0E:  MOVF   x7E,F
0D10:  BNZ   0D16
0D12:  MOVF   x7F,F
0D14:  BZ    0D24
....................         enable_interrupts(INT_RDA); 
0D16:  BSF    F9D.5
....................         enable_interrupts(INT_RTCC); 
0D18:  BSF    FF2.5
....................         enable_interrupts(GLOBAL); 
0D1A:  MOVLW  C0
0D1C:  IORWF  FF2,F
....................         return 1; 
0D1E:  MOVLW  01
0D20:  MOVWF  01
0D22:  BRA    0D38
....................       } 
....................     } 
....................   }while(--tentativas>0);                 
0D24:  MOVLB  7
0D26:  DECFSZ x1F,F
0D28:  BRA    0C5A
....................    
....................   enable_interrupts(GLOBAL); 
0D2A:  MOVLW  C0
0D2C:  IORWF  FF2,F
....................   enable_interrupts(INT_RDA); 
0D2E:  BSF    F9D.5
....................   enable_interrupts(INT_RTCC); 
0D30:  BSF    FF2.5
....................  
....................   return 0; 
0D32:  MOVLW  00
0D34:  MOVWF  01
0D36:  MOVLB  1
0D38:  MOVLB  0
0D3A:  RETURN 0
.................... } 
....................  
.................... int1 Send_SMS(char *numero,char *mensagem){ 
....................    
....................   char numero_envio[35]; 
....................  
....................   sprintf(numero_envio,"AT+CMGS=\"%s\"\r\n",numero); 
0D3C:  MOVLW  06
0D3E:  MOVLB  1
0D40:  MOVWF  x9C
0D42:  MOVLW  DC
0D44:  MOVWF  x9B
0D46:  MOVLW  4C
0D48:  MOVWF  FF6
0D4A:  MOVLW  07
0D4C:  MOVWF  FF7
0D4E:  MOVLW  09
0D50:  MOVLB  7
0D52:  MOVWF  x17
0D54:  MOVLB  0
0D56:  RCALL  0B3E
0D58:  MOVFF  6D9,FEA
0D5C:  MOVFF  6D8,FE9
0D60:  BRA    0B66
0D62:  MOVLW  57
0D64:  MOVWF  FF6
0D66:  MOVLW  07
0D68:  MOVWF  FF7
0D6A:  MOVLW  03
0D6C:  MOVLB  7
0D6E:  MOVWF  x17
0D70:  MOVLB  0
0D72:  RCALL  0B3E
....................  
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
0D74:  MOVLW  06
0D76:  MOVWF  FEA
0D78:  SETF   FE9
0D7A:  MOVFF  FF2,717
0D7E:  BCF    FF2.7
0D80:  MOVLW  0C
0D82:  MOVWF  01
0D84:  CLRF   FF7
0D86:  MOVLW  00
0D88:  CALL   0276
0D8C:  TBLRD*-
0D8E:  TBLRD*+
0D90:  MOVFF  FF5,FEE
0D94:  DECFSZ 01,F
0D96:  BRA    0D8E
0D98:  MOVLB  7
0D9A:  BTFSC  x17.7
0D9C:  BSF    FF2.7
0D9E:  MOVLW  4F
0DA0:  MOVWF  x0B
0DA2:  MOVLW  4B
0DA4:  MOVWF  x0C
0DA6:  CLRF   x0D
0DA8:  MOVLW  06
0DAA:  MOVWF  x1C
0DAC:  SETF   x1B
0DAE:  MOVLW  07
0DB0:  MOVWF  x1E
0DB2:  MOVLW  0B
0DB4:  MOVWF  x1D
0DB6:  MOVLB  0
0DB8:  RCALL  0C4C
0DBA:  MOVF   01,F
0DBC:  BZ    0E6E
....................     if(envia_SIM800L("AT+CSMP=17,255,0,0\r\n","OK")) 
0DBE:  MOVLW  06
0DC0:  MOVWF  FEA
0DC2:  SETF   FE9
0DC4:  MOVFF  FF2,717
0DC8:  BCF    FF2.7
0DCA:  MOVLW  15
0DCC:  MOVWF  01
0DCE:  CLRF   FF7
0DD0:  MOVLW  00
0DD2:  CALL   029C
0DD6:  TBLRD*-
0DD8:  TBLRD*+
0DDA:  MOVFF  FF5,FEE
0DDE:  DECFSZ 01,F
0DE0:  BRA    0DD8
0DE2:  MOVLB  7
0DE4:  BTFSC  x17.7
0DE6:  BSF    FF2.7
0DE8:  MOVLW  4F
0DEA:  MOVWF  x14
0DEC:  MOVLW  4B
0DEE:  MOVWF  x15
0DF0:  CLRF   x16
0DF2:  MOVLW  06
0DF4:  MOVWF  x1C
0DF6:  SETF   x1B
0DF8:  MOVLW  07
0DFA:  MOVWF  x1E
0DFC:  MOVLW  14
0DFE:  MOVWF  x1D
0E00:  MOVLB  0
0E02:  RCALL  0C4C
0E04:  MOVF   01,F
0E06:  BZ    0E6E
....................       if(envia_SIM800L(numero_envio, ">")) 
0E08:  MOVLW  3E
0E0A:  MOVLB  6
0E0C:  MOVWF  xFF
0E0E:  MOVLB  7
0E10:  CLRF   x00
0E12:  MOVLW  06
0E14:  MOVWF  x1C
0E16:  MOVLW  DC
0E18:  MOVWF  x1B
0E1A:  MOVLW  06
0E1C:  MOVWF  x1E
0E1E:  SETF   x1D
0E20:  MOVLB  0
0E22:  RCALL  0C4C
0E24:  MOVF   01,F
0E26:  BZ    0E6E
....................         if(envia_SIM800L(mensagem, "+CMGS:")) 
0E28:  MOVLW  06
0E2A:  MOVWF  FEA
0E2C:  SETF   FE9
0E2E:  MOVFF  FF2,717
0E32:  BCF    FF2.7
0E34:  MOVLW  07
0E36:  MOVWF  01
0E38:  CLRF   FF7
0E3A:  MOVLW  00
0E3C:  CALL   02CC
0E40:  TBLRD*-
0E42:  TBLRD*+
0E44:  MOVFF  FF5,FEE
0E48:  DECFSZ 01,F
0E4A:  BRA    0E42
0E4C:  MOVLB  7
0E4E:  BTFSC  x17.7
0E50:  BSF    FF2.7
0E52:  MOVFF  6DB,71C
0E56:  MOVFF  6DA,71B
0E5A:  MOVLW  06
0E5C:  MOVWF  x1E
0E5E:  SETF   x1D
0E60:  MOVLB  0
0E62:  RCALL  0C4C
0E64:  MOVF   01,F
0E66:  BZ    0E6E
....................           return 1; 
0E68:  MOVLW  01
0E6A:  MOVWF  01
0E6C:  BRA    0E72
....................   return 0; 
0E6E:  MOVLW  00
0E70:  MOVWF  01
0E72:  RETURN 0
.................... } 
....................  
.................... int1 Read_SMS(){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")){ 
*
1B60:  MOVLW  06
1B62:  MOVWF  FEA
1B64:  MOVLW  B3
1B66:  MOVWF  FE9
1B68:  MOVFF  FF2,6CB
1B6C:  BCF    FF2.7
1B6E:  MOVLW  0C
1B70:  MOVWF  01
1B72:  CLRF   FF7
1B74:  MOVLW  00
1B76:  CALL   0276
1B7A:  TBLRD*-
1B7C:  TBLRD*+
1B7E:  MOVFF  FF5,FEE
1B82:  DECFSZ 01,F
1B84:  BRA    1B7C
1B86:  MOVLB  6
1B88:  BTFSC  xCB.7
1B8A:  BSF    FF2.7
1B8C:  MOVLW  4F
1B8E:  MOVWF  xBF
1B90:  MOVLW  4B
1B92:  MOVWF  xC0
1B94:  CLRF   xC1
1B96:  MOVLW  06
1B98:  MOVLB  7
1B9A:  MOVWF  x1C
1B9C:  MOVLW  B3
1B9E:  MOVWF  x1B
1BA0:  MOVLW  06
1BA2:  MOVWF  x1E
1BA4:  MOVLW  BF
1BA6:  MOVWF  x1D
1BA8:  MOVLB  0
1BAA:  CALL   0C4C
1BAE:  MOVF   01,F
1BB0:  BZ    1C08
....................     if(envia_SIM800L("AT+CMGL=\"REC UNREAD\"\r\n", "")){ 
1BB2:  MOVLW  06
1BB4:  MOVWF  FEA
1BB6:  MOVLW  B3
1BB8:  MOVWF  FE9
1BBA:  MOVFF  FF2,6CB
1BBE:  BCF    FF2.7
1BC0:  MOVLW  17
1BC2:  MOVWF  01
1BC4:  CLRF   FF7
1BC6:  MOVLW  00
1BC8:  CALL   02EE
1BCC:  TBLRD*-
1BCE:  TBLRD*+
1BD0:  MOVFF  FF5,FEE
1BD4:  DECFSZ 01,F
1BD6:  BRA    1BCE
1BD8:  MOVLB  6
1BDA:  BTFSC  xCB.7
1BDC:  BSF    FF2.7
1BDE:  CLRF   xCA
1BE0:  MOVLW  06
1BE2:  MOVLB  7
1BE4:  MOVWF  x1C
1BE6:  MOVLW  B3
1BE8:  MOVWF  x1B
1BEA:  MOVLW  06
1BEC:  MOVWF  x1E
1BEE:  MOVLW  CA
1BF0:  MOVWF  x1D
1BF2:  MOVLB  0
1BF4:  CALL   0C4C
1BF8:  MOVF   01,F
1BFA:  BZ    1C08
....................       resposta_SIM = true; 
1BFC:  MOVLB  1
1BFE:  BSF    x82.1
....................       return 1;     
1C00:  MOVLW  01
1C02:  MOVWF  01
1C04:  BRA    1C0E
1C06:  MOVLB  0
....................     }   
....................   } 
....................   return 0; 
1C08:  MOVLW  00
1C0A:  MOVWF  01
1C0C:  MOVLB  1
1C0E:  MOVLB  0
1C10:  GOTO   2DBA (RETURN)
.................... } 
....................  
.................... int1 Get_Locate(char *numero){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
*
1F56:  MOVLW  06
1F58:  MOVWF  FEA
1F5A:  MOVLW  B5
1F5C:  MOVWF  FE9
1F5E:  MOVFF  FF2,6D8
1F62:  BCF    FF2.7
1F64:  MOVLW  0C
1F66:  MOVWF  01
1F68:  CLRF   FF7
1F6A:  MOVLW  00
1F6C:  CALL   0276
1F70:  TBLRD*-
1F72:  TBLRD*+
1F74:  MOVFF  FF5,FEE
1F78:  DECFSZ 01,F
1F7A:  BRA    1F72
1F7C:  MOVLB  6
1F7E:  BTFSC  xD8.7
1F80:  BSF    FF2.7
1F82:  MOVLW  4F
1F84:  MOVWF  xC1
1F86:  MOVLW  4B
1F88:  MOVWF  xC2
1F8A:  CLRF   xC3
1F8C:  MOVLW  06
1F8E:  MOVLB  7
1F90:  MOVWF  x1C
1F92:  MOVLW  B5
1F94:  MOVWF  x1B
1F96:  MOVLW  06
1F98:  MOVWF  x1E
1F9A:  MOVLW  C1
1F9C:  MOVWF  x1D
1F9E:  MOVLB  0
1FA0:  CALL   0C4C
1FA4:  MOVF   01,F
1FA6:  BTFSC  FD8.2
1FA8:  BRA    22D0
....................     if(envia_SIM800L("AT+CGATT=1\r\n","OK")) 
1FAA:  MOVLW  06
1FAC:  MOVWF  FEA
1FAE:  MOVLW  B5
1FB0:  MOVWF  FE9
1FB2:  MOVFF  FF2,6D8
1FB6:  BCF    FF2.7
1FB8:  MOVLW  0D
1FBA:  MOVWF  01
1FBC:  CLRF   FF7
1FBE:  MOVLW  00
1FC0:  CALL   0320
1FC4:  TBLRD*-
1FC6:  TBLRD*+
1FC8:  MOVFF  FF5,FEE
1FCC:  DECFSZ 01,F
1FCE:  BRA    1FC6
1FD0:  MOVLB  6
1FD2:  BTFSC  xD8.7
1FD4:  BSF    FF2.7
1FD6:  MOVLW  4F
1FD8:  MOVWF  xC2
1FDA:  MOVLW  4B
1FDC:  MOVWF  xC3
1FDE:  CLRF   xC4
1FE0:  MOVLW  06
1FE2:  MOVLB  7
1FE4:  MOVWF  x1C
1FE6:  MOVLW  B5
1FE8:  MOVWF  x1B
1FEA:  MOVLW  06
1FEC:  MOVWF  x1E
1FEE:  MOVLW  C2
1FF0:  MOVWF  x1D
1FF2:  MOVLB  0
1FF4:  CALL   0C4C
1FF8:  MOVF   01,F
1FFA:  BTFSC  FD8.2
1FFC:  BRA    22D0
....................       if(envia_SIM800L("AT+SAPBR=3,1,\"CONTYPE\",\"GPRS\"\r\n","OK")) 
1FFE:  MOVLW  06
2000:  MOVWF  FEA
2002:  MOVLW  B5
2004:  MOVWF  FE9
2006:  MOVFF  FF2,6D8
200A:  BCF    FF2.7
200C:  MOVLW  20
200E:  MOVWF  01
2010:  CLRF   FF7
2012:  MOVLW  00
2014:  CALL   0348
2018:  TBLRD*-
201A:  TBLRD*+
201C:  MOVFF  FF5,FEE
2020:  DECFSZ 01,F
2022:  BRA    201A
2024:  MOVLB  6
2026:  BTFSC  xD8.7
2028:  BSF    FF2.7
202A:  MOVLW  4F
202C:  MOVWF  xD5
202E:  MOVLW  4B
2030:  MOVWF  xD6
2032:  CLRF   xD7
2034:  MOVLW  06
2036:  MOVLB  7
2038:  MOVWF  x1C
203A:  MOVLW  B5
203C:  MOVWF  x1B
203E:  MOVLW  06
2040:  MOVWF  x1E
2042:  MOVLW  D5
2044:  MOVWF  x1D
2046:  MOVLB  0
2048:  CALL   0C4C
204C:  MOVF   01,F
204E:  BTFSC  FD8.2
2050:  BRA    22D0
....................         if(envia_SIM800L("AT+SAPBR=3,1,\"APN\",\"CMNET\"\r\n","OK")) 
2052:  MOVLW  06
2054:  MOVWF  FEA
2056:  MOVLW  B5
2058:  MOVWF  FE9
205A:  MOVFF  FF2,6D8
205E:  BCF    FF2.7
2060:  MOVLW  1D
2062:  MOVWF  01
2064:  CLRF   FF7
2066:  MOVLW  00
2068:  CALL   0382
206C:  TBLRD*-
206E:  TBLRD*+
2070:  MOVFF  FF5,FEE
2074:  DECFSZ 01,F
2076:  BRA    206E
2078:  MOVLB  6
207A:  BTFSC  xD8.7
207C:  BSF    FF2.7
207E:  MOVLW  4F
2080:  MOVWF  xD2
2082:  MOVLW  4B
2084:  MOVWF  xD3
2086:  CLRF   xD4
2088:  MOVLW  06
208A:  MOVLB  7
208C:  MOVWF  x1C
208E:  MOVLW  B5
2090:  MOVWF  x1B
2092:  MOVLW  06
2094:  MOVWF  x1E
2096:  MOVLW  D2
2098:  MOVWF  x1D
209A:  MOVLB  0
209C:  CALL   0C4C
20A0:  MOVF   01,F
20A2:  BTFSC  FD8.2
20A4:  BRA    22D0
....................           if(envia_SIM800L("AT+SAPBR=1,1\r\n","OK")) 
20A6:  MOVLW  06
20A8:  MOVWF  FEA
20AA:  MOVLW  B5
20AC:  MOVWF  FE9
20AE:  MOVFF  FF2,6D8
20B2:  BCF    FF2.7
20B4:  MOVLW  0F
20B6:  MOVWF  01
20B8:  CLRF   FF7
20BA:  MOVLW  00
20BC:  CALL   03BA
20C0:  TBLRD*-
20C2:  TBLRD*+
20C4:  MOVFF  FF5,FEE
20C8:  DECFSZ 01,F
20CA:  BRA    20C2
20CC:  MOVLB  6
20CE:  BTFSC  xD8.7
20D0:  BSF    FF2.7
20D2:  MOVLW  4F
20D4:  MOVWF  xC4
20D6:  MOVLW  4B
20D8:  MOVWF  xC5
20DA:  CLRF   xC6
20DC:  MOVLW  06
20DE:  MOVLB  7
20E0:  MOVWF  x1C
20E2:  MOVLW  B5
20E4:  MOVWF  x1B
20E6:  MOVLW  06
20E8:  MOVWF  x1E
20EA:  MOVLW  C4
20EC:  MOVWF  x1D
20EE:  MOVLB  0
20F0:  CALL   0C4C
20F4:  MOVF   01,F
20F6:  BTFSC  FD8.2
20F8:  BRA    22D0
....................             if(envia_SIM800L("AT+SAPBR=2,1\r\n","+SAPBR:")) 
20FA:  MOVLW  06
20FC:  MOVWF  FEA
20FE:  MOVLW  B5
2100:  MOVWF  FE9
2102:  MOVFF  FF2,6D8
2106:  BCF    FF2.7
2108:  MOVLW  0F
210A:  MOVWF  01
210C:  CLRF   FF7
210E:  MOVLW  00
2110:  CALL   03E4
2114:  TBLRD*-
2116:  TBLRD*+
2118:  MOVFF  FF5,FEE
211C:  DECFSZ 01,F
211E:  BRA    2116
2120:  MOVLB  6
2122:  BTFSC  xD8.7
2124:  BSF    FF2.7
2126:  MOVLW  06
2128:  MOVWF  FEA
212A:  MOVLW  C4
212C:  MOVWF  FE9
212E:  MOVFF  FF2,6DA
2132:  BCF    FF2.7
2134:  MOVLW  08
2136:  MOVWF  01
2138:  CLRF   FF7
213A:  MOVLW  00
213C:  MOVLB  0
213E:  CALL   040E
2142:  TBLRD*-
2144:  TBLRD*+
2146:  MOVFF  FF5,FEE
214A:  DECFSZ 01,F
214C:  BRA    2144
214E:  MOVLB  6
2150:  BTFSC  xDA.7
2152:  BSF    FF2.7
2154:  MOVLW  06
2156:  MOVLB  7
2158:  MOVWF  x1C
215A:  MOVLW  B5
215C:  MOVWF  x1B
215E:  MOVLW  06
2160:  MOVWF  x1E
2162:  MOVLW  C4
2164:  MOVWF  x1D
2166:  MOVLB  0
2168:  CALL   0C4C
216C:  MOVF   01,F
216E:  BTFSC  FD8.2
2170:  BRA    22D0
....................               if(envia_SIM800L("AT+CLBSCFG=0,1\r\n","+CLBSCFG:")){                 
2172:  MOVLW  06
2174:  MOVWF  FEA
2176:  MOVLW  B5
2178:  MOVWF  FE9
217A:  MOVFF  FF2,6D8
217E:  BCF    FF2.7
2180:  MOVLW  11
2182:  MOVWF  01
2184:  CLRF   FF7
2186:  MOVLW  00
2188:  CALL   0430
218C:  TBLRD*-
218E:  TBLRD*+
2190:  MOVFF  FF5,FEE
2194:  DECFSZ 01,F
2196:  BRA    218E
2198:  MOVLB  6
219A:  BTFSC  xD8.7
219C:  BSF    FF2.7
219E:  MOVLW  06
21A0:  MOVWF  FEA
21A2:  MOVLW  C6
21A4:  MOVWF  FE9
21A6:  MOVFF  FF2,6DA
21AA:  BCF    FF2.7
21AC:  MOVLW  0A
21AE:  MOVWF  01
21B0:  CLRF   FF7
21B2:  MOVLW  00
21B4:  MOVLB  0
21B6:  CALL   045C
21BA:  TBLRD*-
21BC:  TBLRD*+
21BE:  MOVFF  FF5,FEE
21C2:  DECFSZ 01,F
21C4:  BRA    21BC
21C6:  MOVLB  6
21C8:  BTFSC  xDA.7
21CA:  BSF    FF2.7
21CC:  MOVLW  06
21CE:  MOVLB  7
21D0:  MOVWF  x1C
21D2:  MOVLW  B5
21D4:  MOVWF  x1B
21D6:  MOVLW  06
21D8:  MOVWF  x1E
21DA:  MOVLW  C6
21DC:  MOVWF  x1D
21DE:  MOVLB  0
21E0:  CALL   0C4C
21E4:  MOVF   01,F
21E6:  BZ    22D0
....................                 if(envia_SIM800L("AT+CLBS=1,1\r\n","+CLBS:")){ 
21E8:  MOVLW  06
21EA:  MOVWF  FEA
21EC:  MOVLW  B5
21EE:  MOVWF  FE9
21F0:  MOVFF  FF2,6D8
21F4:  BCF    FF2.7
21F6:  MOVLW  0E
21F8:  MOVWF  01
21FA:  CLRF   FF7
21FC:  MOVLW  00
21FE:  CALL   0480
2202:  TBLRD*-
2204:  TBLRD*+
2206:  MOVFF  FF5,FEE
220A:  DECFSZ 01,F
220C:  BRA    2204
220E:  MOVLB  6
2210:  BTFSC  xD8.7
2212:  BSF    FF2.7
2214:  MOVLW  06
2216:  MOVWF  FEA
2218:  MOVLW  C3
221A:  MOVWF  FE9
221C:  MOVFF  FF2,6DA
2220:  BCF    FF2.7
2222:  MOVLW  07
2224:  MOVWF  01
2226:  CLRF   FF7
2228:  MOVLW  00
222A:  MOVLB  0
222C:  CALL   04A8
2230:  TBLRD*-
2232:  TBLRD*+
2234:  MOVFF  FF5,FEE
2238:  DECFSZ 01,F
223A:  BRA    2232
223C:  MOVLB  6
223E:  BTFSC  xDA.7
2240:  BSF    FF2.7
2242:  MOVLW  06
2244:  MOVLB  7
2246:  MOVWF  x1C
2248:  MOVLW  B5
224A:  MOVWF  x1B
224C:  MOVLW  06
224E:  MOVWF  x1E
2250:  MOVLW  C3
2252:  MOVWF  x1D
2254:  MOVLB  0
2256:  CALL   0C4C
225A:  MOVF   01,F
225C:  BZ    22D0
....................                   Get_Coordenadas(); 
225E:  BRA    1DF4
....................                   Send_SMS(numero,coordenada);  
2260:  MOVFF  6B4,6D9
2264:  MOVFF  6B3,6D8
2268:  MOVLW  01
226A:  MOVLB  6
226C:  MOVWF  xDB
226E:  MOVLW  A1
2270:  MOVWF  xDA
2272:  MOVLB  0
2274:  CALL   0D3C
....................                   if(envia_SIM800L("AT+SAPBR=0,1\r\n","OK")) 
2278:  MOVLW  06
227A:  MOVWF  FEA
227C:  MOVLW  B5
227E:  MOVWF  FE9
2280:  MOVFF  FF2,6D8
2284:  BCF    FF2.7
2286:  MOVLW  0F
2288:  MOVWF  01
228A:  CLRF   FF7
228C:  MOVLW  00
228E:  CALL   04CA
2292:  TBLRD*-
2294:  TBLRD*+
2296:  MOVFF  FF5,FEE
229A:  DECFSZ 01,F
229C:  BRA    2294
229E:  MOVLB  6
22A0:  BTFSC  xD8.7
22A2:  BSF    FF2.7
22A4:  MOVLW  4F
22A6:  MOVWF  xC4
22A8:  MOVLW  4B
22AA:  MOVWF  xC5
22AC:  CLRF   xC6
22AE:  MOVLW  06
22B0:  MOVLB  7
22B2:  MOVWF  x1C
22B4:  MOVLW  B5
22B6:  MOVWF  x1B
22B8:  MOVLW  06
22BA:  MOVWF  x1E
22BC:  MOVLW  C4
22BE:  MOVWF  x1D
22C0:  MOVLB  0
22C2:  CALL   0C4C
22C6:  MOVF   01,F
22C8:  BZ    22D0
....................                     return 1;  
22CA:  MOVLW  01
22CC:  MOVWF  01
22CE:  BRA    2322
....................                 } 
....................               } 
....................   
....................   envia_SIM800L("AT+SAPBR=0,1\r\n","OK"); 
22D0:  MOVLW  06
22D2:  MOVWF  FEA
22D4:  MOVLW  B5
22D6:  MOVWF  FE9
22D8:  MOVFF  FF2,6D8
22DC:  BCF    FF2.7
22DE:  MOVLW  0F
22E0:  MOVWF  01
22E2:  CLRF   FF7
22E4:  MOVLW  00
22E6:  CALL   04CA
22EA:  TBLRD*-
22EC:  TBLRD*+
22EE:  MOVFF  FF5,FEE
22F2:  DECFSZ 01,F
22F4:  BRA    22EC
22F6:  MOVLB  6
22F8:  BTFSC  xD8.7
22FA:  BSF    FF2.7
22FC:  MOVLW  4F
22FE:  MOVWF  xC4
2300:  MOVLW  4B
2302:  MOVWF  xC5
2304:  CLRF   xC6
2306:  MOVLW  06
2308:  MOVLB  7
230A:  MOVWF  x1C
230C:  MOVLW  B5
230E:  MOVWF  x1B
2310:  MOVLW  06
2312:  MOVWF  x1E
2314:  MOVLW  C4
2316:  MOVWF  x1D
2318:  MOVLB  0
231A:  CALL   0C4C
....................   return 0;    
231E:  MOVLW  00
2320:  MOVWF  01
2322:  GOTO   2DBA (RETURN)
.................... } 
....................  
.................... void Get_Coordenadas(){ 
*
1DF4:  MOVLB  6
1DF6:  CLRF   xD8
1DF8:  CLRF   xD9
....................   
....................  int8 index=0; 
....................  int8 index2=0; 
....................  
....................   memset (coordenada, 0x00, sizeof(coordenada)); 
1DFA:  MOVLW  01
1DFC:  MOVWF  FEA
1DFE:  MOVLW  A1
1E00:  MOVWF  FE9
1E02:  CLRF   00
1E04:  CLRF   02
1E06:  MOVLW  28
1E08:  MOVWF  01
1E0A:  MOVLB  0
1E0C:  RCALL  1DC4
....................    
....................   coordenada[0] ='L'; 
1E0E:  MOVLW  4C
1E10:  MOVLB  1
1E12:  MOVWF  xA1
....................   coordenada[1] ='O'; 
1E14:  MOVLW  4F
1E16:  MOVWF  xA2
....................   coordenada[2] ='C'; 
1E18:  MOVLW  43
1E1A:  MOVWF  xA3
....................   coordenada[3] ='A'; 
1E1C:  MOVLW  41
1E1E:  MOVWF  xA4
....................   coordenada[4] ='T'; 
1E20:  MOVLW  54
1E22:  MOVWF  xA5
....................   coordenada[5] ='E'; 
1E24:  MOVLW  45
1E26:  MOVWF  xA6
....................   coordenada[6] =':'; 
1E28:  MOVLW  3A
1E2A:  MOVWF  xA7
....................   coordenada[7] =' '; 
1E2C:  MOVLW  20
1E2E:  MOVWF  xA8
....................   
....................   index2 = 8; 
1E30:  MOVLW  08
1E32:  MOVLB  6
1E34:  MOVWF  xD9
....................   for(index=22;index<33;index++){ //Latitude 
1E36:  MOVLW  16
1E38:  MOVWF  xD8
1E3A:  MOVF   xD8,W
1E3C:  SUBLW  20
1E3E:  BNC   1E74
....................    coordenada[index2] = comando_recibido_UART[index]; 
1E40:  CLRF   03
1E42:  MOVF   xD9,W
1E44:  ADDLW  A1
1E46:  MOVWF  01
1E48:  MOVLW  01
1E4A:  ADDWFC 03,F
1E4C:  MOVFF  03,6DB
1E50:  CLRF   03
1E52:  MOVF   xD8,W
1E54:  ADDLW  52
1E56:  MOVWF  FE9
1E58:  MOVLW  00
1E5A:  ADDWFC 03,W
1E5C:  MOVWF  FEA
1E5E:  MOVFF  FEF,6DC
1E62:  MOVFF  6DB,FEA
1E66:  MOVFF  01,FE9
1E6A:  MOVFF  6DC,FEF
....................    index2++;    
1E6E:  INCF   xD9,F
1E70:  INCF   xD8,F
1E72:  BRA    1E3A
....................   } 
....................  
....................   for(index=11;index<22;index++){ //Longitude 
1E74:  MOVLW  0B
1E76:  MOVWF  xD8
1E78:  MOVF   xD8,W
1E7A:  SUBLW  15
1E7C:  BNC   1EB2
....................    coordenada[index2] = comando_recibido_UART[index]; 
1E7E:  CLRF   03
1E80:  MOVF   xD9,W
1E82:  ADDLW  A1
1E84:  MOVWF  01
1E86:  MOVLW  01
1E88:  ADDWFC 03,F
1E8A:  MOVFF  03,6DB
1E8E:  CLRF   03
1E90:  MOVF   xD8,W
1E92:  ADDLW  52
1E94:  MOVWF  FE9
1E96:  MOVLW  00
1E98:  ADDWFC 03,W
1E9A:  MOVWF  FEA
1E9C:  MOVFF  FEF,6DC
1EA0:  MOVFF  6DB,FEA
1EA4:  MOVFF  01,FE9
1EA8:  MOVFF  6DC,FEF
....................    index2++;    
1EAC:  INCF   xD9,F
1EAE:  INCF   xD8,F
1EB0:  BRA    1E78
....................   } 
....................    
....................   coordenada[index2++] =' '; 
1EB2:  MOVF   xD9,W
1EB4:  INCF   xD9,F
1EB6:  CLRF   03
1EB8:  ADDLW  A1
1EBA:  MOVWF  FE9
1EBC:  MOVLW  01
1EBE:  ADDWFC 03,W
1EC0:  MOVWF  FEA
1EC2:  MOVLW  20
1EC4:  MOVWF  FEF
....................   coordenada[index2++] ='R'; 
1EC6:  MOVF   xD9,W
1EC8:  INCF   xD9,F
1ECA:  CLRF   03
1ECC:  ADDLW  A1
1ECE:  MOVWF  FE9
1ED0:  MOVLW  01
1ED2:  ADDWFC 03,W
1ED4:  MOVWF  FEA
1ED6:  MOVLW  52
1ED8:  MOVWF  FEF
....................   coordenada[index2++] ='='; 
1EDA:  MOVF   xD9,W
1EDC:  INCF   xD9,F
1EDE:  CLRF   03
1EE0:  ADDLW  A1
1EE2:  MOVWF  FE9
1EE4:  MOVLW  01
1EE6:  ADDWFC 03,W
1EE8:  MOVWF  FEA
1EEA:  MOVLW  3D
1EEC:  MOVWF  FEF
....................  
....................   for(index=33;index<36;index++){ //Preciso 
1EEE:  MOVLW  21
1EF0:  MOVWF  xD8
1EF2:  MOVF   xD8,W
1EF4:  SUBLW  23
1EF6:  BNC   1F2C
....................    coordenada[index2] = comando_recibido_UART[index]; 
1EF8:  CLRF   03
1EFA:  MOVF   xD9,W
1EFC:  ADDLW  A1
1EFE:  MOVWF  01
1F00:  MOVLW  01
1F02:  ADDWFC 03,F
1F04:  MOVFF  03,6DB
1F08:  CLRF   03
1F0A:  MOVF   xD8,W
1F0C:  ADDLW  52
1F0E:  MOVWF  FE9
1F10:  MOVLW  00
1F12:  ADDWFC 03,W
1F14:  MOVWF  FEA
1F16:  MOVFF  FEF,6DC
1F1A:  MOVFF  6DB,FEA
1F1E:  MOVFF  01,FE9
1F22:  MOVFF  6DC,FEF
....................    index2++;    
1F26:  INCF   xD9,F
1F28:  INCF   xD8,F
1F2A:  BRA    1EF2
....................   } 
....................    
....................   coordenada[index2++] ='m'; 
1F2C:  MOVF   xD9,W
1F2E:  INCF   xD9,F
1F30:  CLRF   03
1F32:  ADDLW  A1
1F34:  MOVWF  FE9
1F36:  MOVLW  01
1F38:  ADDWFC 03,W
1F3A:  MOVWF  FEA
1F3C:  MOVLW  6D
1F3E:  MOVWF  FEF
....................   coordenada[index2] = 0; 
1F40:  CLRF   03
1F42:  MOVF   xD9,W
1F44:  ADDLW  A1
1F46:  MOVWF  FE9
1F48:  MOVLW  01
1F4A:  ADDWFC 03,W
1F4C:  MOVWF  FEA
1F4E:  CLRF   FEF
1F50:  MOVLB  0
1F52:  GOTO   2260 (RETURN)
....................  
.................... } 
....................  
....................  
.................... #ENDIF 
....................  
.................... #include "Memory.h" 
.................... #IFNDEF MEMORY_H 
.................... #DEFINE MEMORY_H 
....................  
.................... //*********************************** ENDERECOS EEPROM *******************************************  
....................  
.................... #define ADDR_tempo_entre_alertas              getenv("EEPROM_ADDRESS") + 0  //int32 
.................... #define ADDR_tempo_ultimo_alerta              getenv("EEPROM_ADDRESS") + 4  //int32 
.................... #define ADDR_corrente_limite                  getenv("EEPROM_ADDRESS") + 8  //int32 
.................... #define ADDR_zero_set                         getenv("EEPROM_ADDRESS") + 12 //int32 
.................... #define ADDR_qtd_numeros                      getenv("EEPROM_ADDRESS") + 16 //int8 
.................... #define ADDR_vector_numeros                   getenv("EEPROM_ADDRESS") + 17 //Vetor int 8 com 50 posicoes 
....................  
.................... //************************************************************************************************* 
....................  
.................... //************************************ DEAFULT EEPROM ********************************************* 
....................  
.................... #rom int32 ADDR_tempo_entre_alertas = {0} 
.................... #rom int32 ADDR_tempo_ultimo_alerta = {0}  
.................... #rom int32 ADDR_corrente_limite = {0}  
.................... #rom int32 ADDR_zero_set = {0}  
.................... #rom int8  ADDR_qtd_numeros = {0}  
.................... #rom int8  ADDR_vector_numeros = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} 
....................  
.................... //************************************************************************************************* 
....................  
....................  
.................... void read_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
.................... void write_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
....................  
.................... #include "Memory.c" 
.................... #ENDIF 
....................  
.................... #include "numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
.................... void obtem_numero(int8 pos_num, char *numero); 
....................  
.................... #include"numeros.c" 
.................... #ENDIF 
....................  
....................  
.................... // Declaração de Variáveis 
....................  
.................... int1 comando_disponivel_UART = FALSE; 
.................... int1 One_Second = FALSE; 
.................... int1 One_Minute = FALSE; 
.................... int16 Miliseconds = 0; 
.................... int16 seconds = 0; 
.................... char comando = 0; 
.................... int1 resposta_SIM = false; 
.................... int8 leitura_tensao_partida[400]; 
.................... int1 partida_iniciada = FALSE; 
.................... int1 aquisicao_tensao_partida = FALSE; 
.................... int1 veiculo_ligado = FALSE; 
.................... int16 index = 0; 
.................... unsigned int8 index_1 = 0; 
.................... unsigned int8 index_2 = 0; 
.................... int8 V1 = 255; 
.................... int8 V2 = 255; 
.................... int1 sel_ad = FALSE; 
.................... unsigned int16 leitura_corrente[100]; 
.................... unsigned int16 offset_current_ref[100]; 
.................... unsigned int8 leitura_tensao[100]; 
.................... unsigned int16 aux_leitura[100]; 
.................... float aux_offset_current_ref = 0; 
.................... float aux_corrente = 0; 
.................... float aux_tensao = 0; 
.................... float zero_set = 0; 
.................... float zero_set_aux = 0; 
.................... int32 corrente_limite = 3000; 
.................... int8 qtd_numeros=0; 
.................... int8 tempo_corrente_verif = 0; 
.................... int8 tempo_corrente_verif_low = 0;  
.................... int8 index_envio = 0; 
.................... int32 tempo_entre_alertas = 1; 
.................... int32 tempo_ultimo_alerta = 1; 
.................... int1 detect_high_current = false; 
.................... char numero[20]; 
.................... //Fim declaração de variáveis 
....................  
.................... #INT_RTCC 
.................... void Timer_0(){ 
....................  
....................   set_timer0(6);   
*
07A4:  CLRF   FD7
07A6:  MOVLW  06
07A8:  MOVWF  FD6
....................    
....................   if(partida_iniciada){ 
07AA:  MOVLB  1
07AC:  BTFSS  x82.4
07AE:  BRA    080A
....................      
....................     output_high(PIN_D0); 
07B0:  BSF    F8C.0
....................     if(index<400){  
07B2:  MOVLB  3
07B4:  MOVF   x5F,W
07B6:  SUBLW  01
07B8:  BNC   07F4
07BA:  BNZ   07C2
07BC:  MOVF   x5E,W
07BE:  SUBLW  8F
07C0:  BNC   07F4
....................          
....................       leitura_tensao_partida[index] = (read_adc()>>2); 
07C2:  MOVLW  CE
07C4:  ADDWF  x5E,W
07C6:  MOVWF  FE9
07C8:  MOVLW  01
07CA:  ADDWFC x5F,W
07CC:  MOVWF  FEA
07CE:  BSF    FC2.1
07D0:  BTFSC  FC2.1
07D2:  BRA    07D0
07D4:  MOVLB  7
07D6:  RRCF   FC4,W
07D8:  MOVWF  03
07DA:  RRCF   FC3,W
07DC:  MOVWF  02
07DE:  RRCF   03,F
07E0:  RRCF   02,F
07E2:  MOVLW  3F
07E4:  ANDWF  03,F
07E6:  MOVFF  02,FEF
....................       index++; 
07EA:  MOVLB  3
07EC:  INCF   x5E,F
07EE:  BTFSC  FD8.2
07F0:  INCF   x5F,F
....................     }  
07F2:  BRA    0806
....................     else{ 
....................       index = 0; 
07F4:  CLRF   x5F
07F6:  CLRF   x5E
....................       partida_iniciada = FALSE; 
07F8:  MOVLB  1
07FA:  BCF    x82.4
....................       aquisicao_tensao_partida = TRUE; 
07FC:  BSF    x82.5
....................       output_low(PIN_D0); 
07FE:  BCF    F8C.0
....................       enable_interrupts(INT_RDA); 
0800:  BSF    F9D.5
....................       enable_interrupts(INT_EXT); 
0802:  BSF    FF2.4
0804:  MOVLB  3
....................     } 
....................   } 
0806:  BRA    091A
0808:  MOVLB  1
....................   else{ 
....................     Miliseconds++; 
080A:  INCF   xC9,F
080C:  BTFSC  FD8.2
080E:  INCF   xCA,F
....................  
....................     if(Miliseconds % 5 == 0){ 
0810:  MOVFF  1CA,732
0814:  MOVFF  1C9,731
0818:  MOVLB  7
081A:  CLRF   x34
081C:  MOVLW  05
081E:  MOVWF  x33
0820:  MOVLB  0
0822:  BRA    075C
0824:  MOVFF  00,731
0828:  MOVLB  7
082A:  MOVFF  03,732
082E:  MOVF   x31,F
0830:  BNZ   08E4
0832:  MOVF   x32,F
0834:  BNZ   08E4
....................       sel_ad = !sel_ad; 
0836:  MOVLB  1
0838:  BTG    x82.7
....................     
....................       if(sel_ad){ 
083A:  BTFSS  x82.7
083C:  BRA    08A6
....................         leitura_corrente[index_1] = read_adc(); 
083E:  BCF    FD8.0
0840:  MOVLB  3
0842:  RLCF   x60,W
0844:  CLRF   03
0846:  ADDLW  64
0848:  MOVWF  FE9
084A:  MOVLW  03
084C:  ADDWFC 03,W
084E:  MOVWF  FEA
0850:  BSF    FC2.1
0852:  BTFSC  FC2.1
0854:  BRA    0852
0856:  MOVFF  FC3,FEF
085A:  MOVFF  FC4,FEC
....................         set_adc_channel(3); 
085E:  MOVLW  0C
0860:  MOVWF  01
0862:  MOVF   FC2,W
0864:  ANDLW  C3
0866:  IORWF  01,W
0868:  MOVWF  FC2
....................         delay_us(10); 
086A:  MOVLW  0C
086C:  MOVWF  00
086E:  DECFSZ 00,F
0870:  BRA    086E
0872:  BRA    0874
0874:  NOP   
....................         offset_current_ref[index_1] = read_adc(); 
0876:  BCF    FD8.0
0878:  RLCF   x60,W
087A:  CLRF   03
087C:  ADDLW  2C
087E:  MOVWF  FE9
0880:  MOVLW  04
0882:  ADDWFC 03,W
0884:  MOVWF  FEA
0886:  BSF    FC2.1
0888:  BTFSC  FC2.1
088A:  BRA    0888
088C:  MOVFF  FC3,FEF
0890:  MOVFF  FC4,FEC
....................         set_adc_channel(1); 
0894:  MOVLW  04
0896:  MOVWF  01
0898:  MOVF   FC2,W
089A:  ANDLW  C3
089C:  IORWF  01,W
089E:  MOVWF  FC2
....................         index_1++; 
08A0:  INCF   x60,F
....................       } 
08A2:  BRA    08E2
08A4:  MOVLB  1
....................       else{ 
....................         leitura_tensao[index_2] = (read_adc()>>2); 
08A6:  CLRF   03
08A8:  MOVLB  3
08AA:  MOVF   x61,W
08AC:  ADDLW  F4
08AE:  MOVWF  FE9
08B0:  MOVLW  04
08B2:  ADDWFC 03,W
08B4:  MOVWF  FEA
08B6:  BSF    FC2.1
08B8:  BTFSC  FC2.1
08BA:  BRA    08B8
08BC:  MOVLB  7
08BE:  RRCF   FC4,W
08C0:  MOVWF  03
08C2:  RRCF   FC3,W
08C4:  MOVWF  02
08C6:  RRCF   03,F
08C8:  RRCF   02,F
08CA:  MOVLW  3F
08CC:  ANDWF  03,F
08CE:  MOVFF  02,FEF
....................         set_adc_channel(2); 
08D2:  MOVLW  08
08D4:  MOVWF  01
08D6:  MOVF   FC2,W
08D8:  ANDLW  C3
08DA:  IORWF  01,W
08DC:  MOVWF  FC2
....................         index_2++; 
08DE:  MOVLB  3
08E0:  INCF   x61,F
08E2:  MOVLB  7
....................       }  
....................     } 
....................  
....................     if(Miliseconds == 1000){ 
08E4:  MOVLB  1
08E6:  MOVF   xC9,W
08E8:  SUBLW  E8
08EA:  BNZ   0918
08EC:  MOVF   xCA,W
08EE:  SUBLW  03
08F0:  BNZ   0918
....................       seconds++; 
08F2:  INCF   xCB,F
08F4:  BTFSC  FD8.2
08F6:  INCF   xCC,F
....................       Miliseconds = 0; 
08F8:  CLRF   xCA
08FA:  CLRF   xC9
....................       One_Second = TRUE; 
08FC:  BSF    x82.2
....................       index_1 = 0; 
08FE:  MOVLB  3
0900:  CLRF   x60
....................       index_2 = 0; 
0902:  CLRF   x61
....................       output_toggle(PIN_A0); 
0904:  BTG    F89.0
....................       if(seconds==60){ 
0906:  MOVLB  1
0908:  MOVF   xCB,W
090A:  SUBLW  3C
090C:  BNZ   0918
090E:  MOVF   xCC,F
0910:  BNZ   0918
....................         seconds = 0; 
0912:  CLRF   xCC
0914:  CLRF   xCB
....................         One_Minute = TRUE; 
0916:  BSF    x82.3
0918:  MOVLB  3
....................       } 
....................     } 
....................   } 
....................   return; 
.................... } 
....................  
091A:  BCF    FF2.2
091C:  MOVLB  0
091E:  GOTO   006C
.................... #INT_EXT 
.................... void Interrupcao_Externa(){ 
....................    
....................   set_adc_channel(1); 
0922:  MOVLW  04
0924:  MOVWF  01
0926:  MOVF   FC2,W
0928:  ANDLW  C3
092A:  IORWF  01,W
092C:  MOVWF  FC2
....................   disable_interrupts(INT_RDA); 
092E:  BCF    F9D.5
....................   disable_interrupts(INT_EXT); 
0930:  BCF    FF2.4
....................   partida_iniciada = TRUE; 
0932:  MOVLB  1
0934:  BSF    x82.4
....................   veiculo_ligado = TRUE; 
0936:  BSF    x82.6
....................   aquisicao_tensao_partida = FALSE; 
0938:  BCF    x82.5
....................   index = 0; 
093A:  MOVLB  3
093C:  CLRF   x5F
093E:  CLRF   x5E
....................  
....................   return; 
0940:  BCF    FF2.1
0942:  MOVLB  0
0944:  GOTO   006C
.................... } 
....................  
.................... void main() 
*
331C:  CLRF   FF8
331E:  BCF    FD0.7
3320:  BSF    07.7
3322:  CLRF   16
3324:  BSF    FB8.3
3326:  MOVLW  22
3328:  MOVWF  FAF
332A:  MOVLW  00
332C:  MOVWF  FB0
332E:  MOVLW  A6
3330:  MOVWF  FAC
3332:  MOVLW  90
3334:  MOVWF  FAB
3336:  BCF    F93.2
3338:  BSF    F8A.2
333A:  MOVLB  1
333C:  CLRF   x7F
333E:  CLRF   x7E
3340:  MOVLW  86
3342:  MOVWF  x81
3344:  MOVLW  A0
3346:  MOVWF  x80
3348:  CLRF   x9C
334A:  CLRF   x9B
334C:  CLRF   xA0
334E:  MOVLW  6A
3350:  MOVWF  x9F
3352:  MOVLW  CF
3354:  MOVWF  x9E
3356:  MOVLW  C0
3358:  MOVWF  x9D
335A:  BCF    x82.0
335C:  BCF    x82.2
335E:  BCF    x82.3
3360:  CLRF   xCA
3362:  CLRF   xC9
3364:  CLRF   xCC
3366:  CLRF   xCB
3368:  CLRF   xCD
336A:  BCF    x82.1
336C:  BCF    x82.4
336E:  BCF    x82.5
3370:  BCF    x82.6
3372:  MOVLB  3
3374:  CLRF   x5F
3376:  CLRF   x5E
3378:  CLRF   x60
337A:  CLRF   x61
337C:  SETF   x62
337E:  SETF   x63
3380:  MOVLB  1
3382:  BCF    x82.7
3384:  MOVLB  6
3386:  CLRF   x23
3388:  CLRF   x22
338A:  CLRF   x21
338C:  CLRF   x20
338E:  MOVLB  1
3390:  CLRF   x8E
3392:  CLRF   x8D
3394:  CLRF   x8C
3396:  CLRF   x8B
3398:  CLRF   x92
339A:  CLRF   x91
339C:  CLRF   x90
339E:  CLRF   x8F
33A0:  CLRF   x96
33A2:  CLRF   x95
33A4:  CLRF   x94
33A6:  CLRF   x93
33A8:  CLRF   x9A
33AA:  CLRF   x99
33AC:  CLRF   x98
33AE:  CLRF   x97
33B0:  CLRF   x86
33B2:  CLRF   x85
33B4:  MOVLW  0B
33B6:  MOVWF  x84
33B8:  MOVLW  B8
33BA:  MOVWF  x83
33BC:  CLRF   4F
33BE:  MOVLB  6
33C0:  CLRF   x24
33C2:  CLRF   x25
33C4:  CLRF   x26
33C6:  MOVLB  1
33C8:  CLRF   x8A
33CA:  CLRF   x89
33CC:  CLRF   x88
33CE:  MOVLW  01
33D0:  MOVWF  x87
33D2:  MOVLB  6
33D4:  CLRF   x2A
33D6:  CLRF   x29
33D8:  CLRF   x28
33DA:  MOVWF  x27
33DC:  BCF    x2B.0
33DE:  MOVF   FC1,W
33E0:  ANDLW  C0
33E2:  IORLW  0F
33E4:  MOVWF  FC1
33E6:  MOVLW  07
33E8:  MOVWF  FB4
33EA:  CLRF   17
33EC:  CLRF   18
.................... { 
....................   set_tris_a (0b00001110);                                                     //Ra7-Ra6-Ra5-Ra4-Ra3-Ra2-Ra1-Ra0 
33EE:  MOVLW  0E
33F0:  MOVWF  F92
....................   set_tris_b (0b00001001);                                                     //Rb7-Rb6-Rb5-Rb4-Rb3-Rb2-Rb1-Rb0 
33F2:  MOVLW  09
33F4:  MOVWF  F93
....................   set_tris_c (0b10000000);                                                     //Rc7-Rc6-Rc5-Rc4-Rc3-Rc2-Rc1-Rc0 
33F6:  MOVLW  80
33F8:  MOVWF  F94
....................   set_tris_d (0b00000000);  
33FA:  MOVLW  00
33FC:  MOVWF  F95
....................    
....................   setup_adc_ports(AN0_TO_AN3); 
33FE:  MOVF   FC1,W
3400:  ANDLW  C0
3402:  IORLW  0B
3404:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_2); 
3406:  MOVF   FC0,W
3408:  ANDLW  C0
340A:  MOVWF  FC0
340C:  BSF    FC0.7
340E:  BSF    FC2.0
....................   set_adc_channel(1); 
3410:  MOVLW  04
3412:  MOVWF  01
3414:  MOVF   FC2,W
3416:  ANDLW  C3
3418:  IORWF  01,W
341A:  MOVWF  FC2
....................   setup_wdt(WDT_OFF); 
341C:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 | RTCC_8_BIT); 
341E:  MOVLW  C3
3420:  MOVWF  FD5
....................   set_timer0(6); 
3422:  CLRF   FD7
3424:  MOVLW  06
3426:  MOVWF  FD6
....................   ext_int_edge(H_TO_L); 
3428:  BCF    FF1.6
....................  
....................   output_low(PIN_D0); 
342A:  BCF    F8C.0
....................   enable_interrupts(INT_RTCC); 
342C:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
342E:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
3430:  MOVLW  C0
3432:  IORWF  FF2,F
....................  
....................   le_EEPROM();  
3434:  MOVLB  0
3436:  GOTO   0A40
....................   output_low(PIN_D2); 
343A:  BCF    F8C.2
....................   delay_ms(2000); 
343C:  MOVLW  08
343E:  MOVLB  6
3440:  MOVWF  x5A
3442:  MOVLW  FA
3444:  MOVLB  7
3446:  MOVWF  x26
3448:  MOVLB  0
344A:  CALL   0AF2
344E:  MOVLB  6
3450:  DECFSZ x5A,F
3452:  BRA    3442
....................   output_high(PIN_D2); 
3454:  BSF    F8C.2
....................   delay_ms(15000); 
3456:  MOVLW  3C
3458:  MOVWF  x5A
345A:  MOVLW  FA
345C:  MOVLB  7
345E:  MOVWF  x26
3460:  MOVLB  0
3462:  CALL   0AF2
3466:  MOVLB  6
3468:  DECFSZ x5A,F
346A:  BRA    345A
....................   Send_SMS("031995822739","INICIANDO..."); 
346C:  MOVLW  06
346E:  MOVWF  FEA
3470:  MOVLW  40
3472:  MOVWF  FE9
3474:  MOVFF  FF2,65A
3478:  BCF    FF2.7
347A:  MOVLW  0D
347C:  MOVWF  01
347E:  CLRF   FF7
3480:  MOVLW  00
3482:  MOVLB  0
3484:  CALL   04F4
3488:  TBLRD*-
348A:  TBLRD*+
348C:  MOVFF  FF5,FEE
3490:  DECFSZ 01,F
3492:  BRA    348A
3494:  MOVLB  6
3496:  BTFSC  x5A.7
3498:  BSF    FF2.7
349A:  MOVLW  06
349C:  MOVWF  FEA
349E:  MOVLW  4D
34A0:  MOVWF  FE9
34A2:  MOVFF  FF2,65C
34A6:  BCF    FF2.7
34A8:  MOVLW  0D
34AA:  MOVWF  01
34AC:  CLRF   FF7
34AE:  MOVLW  00
34B0:  MOVLB  0
34B2:  CALL   051C
34B6:  TBLRD*-
34B8:  TBLRD*+
34BA:  MOVFF  FF5,FEE
34BE:  DECFSZ 01,F
34C0:  BRA    34B8
34C2:  MOVLB  6
34C4:  BTFSC  x5C.7
34C6:  BSF    FF2.7
34C8:  MOVLW  06
34CA:  MOVWF  xD9
34CC:  MOVLW  40
34CE:  MOVWF  xD8
34D0:  MOVLW  06
34D2:  MOVWF  xDB
34D4:  MOVLW  4D
34D6:  MOVWF  xDA
34D8:  MOVLB  0
34DA:  CALL   0D3C
....................  
....................   enable_interrupts(INT_EXT_H2L); 
34DE:  BSF    FF2.4
34E0:  BCF    FF1.6
....................  
....................   while(TRUE){ 
....................  
....................     if(One_Second){ 
34E2:  MOVLB  1
34E4:  BTFSS  x82.2
34E6:  BRA    34F0
....................  
....................       One_Second = FALSE; 
34E8:  BCF    x82.2
....................       Executar_Cada_Segundo(); 
34EA:  MOVLB  0
34EC:  BRA    2DFE
34EE:  MOVLB  1
....................  
....................     } 
....................  
....................     if(One_Minute){ 
34F0:  BTFSS  x82.3
34F2:  BRA    34FC
....................  
....................       One_Minute = FALSE; 
34F4:  BCF    x82.3
....................       Executar_Cada_Minuto(); 
34F6:  MOVLB  0
34F8:  BRA    312C
34FA:  MOVLB  1
....................  
....................     } 
34FC:  BRA    34E4
....................  
....................   } 
....................  
.................... } 
....................  
34FE:  SLEEP 
.................... void le_EEPROM(void){ 
....................  
....................   read_config(ADDR_tempo_entre_alertas,&tempo_entre_alertas,4); 
*
0A40:  MOVLB  6
0A42:  CLRF   x5D
0A44:  MOVLW  F0
0A46:  MOVWF  x5C
0A48:  CLRF   x5B
0A4A:  CLRF   x5A
0A4C:  MOVLW  01
0A4E:  MOVWF  x5F
0A50:  MOVLW  87
0A52:  MOVWF  x5E
0A54:  MOVLW  04
0A56:  MOVWF  x60
0A58:  MOVLB  0
0A5A:  RCALL  09EA
....................   read_config(ADDR_tempo_ultimo_alerta,&tempo_ultimo_alerta,4); 
0A5C:  MOVLB  6
0A5E:  CLRF   x5D
0A60:  MOVLW  F0
0A62:  MOVWF  x5C
0A64:  CLRF   x5B
0A66:  MOVLW  04
0A68:  MOVWF  x5A
0A6A:  MOVLW  06
0A6C:  MOVWF  x5F
0A6E:  MOVLW  27
0A70:  MOVWF  x5E
0A72:  MOVLW  04
0A74:  MOVWF  x60
0A76:  MOVLB  0
0A78:  RCALL  09EA
....................   read_config(ADDR_corrente_limite,&corrente_limite,4); 
0A7A:  MOVLB  6
0A7C:  CLRF   x5D
0A7E:  MOVLW  F0
0A80:  MOVWF  x5C
0A82:  CLRF   x5B
0A84:  MOVLW  08
0A86:  MOVWF  x5A
0A88:  MOVLW  01
0A8A:  MOVWF  x5F
0A8C:  MOVLW  83
0A8E:  MOVWF  x5E
0A90:  MOVLW  04
0A92:  MOVWF  x60
0A94:  MOVLB  0
0A96:  RCALL  09EA
....................   read_config(ADDR_zero_set,&zero_set,4); 
0A98:  MOVLB  6
0A9A:  CLRF   x5D
0A9C:  MOVLW  F0
0A9E:  MOVWF  x5C
0AA0:  CLRF   x5B
0AA2:  MOVLW  0C
0AA4:  MOVWF  x5A
0AA6:  MOVLW  01
0AA8:  MOVWF  x5F
0AAA:  MOVLW  93
0AAC:  MOVWF  x5E
0AAE:  MOVLW  04
0AB0:  MOVWF  x60
0AB2:  MOVLB  0
0AB4:  RCALL  09EA
....................   read_config(ADDR_qtd_numeros,&qtd_numeros,1); 
0AB6:  MOVLB  6
0AB8:  CLRF   x5D
0ABA:  MOVLW  F0
0ABC:  MOVWF  x5C
0ABE:  CLRF   x5B
0AC0:  MOVLW  10
0AC2:  MOVWF  x5A
0AC4:  CLRF   x5F
0AC6:  MOVLW  4F
0AC8:  MOVWF  x5E
0ACA:  MOVLW  01
0ACC:  MOVWF  x60
0ACE:  MOVLB  0
0AD0:  RCALL  09EA
....................   read_config(ADDR_vector_numeros,&numeros,50); 
0AD2:  MOVLB  6
0AD4:  CLRF   x5D
0AD6:  MOVLW  F0
0AD8:  MOVWF  x5C
0ADA:  CLRF   x5B
0ADC:  MOVLW  11
0ADE:  MOVWF  x5A
0AE0:  CLRF   x5F
0AE2:  MOVLW  1D
0AE4:  MOVWF  x5E
0AE6:  MOVLW  32
0AE8:  MOVWF  x60
0AEA:  MOVLB  0
0AEC:  RCALL  09EA
0AEE:  GOTO   343A (RETURN)
....................  
.................... } 
....................  
.................... void Executar_Cada_Segundo(){ 
....................    
....................   Calcula_SOC(); 
*
2DFE:  GOTO   16B8
....................   if(aux_corrente > corrente_limite){ 
2E02:  MOVFF  186,66E
2E06:  MOVFF  185,66D
2E0A:  MOVFF  184,66C
2E0E:  MOVFF  183,66B
2E12:  GOTO   19F8
2E16:  MOVFF  03,6A1
2E1A:  MOVFF  02,6A0
2E1E:  MOVFF  01,69F
2E22:  MOVFF  00,69E
2E26:  MOVFF  18E,6A5
2E2A:  MOVFF  18D,6A4
2E2E:  MOVFF  18C,6A3
2E32:  MOVFF  18B,6A2
2E36:  CALL   1348
2E3A:  BNC   2E6C
....................     tempo_corrente_verif++; 
2E3C:  MOVLB  6
2E3E:  INCF   x24,F
....................     if(tempo_corrente_verif > 30){ 
2E40:  MOVF   x24,W
2E42:  SUBLW  1E
2E44:  BC    2E68
....................       tempo_corrente_verif = 0; 
2E46:  CLRF   x24
....................       tempo_corrente_verif_low = 0; 
2E48:  CLRF   x25
....................       detect_high_current = true; 
2E4A:  BSF    x2B.0
....................       disable_interrupts(GLOBAL); 
2E4C:  BCF    FF2.6
2E4E:  BCF    FF2.7
2E50:  BTFSC  FF2.7
2E52:  BRA    2E4E
....................       fprintf(MONITOR_SERIAL,"Detect High Current\r\n"); 
2E54:  MOVLW  48
2E56:  MOVWF  FF6
2E58:  MOVLW  09
2E5A:  MOVWF  FF7
2E5C:  MOVLB  0
2E5E:  CALL   1A32
....................       enable_interrupts(GLOBAL); 
2E62:  MOVLW  C0
2E64:  IORWF  FF2,F
2E66:  MOVLB  6
....................     } 
....................   } 
2E68:  BRA    2E98
2E6A:  MOVLB  0
....................   else{ 
....................     tempo_corrente_verif_low++; 
2E6C:  MOVLB  6
2E6E:  INCF   x25,F
....................     if(tempo_corrente_verif_low > 30){ 
2E70:  MOVF   x25,W
2E72:  SUBLW  1E
2E74:  BC    2E98
....................       tempo_corrente_verif_low = 0; 
2E76:  CLRF   x25
....................       tempo_corrente_verif = 0; 
2E78:  CLRF   x24
....................       detect_high_current = false; 
2E7A:  BCF    x2B.0
....................       disable_interrupts(GLOBAL); 
2E7C:  BCF    FF2.6
2E7E:  BCF    FF2.7
2E80:  BTFSC  FF2.7
2E82:  BRA    2E7E
....................       fprintf(MONITOR_SERIAL,"Detect Low Current\r\n"); 
2E84:  MOVLW  5E
2E86:  MOVWF  FF6
2E88:  MOVLW  09
2E8A:  MOVWF  FF7
2E8C:  MOVLB  0
2E8E:  CALL   1A32
....................       enable_interrupts(GLOBAL); 
2E92:  MOVLW  C0
2E94:  IORWF  FF2,F
2E96:  MOVLB  6
....................     } 
....................      
....................   } 
....................  
....................   if(aquisicao_tensao_partida){ 
2E98:  MOVLB  1
2E9A:  BTFSS  x82.5
2E9C:  BRA    2EA8
....................  
....................     aquisicao_tensao_partida = FALSE; 
2E9E:  BCF    x82.5
....................     Obtem_SOH(); 
2EA0:  MOVLB  0
2EA2:  GOTO   1A52
2EA6:  MOVLB  1
....................  
....................   } 
....................   if(comando_disponivel_UART){ 
2EA8:  BTFSS  x82.0
2EAA:  BRA    2F54
....................    
....................     disable_interrupts(GLOBAL); 
2EAC:  BCF    FF2.6
2EAE:  BCF    FF2.7
2EB0:  BTFSC  FF2.7
2EB2:  BRA    2EAE
....................     comando = Get_Comando(); 
2EB4:  MOVLB  0
2EB6:  CALL   1A9A
2EBA:  MOVFF  01,1CD
....................      
....................     if(comando != 0){ 
2EBE:  MOVLB  1
2EC0:  MOVF   xCD,F
2EC2:  BZ    2ED0
....................  
....................       Executa_Comando(comando); 
2EC4:  MOVFF  1CD,66B
2EC8:  MOVLB  0
2ECA:  CALL   25E8
2ECE:  MOVLB  1
....................        
....................     } 
....................     if(resposta_SIM == 1){ 
2ED0:  BTFSS  x82.1
2ED2:  BRA    2F4C
....................       disable_interrupts(GLOBAL); 
2ED4:  BCF    FF2.6
2ED6:  BCF    FF2.7
2ED8:  BTFSC  FF2.7
2EDA:  BRA    2ED6
....................       resposta_SIM = 0; 
2EDC:  BCF    x82.1
....................       comando = Get_Comando(); 
2EDE:  MOVLB  0
2EE0:  CALL   1A9A
2EE4:  MOVFF  01,1CD
....................       Executa_Comando(comando); 
2EE8:  MOVFF  1CD,66B
2EEC:  CALL   25E8
....................       delay_ms(100); 
2EF0:  MOVLW  64
2EF2:  MOVLB  7
2EF4:  MOVWF  x26
2EF6:  MOVLB  0
2EF8:  CALL   0AF2
....................       envia_SIM800L("AT+CMGD=1,1\r\n", "OK"); 
2EFC:  MOVLW  06
2EFE:  MOVWF  FEA
2F00:  MOVLW  5A
2F02:  MOVWF  FE9
2F04:  MOVFF  FF2,66B
2F08:  BCF    FF2.7
2F0A:  MOVLW  0E
2F0C:  MOVWF  01
2F0E:  CLRF   FF7
2F10:  MOVLW  00
2F12:  CALL   0544
2F16:  TBLRD*-
2F18:  TBLRD*+
2F1A:  MOVFF  FF5,FEE
2F1E:  DECFSZ 01,F
2F20:  BRA    2F18
2F22:  MOVLB  6
2F24:  BTFSC  x6B.7
2F26:  BSF    FF2.7
2F28:  MOVLW  4F
2F2A:  MOVWF  x68
2F2C:  MOVLW  4B
2F2E:  MOVWF  x69
2F30:  CLRF   x6A
2F32:  MOVLW  06
2F34:  MOVLB  7
2F36:  MOVWF  x1C
2F38:  MOVLW  5A
2F3A:  MOVWF  x1B
2F3C:  MOVLW  06
2F3E:  MOVWF  x1E
2F40:  MOVLW  68
2F42:  MOVWF  x1D
2F44:  MOVLB  0
2F46:  CALL   0C4C
2F4A:  MOVLB  1
....................     } 
....................     comando = 0; 
2F4C:  CLRF   xCD
....................     clear_command(); 
2F4E:  MOVLB  0
2F50:  BRA    2DBC
2F52:  MOVLB  1
....................   } 
....................    
....................   return; 
2F54:  MOVLB  0
2F56:  GOTO   34EE (RETURN)
.................... } 
....................  
.................... void Executar_Cada_Minuto(){ 
....................    
....................   index_envio = 0; 
*
312C:  MOVLB  6
312E:  CLRF   x26
....................   if(detect_high_current){ 
3130:  BTFSS  x2B.0
3132:  BRA    3316
....................      
....................     if((qtd_numeros>0 && qtd_numeros<4) && tempo_entre_alertas>0){ 
3134:  MOVF   4F,F
3136:  BTFSC  FD8.2
3138:  BRA    3316
313A:  MOVF   4F,W
313C:  SUBLW  03
313E:  BTFSS  FD8.0
3140:  BRA    3316
3142:  MOVLB  1
3144:  MOVF   x87,F
3146:  BNZ   315A
3148:  MOVF   x88,F
314A:  BNZ   315A
314C:  MOVF   x89,F
314E:  BNZ   315A
3150:  MOVF   x8A,F
3152:  BTFSS  FD8.2
3154:  BRA    315A
3156:  MOVLB  6
3158:  BRA    3316
....................       tempo_ultimo_alerta++; 
315A:  MOVLW  01
315C:  MOVLB  6
315E:  ADDWF  x27,F
3160:  BTFSC  FD8.0
3162:  INCF   x28,F
3164:  BTFSC  FD8.2
3166:  INCF   x29,F
3168:  BTFSC  FD8.2
316A:  INCF   x2A,F
....................       disable_interrupts(GLOBAL); 
316C:  BCF    FF2.6
316E:  BCF    FF2.7
3170:  BTFSC  FF2.7
3172:  BRA    316E
....................       fprintf(MONITOR_SERIAL,"Tempo Entre Alertas %Lu , Tempo Ultimoi Alerta %Lu \r\n",tempo_entre_alertas,tempo_ultimo_alerta); 
3174:  MOVLW  74
3176:  MOVWF  FF6
3178:  MOVLW  09
317A:  MOVWF  FF7
317C:  MOVLW  14
317E:  MOVWF  x9B
3180:  MOVLB  0
3182:  RCALL  2F5A
3184:  MOVLW  41
3186:  MOVWF  FE9
3188:  MOVFF  18A,69D
318C:  MOVFF  189,69C
3190:  MOVFF  188,69B
3194:  MOVFF  187,69A
3198:  RCALL  2F84
319A:  MOVLW  8B
319C:  MOVWF  FF6
319E:  MOVLW  09
31A0:  MOVWF  FF7
31A2:  MOVLW  18
31A4:  MOVLB  6
31A6:  MOVWF  x9B
31A8:  MOVLB  0
31AA:  RCALL  2F5A
31AC:  MOVLW  41
31AE:  MOVWF  FE9
31B0:  MOVFF  62A,69D
31B4:  MOVFF  629,69C
31B8:  MOVFF  628,69B
31BC:  MOVFF  627,69A
31C0:  RCALL  2F84
31C2:  MOVLW  A6
31C4:  MOVWF  FF6
31C6:  MOVLW  09
31C8:  MOVWF  FF7
31CA:  MOVLW  03
31CC:  MOVLB  6
31CE:  MOVWF  x9B
31D0:  MOVLB  0
31D2:  RCALL  2F5A
....................       enable_interrupts(GLOBAL); 
31D4:  MOVLW  C0
31D6:  IORWF  FF2,F
....................       disable_interrupts(INT_EXT);  
31D8:  BCF    FF2.4
....................  
....................       if(tempo_ultimo_alerta >= tempo_entre_alertas){    
31DA:  MOVLB  1
31DC:  MOVF   x8A,W
31DE:  MOVLB  6
31E0:  SUBWF  x2A,W
31E2:  BTFSS  FD8.0
31E4:  BRA    3314
31E6:  BNZ   3210
31E8:  MOVLB  1
31EA:  MOVF   x89,W
31EC:  MOVLB  6
31EE:  SUBWF  x29,W
31F0:  BTFSS  FD8.0
31F2:  BRA    3314
31F4:  BNZ   3210
31F6:  MOVLB  1
31F8:  MOVF   x88,W
31FA:  MOVLB  6
31FC:  SUBWF  x28,W
31FE:  BTFSS  FD8.0
3200:  BRA    3314
3202:  BNZ   3210
3204:  MOVLB  1
3206:  MOVF   x87,W
3208:  MOVLB  6
320A:  SUBWF  x27,W
320C:  BTFSS  FD8.0
320E:  BRA    3314
....................         tempo_ultimo_alerta = 0; 
3210:  CLRF   x2A
3212:  CLRF   x29
3214:  CLRF   x28
3216:  CLRF   x27
....................         for(index_envio = 0; index_envio < qtd_numeros; index_envio++){ 
3218:  CLRF   x26
321A:  MOVF   4F,W
321C:  SUBWF  x26,W
321E:  BTFSC  FD8.0
3220:  BRA    3314
....................           memset (numero, 0x00, sizeof(numero)); 
3222:  MOVLW  06
3224:  MOVWF  FEA
3226:  MOVLW  2C
3228:  MOVWF  FE9
322A:  CLRF   00
322C:  CLRF   02
322E:  MOVLW  14
3230:  MOVWF  01
3232:  MOVLB  0
3234:  CALL   1DC4
....................           obtem_numero(index_envio,numero); 
3238:  MOVFF  626,69A
323C:  MOVLW  06
323E:  MOVLB  6
3240:  MOVWF  x9C
3242:  MOVLW  2C
3244:  MOVWF  x9B
3246:  MOVLB  0
3248:  BRA    3048
....................           disable_interrupts(GLOBAL); 
324A:  BCF    FF2.6
324C:  BCF    FF2.7
324E:  BTFSC  FF2.7
3250:  BRA    324C
....................           fprintf(MONITOR_SERIAL,"Send SMS Numero (%u/%u): %s\r\n",index_envio+1,qtd_numeros,numero); 
3252:  MOVLW  01
3254:  MOVLB  6
3256:  ADDWF  x26,W
3258:  MOVWF  x9A
325A:  MOVLW  AA
325C:  MOVWF  FF6
325E:  MOVLW  09
3260:  MOVWF  FF7
3262:  MOVLW  11
3264:  MOVWF  x9B
3266:  MOVLB  0
3268:  RCALL  2F5A
326A:  MOVFF  69A,69B
326E:  MOVLW  1B
3270:  MOVLB  6
3272:  MOVWF  x9C
3274:  MOVLB  0
3276:  RCALL  30A6
3278:  MOVLW  2F
327A:  MOVLB  6
327C:  MOVWF  xA6
327E:  MOVLB  0
3280:  CALL   164E
3284:  MOVFF  4F,69B
3288:  MOVLW  1B
328A:  MOVLB  6
328C:  MOVWF  x9C
328E:  MOVLB  0
3290:  RCALL  30A6
3292:  MOVLW  C0
3294:  MOVWF  FF6
3296:  MOVLW  09
3298:  MOVWF  FF7
329A:  MOVLW  03
329C:  MOVLB  6
329E:  MOVWF  x9B
32A0:  MOVLB  0
32A2:  RCALL  2F5A
32A4:  MOVLW  06
32A6:  MOVWF  FEA
32A8:  MOVLW  2C
32AA:  MOVWF  FE9
32AC:  CALL   1694
32B0:  MOVLW  0D
32B2:  MOVLB  6
32B4:  MOVWF  xA6
32B6:  MOVLB  0
32B8:  CALL   164E
32BC:  MOVLW  0A
32BE:  MOVLB  6
32C0:  MOVWF  xA6
32C2:  MOVLB  0
32C4:  CALL   164E
....................           enable_interrupts(GLOBAL); 
32C8:  MOVLW  C0
32CA:  IORWF  FF2,F
....................           Send_SMS(numero,"!!!!ALERTA: Bateria em descarga rapida VERIFIQUE SEU VEICULO!!!"); 
32CC:  MOVLW  06
32CE:  MOVWF  FEA
32D0:  MOVLW  5A
32D2:  MOVWF  FE9
32D4:  MOVFF  FF2,69A
32D8:  BCF    FF2.7
32DA:  MOVLW  40
32DC:  MOVWF  01
32DE:  CLRF   FF7
32E0:  MOVLW  00
32E2:  CALL   056C
32E6:  TBLRD*-
32E8:  TBLRD*+
32EA:  MOVFF  FF5,FEE
32EE:  DECFSZ 01,F
32F0:  BRA    32E8
32F2:  MOVLB  6
32F4:  BTFSC  x9A.7
32F6:  BSF    FF2.7
32F8:  MOVLW  06
32FA:  MOVWF  xD9
32FC:  MOVLW  2C
32FE:  MOVWF  xD8
3300:  MOVLW  06
3302:  MOVWF  xDB
3304:  MOVLW  5A
3306:  MOVWF  xDA
3308:  MOVLB  0
330A:  CALL   0D3C
330E:  MOVLB  6
3310:  INCF   x26,F
3312:  BRA    321A
....................    
....................         } 
....................       } 
....................       enable_interrupts(INT_EXT); 
3314:  BSF    FF2.4
....................     } 
....................        
....................   }   
....................   return; 
3316:  MOVLB  0
3318:  GOTO   34FA (RETURN)
.................... } 
....................  
.................... void Obtem_SOH(){ 
....................   
....................   V1 = 255; 
*
1A52:  MOVLB  3
1A54:  SETF   x62
....................   V2 = 255; 
1A56:  SETF   x63
....................   index = 0; 
1A58:  CLRF   x5F
1A5A:  CLRF   x5E
....................  
....................   for(index=0;index<15;index++){ 
1A5C:  CLRF   x5F
1A5E:  CLRF   x5E
1A60:  MOVF   x5F,F
1A62:  BNZ   1A94
1A64:  MOVF   x5E,W
1A66:  SUBLW  0E
1A68:  BNC   1A94
....................      
....................     if(leitura_tensao_partida[index]<V1) 
1A6A:  MOVLW  CE
1A6C:  ADDWF  x5E,W
1A6E:  MOVWF  FE9
1A70:  MOVLW  01
1A72:  ADDWFC x5F,W
1A74:  MOVWF  FEA
1A76:  MOVF   x62,W
1A78:  SUBWF  FEF,W
1A7A:  BC    1A8C
....................       V1 = leitura_tensao[index]; 
1A7C:  MOVLW  F4
1A7E:  ADDWF  x5E,W
1A80:  MOVWF  FE9
1A82:  MOVLW  04
1A84:  ADDWFC x5F,W
1A86:  MOVWF  FEA
1A88:  MOVFF  FEF,362
1A8C:  INCF   x5E,F
1A8E:  BTFSC  FD8.2
1A90:  INCF   x5F,F
1A92:  BRA    1A60
....................     
....................   } 
....................    
....................  
....................   return; 
1A94:  MOVLB  0
1A96:  GOTO   2EA6 (RETURN)
.................... } 
....................  
.................... void Calcula_SOC(){ 
*
16B8:  MOVLB  6
16BA:  CLRF   x6B
....................    
....................   int8 i=0; 
....................   char exibe[50]; 
....................  
....................   for(i=0; i<100;i++) 
16BC:  CLRF   x6B
16BE:  MOVF   x6B,W
16C0:  SUBLW  63
16C2:  BNC   170E
....................     aux_leitura[i] = leitura_corrente[i]; 
16C4:  BCF    FD8.0
16C6:  RLCF   x6B,W
16C8:  CLRF   03
16CA:  ADDLW  58
16CC:  MOVWF  01
16CE:  MOVLW  05
16D0:  ADDWFC 03,F
16D2:  MOVFF  01,69E
16D6:  MOVFF  03,69F
16DA:  BCF    FD8.0
16DC:  RLCF   x6B,W
16DE:  CLRF   03
16E0:  ADDLW  64
16E2:  MOVWF  FE9
16E4:  MOVLW  03
16E6:  ADDWFC 03,W
16E8:  MOVWF  FEA
16EA:  MOVFF  FEC,03
16EE:  MOVF   FED,F
16F0:  MOVFF  FEF,6A0
16F4:  MOVFF  03,6A1
16F8:  MOVFF  69F,FEA
16FC:  MOVFF  01,FE9
1700:  MOVFF  03,FEC
1704:  MOVF   FED,F
1706:  MOVFF  6A0,FEF
170A:  INCF   x6B,F
170C:  BRA    16BE
....................   aux_corrente = obtem_mediana(aux_leitura,100); 
170E:  MOVLW  05
1710:  MOVWF  x9F
1712:  MOVLW  58
1714:  MOVWF  x9E
1716:  MOVLW  64
1718:  MOVWF  xA0
171A:  MOVLB  0
171C:  CALL   0E74
1720:  MOVFF  02,69F
1724:  MOVFF  01,69E
1728:  RCALL  0FA4
172A:  MOVFF  03,18E
172E:  MOVFF  02,18D
1732:  MOVFF  01,18C
1736:  MOVFF  00,18B
....................    
....................   for(i=0; i<100;i++) 
173A:  MOVLB  6
173C:  CLRF   x6B
173E:  MOVF   x6B,W
1740:  SUBLW  63
1742:  BNC   178E
....................     aux_leitura[i] = offset_current_ref[i]; 
1744:  BCF    FD8.0
1746:  RLCF   x6B,W
1748:  CLRF   03
174A:  ADDLW  58
174C:  MOVWF  01
174E:  MOVLW  05
1750:  ADDWFC 03,F
1752:  MOVFF  01,69E
1756:  MOVFF  03,69F
175A:  BCF    FD8.0
175C:  RLCF   x6B,W
175E:  CLRF   03
1760:  ADDLW  2C
1762:  MOVWF  FE9
1764:  MOVLW  04
1766:  ADDWFC 03,W
1768:  MOVWF  FEA
176A:  MOVFF  FEC,03
176E:  MOVF   FED,F
1770:  MOVFF  FEF,6A0
1774:  MOVFF  03,6A1
1778:  MOVFF  69F,FEA
177C:  MOVFF  01,FE9
1780:  MOVFF  03,FEC
1784:  MOVF   FED,F
1786:  MOVFF  6A0,FEF
178A:  INCF   x6B,F
178C:  BRA    173E
....................   aux_offset_current_ref = obtem_mediana(aux_leitura,100); 
178E:  MOVLW  05
1790:  MOVWF  x9F
1792:  MOVLW  58
1794:  MOVWF  x9E
1796:  MOVLW  64
1798:  MOVWF  xA0
179A:  MOVLB  0
179C:  CALL   0E74
17A0:  MOVFF  02,69F
17A4:  MOVFF  01,69E
17A8:  CALL   0FA4
17AC:  MOVFF  03,623
17B0:  MOVFF  02,622
17B4:  MOVFF  01,621
17B8:  MOVFF  00,620
....................  
....................   for(i=0; i<100;i++) 
17BC:  MOVLB  6
17BE:  CLRF   x6B
17C0:  MOVF   x6B,W
17C2:  SUBLW  63
17C4:  BNC   1802
....................     aux_leitura[i] = leitura_tensao[i]; 
17C6:  BCF    FD8.0
17C8:  RLCF   x6B,W
17CA:  CLRF   03
17CC:  ADDLW  58
17CE:  MOVWF  01
17D0:  MOVLW  05
17D2:  ADDWFC 03,F
17D4:  MOVFF  01,69E
17D8:  MOVFF  03,69F
17DC:  CLRF   03
17DE:  MOVF   x6B,W
17E0:  ADDLW  F4
17E2:  MOVWF  FE9
17E4:  MOVLW  04
17E6:  ADDWFC 03,W
17E8:  MOVWF  FEA
17EA:  MOVFF  FEF,6A0
17EE:  MOVFF  69F,FEA
17F2:  MOVFF  01,FE9
17F6:  CLRF   FEC
17F8:  MOVF   FED,F
17FA:  MOVFF  6A0,FEF
17FE:  INCF   x6B,F
1800:  BRA    17C0
....................   aux_tensao = obtem_mediana(aux_leitura,100); 
1802:  MOVLW  05
1804:  MOVWF  x9F
1806:  MOVLW  58
1808:  MOVWF  x9E
180A:  MOVLW  64
180C:  MOVWF  xA0
180E:  MOVLB  0
1810:  CALL   0E74
1814:  MOVFF  02,69F
1818:  MOVFF  01,69E
181C:  CALL   0FA4
1820:  MOVFF  03,192
1824:  MOVFF  02,191
1828:  MOVFF  01,190
182C:  MOVFF  00,18F
....................    
....................   aux_tensao = aux_tensao*(15.0/255.0); 
1830:  MOVFF  192,6C3
1834:  MOVFF  191,6C2
1838:  MOVFF  190,6C1
183C:  MOVFF  18F,6C0
1840:  MOVLW  F1
1842:  MOVLB  6
1844:  MOVWF  xC7
1846:  MOVLW  F0
1848:  MOVWF  xC6
184A:  MOVLW  70
184C:  MOVWF  xC5
184E:  MOVLW  7A
1850:  MOVWF  xC4
1852:  MOVLB  0
1854:  CALL   0FDA
1858:  MOVFF  03,192
185C:  MOVFF  02,191
1860:  MOVFF  01,190
1864:  MOVFF  00,18F
....................   zero_set_aux = (aux_corrente-(aux_offset_current_ref)); 
1868:  BSF    FD8.1
186A:  MOVFF  18E,6A1
186E:  MOVFF  18D,6A0
1872:  MOVFF  18C,69F
1876:  MOVFF  18B,69E
187A:  MOVFF  623,6A5
187E:  MOVFF  622,6A4
1882:  MOVFF  621,6A3
1886:  MOVFF  620,6A2
188A:  RCALL  10D0
188C:  MOVFF  03,19A
1890:  MOVFF  02,199
1894:  MOVFF  01,198
1898:  MOVFF  00,197
....................   aux_corrente = (zero_set_aux-zero_set)*355; 
189C:  BSF    FD8.1
189E:  MOVFF  19A,6A1
18A2:  MOVFF  199,6A0
18A6:  MOVFF  198,69F
18AA:  MOVFF  197,69E
18AE:  MOVFF  196,6A5
18B2:  MOVFF  195,6A4
18B6:  MOVFF  194,6A3
18BA:  MOVFF  193,6A2
18BE:  RCALL  10D0
18C0:  MOVFF  03,6A1
18C4:  MOVFF  02,6A0
18C8:  MOVFF  01,69F
18CC:  MOVFF  00,69E
18D0:  MOVFF  03,6C3
18D4:  MOVFF  02,6C2
18D8:  MOVFF  01,6C1
18DC:  MOVFF  00,6C0
18E0:  MOVLB  6
18E2:  CLRF   xC7
18E4:  MOVLW  80
18E6:  MOVWF  xC6
18E8:  MOVLW  31
18EA:  MOVWF  xC5
18EC:  MOVLW  87
18EE:  MOVWF  xC4
18F0:  MOVLB  0
18F2:  CALL   0FDA
18F6:  MOVFF  03,18E
18FA:  MOVFF  02,18D
18FE:  MOVFF  01,18C
1902:  MOVFF  00,18B
....................   if(aux_corrente > -750 && aux_corrente < 750) aux_corrente = 0; 
1906:  MOVLB  6
1908:  CLRF   xA1
190A:  MOVLW  80
190C:  MOVWF  xA0
190E:  MOVLW  BB
1910:  MOVWF  x9F
1912:  MOVLW  88
1914:  MOVWF  x9E
1916:  MOVFF  18E,6A5
191A:  MOVFF  18D,6A4
191E:  MOVFF  18C,6A3
1922:  MOVFF  18B,6A2
1926:  MOVLB  0
1928:  RCALL  1348
192A:  BNC   195E
192C:  MOVFF  18E,6A1
1930:  MOVFF  18D,6A0
1934:  MOVFF  18C,69F
1938:  MOVFF  18B,69E
193C:  MOVLB  6
193E:  CLRF   xA5
1940:  MOVLW  80
1942:  MOVWF  xA4
1944:  MOVLW  3B
1946:  MOVWF  xA3
1948:  MOVLW  88
194A:  MOVWF  xA2
194C:  MOVLB  0
194E:  RCALL  1348
1950:  BNC   195E
1952:  MOVLB  1
1954:  CLRF   x8E
1956:  CLRF   x8D
1958:  CLRF   x8C
195A:  CLRF   x8B
195C:  MOVLB  0
....................  
....................   disable_interrupts(GLOBAL); 
195E:  BCF    FF2.6
1960:  BCF    FF2.7
1962:  BTFSC  FF2.7
1964:  BRA    1960
....................   sprintf(exibe,"Corrente: %6.0f Tensao: %2.2f \r\n",aux_corrente,aux_tensao); 
1966:  MOVLW  06
1968:  MOVLB  1
196A:  MOVWF  x9C
196C:  MOVLW  6C
196E:  MOVWF  x9B
1970:  MOVLW  C8
1972:  MOVWF  FF6
1974:  MOVLW  09
1976:  MOVWF  FF7
1978:  MOVLW  0A
197A:  MOVLB  7
197C:  MOVWF  x17
197E:  MOVLB  0
1980:  CALL   0B3E
1984:  MOVLW  05
1986:  MOVWF  FE9
1988:  MOVFF  18E,6B6
198C:  MOVFF  18D,6B5
1990:  MOVFF  18C,6B4
1994:  MOVFF  18B,6B3
1998:  MOVLB  6
199A:  CLRF   xB7
199C:  MOVLB  0
199E:  RCALL  149A
19A0:  MOVLW  D7
19A2:  MOVWF  FF6
19A4:  MOVLW  09
19A6:  MOVWF  FF7
19A8:  MOVLW  09
19AA:  MOVLB  7
19AC:  MOVWF  x17
19AE:  MOVLB  0
19B0:  CALL   0B3E
19B4:  MOVLW  89
19B6:  MOVWF  FE9
19B8:  MOVFF  192,6B6
19BC:  MOVFF  191,6B5
19C0:  MOVFF  190,6B4
19C4:  MOVFF  18F,6B3
19C8:  MOVLW  02
19CA:  MOVLB  6
19CC:  MOVWF  xB7
19CE:  MOVLB  0
19D0:  RCALL  149A
19D2:  MOVLW  E5
19D4:  MOVWF  FF6
19D6:  MOVLW  09
19D8:  MOVWF  FF7
19DA:  MOVLW  03
19DC:  MOVLB  7
19DE:  MOVWF  x17
19E0:  MOVLB  0
19E2:  CALL   0B3E
....................   fprintf(MONITOR_SERIAL,exibe); 
19E6:  MOVLW  06
19E8:  MOVWF  FEA
19EA:  MOVLW  6C
19EC:  MOVWF  FE9
19EE:  RCALL  1694
....................   enable_interrupts(GLOBAL); 
19F0:  MOVLW  C0
19F2:  IORWF  FF2,F
19F4:  GOTO   2E02 (RETURN)
....................  
.................... } 
....................  
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam){   
....................  
....................   int16 aux;  
....................   int16 i, j; 
....................  
....................   for (i = 0; i < (tam-1); i++){ 
*
0E74:  MOVLB  6
0E76:  CLRF   xA4
0E78:  CLRF   xA3
0E7A:  MOVLW  01
0E7C:  SUBWF  xA0,W
0E7E:  MOVF   xA4,F
0E80:  BTFSS  FD8.2
0E82:  BRA    0F88
0E84:  SUBWF  xA3,W
0E86:  BTFSC  FD8.0
0E88:  BRA    0F88
....................     for (j = i+1; j < tam; j++){ 
0E8A:  MOVLW  01
0E8C:  ADDWF  xA3,W
0E8E:  MOVWF  xA5
0E90:  MOVLW  00
0E92:  ADDWFC xA4,W
0E94:  MOVWF  xA6
0E96:  MOVF   xA6,F
0E98:  BNZ   0F80
0E9A:  MOVF   xA0,W
0E9C:  SUBWF  xA5,W
0E9E:  BC    0F80
....................       if (num[i] < num[j]) 
0EA0:  BCF    FD8.0
0EA2:  RLCF   xA3,W
0EA4:  MOVWF  02
0EA6:  RLCF   xA4,W
0EA8:  MOVWF  03
0EAA:  MOVF   02,W
0EAC:  ADDWF  x9E,W
0EAE:  MOVWF  FE9
0EB0:  MOVF   x9F,W
0EB2:  ADDWFC 03,W
0EB4:  MOVWF  FEA
0EB6:  MOVFF  FEC,6A8
0EBA:  MOVF   FED,F
0EBC:  MOVFF  FEF,6A7
0EC0:  BCF    FD8.0
0EC2:  RLCF   xA5,W
0EC4:  MOVWF  02
0EC6:  RLCF   xA6,W
0EC8:  MOVWF  03
0ECA:  MOVF   02,W
0ECC:  ADDWF  x9E,W
0ECE:  MOVWF  FE9
0ED0:  MOVF   x9F,W
0ED2:  ADDWFC 03,W
0ED4:  MOVWF  FEA
0ED6:  MOVFF  FEC,03
0EDA:  MOVF   FED,F
0EDC:  MOVFF  FEF,01
0EE0:  MOVF   xA8,W
0EE2:  SUBWF  03,W
0EE4:  BNC   0F78
0EE6:  BNZ   0EEE
0EE8:  MOVF   01,W
0EEA:  SUBWF  xA7,W
0EEC:  BC    0F78
....................       { 
....................         aux = num[i]; 
0EEE:  BCF    FD8.0
0EF0:  RLCF   xA3,W
0EF2:  MOVWF  02
0EF4:  RLCF   xA4,W
0EF6:  MOVWF  03
0EF8:  MOVF   02,W
0EFA:  ADDWF  x9E,W
0EFC:  MOVWF  FE9
0EFE:  MOVF   x9F,W
0F00:  ADDWFC 03,W
0F02:  MOVWF  FEA
0F04:  MOVFF  FEC,6A2
0F08:  MOVF   FED,F
0F0A:  MOVFF  FEF,6A1
....................         num[i] = num[j]; 
0F0E:  BCF    FD8.0
0F10:  RLCF   xA3,W
0F12:  MOVWF  02
0F14:  RLCF   xA4,W
0F16:  MOVWF  03
0F18:  MOVF   02,W
0F1A:  ADDWF  x9E,W
0F1C:  MOVWF  01
0F1E:  MOVF   x9F,W
0F20:  ADDWFC 03,F
0F22:  MOVFF  03,6A8
0F26:  BCF    FD8.0
0F28:  RLCF   xA5,W
0F2A:  MOVWF  02
0F2C:  RLCF   xA6,W
0F2E:  MOVWF  03
0F30:  MOVF   02,W
0F32:  ADDWF  x9E,W
0F34:  MOVWF  FE9
0F36:  MOVF   x9F,W
0F38:  ADDWFC 03,W
0F3A:  MOVWF  FEA
0F3C:  MOVFF  FEC,03
0F40:  MOVF   FED,F
0F42:  MOVFF  FEF,6A9
0F46:  MOVFF  6A8,FEA
0F4A:  MOVFF  01,FE9
0F4E:  MOVFF  03,FEC
0F52:  MOVF   FED,F
0F54:  MOVFF  6A9,FEF
....................         num[j] = aux; 
0F58:  BCF    FD8.0
0F5A:  RLCF   xA5,W
0F5C:  MOVWF  02
0F5E:  RLCF   xA6,W
0F60:  MOVWF  03
0F62:  MOVF   02,W
0F64:  ADDWF  x9E,W
0F66:  MOVWF  FE9
0F68:  MOVF   x9F,W
0F6A:  ADDWFC 03,W
0F6C:  MOVWF  FEA
0F6E:  MOVFF  6A2,FEC
0F72:  MOVF   FED,F
0F74:  MOVFF  6A1,FEF
....................       } 
0F78:  INCF   xA5,F
0F7A:  BTFSC  FD8.2
0F7C:  INCF   xA6,F
0F7E:  BRA    0E96
....................     } 
0F80:  INCF   xA3,F
0F82:  BTFSC  FD8.2
0F84:  INCF   xA4,F
0F86:  BRA    0E7A
....................   } 
....................   return num[50];  
0F88:  MOVLW  64
0F8A:  ADDWF  x9E,W
0F8C:  MOVWF  FE9
0F8E:  MOVLW  00
0F90:  ADDWFC x9F,W
0F92:  MOVWF  FEA
0F94:  MOVFF  FEF,01
0F98:  INCF   FE9,F
0F9A:  MOVF   FEF,W
0F9C:  DECF   FE9,F
0F9E:  MOVWF  02
0FA0:  MOVLB  0
0FA2:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: CE3B   PLL4 CPUDIV4 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00040: 00 00 00 
