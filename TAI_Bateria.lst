CCS PCH C Compiler, Version 5.015, 5967               16-nov-18 14:54

               Filename:   C:\Users\Vitor\Desktop\Monitor_Estado_Baterias\TAI_Bateria.lst

               ROM used:   13226 bytes (40%)
                           Largest free fragment is 19538
               RAM used:   1606 (78%) at main() level
                           1846 (90%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   31CA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.4
004A:  GOTO   0054
004E:  BTFSC  FF2.1
0050:  GOTO   0922
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   05DC
0060:  BTFSS  FF2.5
0062:  GOTO   006C
0066:  BTFSC  FF2.2
0068:  GOTO   07A4
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Projeto Monitor do Estado de Baterias - TAI  
.................... // Data: Setembro de 2018 
....................  
....................  
.................... //******************* Interrupção do Timer 0 / RTCC ************************** 
.................... //   
.................... //  Cristal externo = 16 MHz - Uso de PLL*4 -> Frequencia de trabalho = 16MHz  
.................... //  Prescaler = 1:16 
.................... //  Tout =(4*prescaler* (256-TMR0))/fclk   
.................... //  Para interrup��o a cada 1 ms 
.................... //  TMR0 = 6  
.................... //  
.................... //**************************************************************************** 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  MOVFF  FF2,0D
00B2:  BCF    FF2.7
00B4:  CLRF   FF7
00B6:  ADDLW  C8
00B8:  MOVWF  FF6
00BA:  MOVLW  00
00BC:  ADDWFC FF7,F
00BE:  TBLRD*+
00C0:  MOVF   FF5,W
00C2:  BTFSC  0D.7
00C4:  BSF    FF2.7
00C6:  RETURN 0
00C8:  DATA 2B,43
00CA:  DATA 4D,54
00CC:  DATA 49,00
00CE:  MOVFF  FF2,0D
00D2:  BCF    FF2.7
00D4:  CLRF   FF7
00D6:  ADDLW  E8
00D8:  MOVWF  FF6
00DA:  MOVLW  00
00DC:  ADDWFC FF7,F
00DE:  TBLRD*+
00E0:  MOVF   FF5,W
00E2:  BTFSC  0D.7
00E4:  BSF    FF2.7
00E6:  RETURN 0
00E8:  DATA 2B,43
00EA:  DATA 4D,47
00EC:  DATA 4C,00
00EE:  MOVFF  FF2,0D
00F2:  BCF    FF2.7
00F4:  CLRF   FF7
00F6:  ADDLW  08
00F8:  MOVWF  FF6
00FA:  MOVLW  01
00FC:  ADDWFC FF7,F
00FE:  TBLRD*+
0100:  MOVF   FF5,W
0102:  BTFSC  0D.7
0104:  BSF    FF2.7
0106:  RETURN 0
0108:  DATA 4F,49
010A:  DATA 54,41
010C:  DATA 49,00
010E:  MOVFF  FF2,0D
0112:  BCF    FF2.7
0114:  CLRF   FF7
0116:  ADDLW  28
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  BTFSC  0D.7
0124:  BSF    FF2.7
0126:  RETURN 0
0128:  DATA 48,45
012A:  DATA 41,52
012C:  DATA 54,42
012E:  DATA 45,41
0130:  DATA 54,28
0132:  DATA 29,00
0134:  MOVFF  FF2,0D
0138:  BCF    FF2.7
013A:  CLRF   FF7
013C:  ADDLW  4E
013E:  MOVWF  FF6
0140:  MOVLW  01
0142:  ADDWFC FF7,F
0144:  TBLRD*+
0146:  MOVF   FF5,W
0148:  BTFSC  0D.7
014A:  BSF    FF2.7
014C:  RETURN 0
014E:  DATA 2B,4E
0150:  DATA 55,4D
0152:  DATA 41,44
0154:  DATA 44,00
0156:  MOVFF  FF2,0D
015A:  BCF    FF2.7
015C:  CLRF   FF7
015E:  ADDLW  70
0160:  MOVWF  FF6
0162:  MOVLW  01
0164:  ADDWFC FF7,F
0166:  TBLRD*+
0168:  MOVF   FF5,W
016A:  BTFSC  0D.7
016C:  BSF    FF2.7
016E:  RETURN 0
0170:  DATA 2B,4E
0172:  DATA 55,4D
0174:  DATA 44,45
0176:  DATA 4C,00
0178:  MOVFF  FF2,0D
017C:  BCF    FF2.7
017E:  CLRF   FF7
0180:  ADDLW  92
0182:  MOVWF  FF6
0184:  MOVLW  01
0186:  ADDWFC FF7,F
0188:  TBLRD*+
018A:  MOVF   FF5,W
018C:  BTFSC  0D.7
018E:  BSF    FF2.7
0190:  RETURN 0
0192:  DATA 4F,4B
0194:  DATA 20,43
0196:  DATA 4C,45
0198:  DATA 41,52
019A:  DATA 20,41
019C:  DATA 4C,4C
019E:  DATA 00,00
01A0:  MOVFF  FF2,0D
01A4:  BCF    FF2.7
01A6:  CLRF   FF7
01A8:  ADDLW  BA
01AA:  MOVWF  FF6
01AC:  MOVLW  01
01AE:  ADDWFC FF7,F
01B0:  TBLRD*+
01B2:  MOVF   FF5,W
01B4:  BTFSC  0D.7
01B6:  BSF    FF2.7
01B8:  RETURN 0
01BA:  DATA 2B,47
01BC:  DATA 53,4D
01BE:  DATA 4C,4F
01C0:  DATA 43,41
01C2:  DATA 54,45
01C4:  DATA 00,00
01C6:  MOVFF  FF2,0D
01CA:  BCF    FF2.7
01CC:  CLRF   FF7
01CE:  ADDLW  E0
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  BTFSC  0D.7
01DC:  BSF    FF2.7
01DE:  RETURN 0
01E0:  DATA 2B,43
01E2:  DATA 55,52
01E4:  DATA 4C,49
01E6:  DATA 4D,00
01E8:  MOVFF  FF2,0D
01EC:  BCF    FF2.7
01EE:  CLRF   FF7
01F0:  ADDLW  02
01F2:  MOVWF  FF6
01F4:  MOVLW  02
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  BTFSC  0D.7
01FE:  BSF    FF2.7
0200:  RETURN 0
0202:  DATA 2B,43
0204:  DATA 55,52
0206:  DATA 41,4C
0208:  DATA 4D,00
020A:  MOVFF  FF2,0D
020E:  BCF    FF2.7
0210:  CLRF   FF7
0212:  ADDLW  24
0214:  MOVWF  FF6
0216:  MOVLW  02
0218:  ADDWFC FF7,F
021A:  TBLRD*+
021C:  MOVF   FF5,W
021E:  BTFSC  0D.7
0220:  BSF    FF2.7
0222:  RETURN 0
0224:  DATA 2B,43
0226:  DATA 53,54
0228:  DATA 41,54
022A:  DATA 53,00
022C:  MOVFF  FF2,0D
0230:  BCF    FF2.7
0232:  CLRF   FF7
0234:  ADDLW  46
0236:  MOVWF  FF6
0238:  MOVLW  02
023A:  ADDWFC FF7,F
023C:  TBLRD*+
023E:  MOVF   FF5,W
0240:  BTFSC  0D.7
0242:  BSF    FF2.7
0244:  RETURN 0
0246:  DATA 2B,53
0248:  DATA 45,54
024A:  DATA 5A,45
024C:  DATA 52,4F
024E:  DATA 00,00
0250:  MOVFF  FF2,0D
0254:  BCF    FF2.7
0256:  CLRF   FF7
0258:  ADDLW  6A
025A:  MOVWF  FF6
025C:  MOVLW  02
025E:  ADDWFC FF7,F
0260:  TBLRD*+
0262:  MOVF   FF5,W
0264:  BTFSC  0D.7
0266:  BSF    FF2.7
0268:  RETURN 0
026A:  DATA 5A,45
026C:  DATA 52,4F
026E:  DATA 20,53
0270:  DATA 45,54
0272:  DATA 45,44
0274:  DATA 00,00
0276:  MOVFF  FF2,0D
027A:  BCF    FF2.7
027C:  CLRF   FF7
027E:  ADDLW  90
0280:  MOVWF  FF6
0282:  MOVLW  02
0284:  ADDWFC FF7,F
0286:  TBLRD*+
0288:  MOVF   FF5,W
028A:  BTFSC  0D.7
028C:  BSF    FF2.7
028E:  RETURN 0
0290:  DATA 41,54
0292:  DATA 2B,43
0294:  DATA 4D,47
0296:  DATA 46,3D
0298:  DATA 31,0D
029A:  DATA 0A,00
029C:  MOVFF  FF2,0D
02A0:  BCF    FF2.7
02A2:  CLRF   FF7
02A4:  ADDLW  B6
02A6:  MOVWF  FF6
02A8:  MOVLW  02
02AA:  ADDWFC FF7,F
02AC:  TBLRD*+
02AE:  MOVF   FF5,W
02B0:  BTFSC  0D.7
02B2:  BSF    FF2.7
02B4:  RETURN 0
02B6:  DATA 41,54
02B8:  DATA 2B,43
02BA:  DATA 53,4D
02BC:  DATA 50,3D
02BE:  DATA 31,37
02C0:  DATA 2C,32
02C2:  DATA 35,35
02C4:  DATA 2C,30
02C6:  DATA 2C,30
02C8:  DATA 0D,0A
02CA:  DATA 00,00
02CC:  MOVFF  FF2,0D
02D0:  BCF    FF2.7
02D2:  CLRF   FF7
02D4:  ADDLW  E6
02D6:  MOVWF  FF6
02D8:  MOVLW  02
02DA:  ADDWFC FF7,F
02DC:  TBLRD*+
02DE:  MOVF   FF5,W
02E0:  BTFSC  0D.7
02E2:  BSF    FF2.7
02E4:  RETURN 0
02E6:  DATA 2B,43
02E8:  DATA 4D,47
02EA:  DATA 53,3A
02EC:  DATA 00,00
02EE:  MOVFF  FF2,0D
02F2:  BCF    FF2.7
02F4:  CLRF   FF7
02F6:  ADDLW  08
02F8:  MOVWF  FF6
02FA:  MOVLW  03
02FC:  ADDWFC FF7,F
02FE:  TBLRD*+
0300:  MOVF   FF5,W
0302:  BTFSC  0D.7
0304:  BSF    FF2.7
0306:  RETURN 0
0308:  DATA 41,54
030A:  DATA 2B,43
030C:  DATA 4D,47
030E:  DATA 4C,3D
0310:  DATA 22,52
0312:  DATA 45,43
0314:  DATA 20,55
0316:  DATA 4E,52
0318:  DATA 45,41
031A:  DATA 44,22
031C:  DATA 0D,0A
031E:  DATA 00,00
0320:  MOVFF  FF2,0D
0324:  BCF    FF2.7
0326:  CLRF   FF7
0328:  ADDLW  3A
032A:  MOVWF  FF6
032C:  MOVLW  03
032E:  ADDWFC FF7,F
0330:  TBLRD*+
0332:  MOVF   FF5,W
0334:  BTFSC  0D.7
0336:  BSF    FF2.7
0338:  RETURN 0
033A:  DATA 41,54
033C:  DATA 2B,43
033E:  DATA 47,41
0340:  DATA 54,54
0342:  DATA 3D,31
0344:  DATA 0D,0A
0346:  DATA 00,00
0348:  MOVFF  FF2,0D
034C:  BCF    FF2.7
034E:  CLRF   FF7
0350:  ADDLW  62
0352:  MOVWF  FF6
0354:  MOVLW  03
0356:  ADDWFC FF7,F
0358:  TBLRD*+
035A:  MOVF   FF5,W
035C:  BTFSC  0D.7
035E:  BSF    FF2.7
0360:  RETURN 0
0362:  DATA 41,54
0364:  DATA 2B,53
0366:  DATA 41,50
0368:  DATA 42,52
036A:  DATA 3D,33
036C:  DATA 2C,31
036E:  DATA 2C,22
0370:  DATA 43,4F
0372:  DATA 4E,54
0374:  DATA 59,50
0376:  DATA 45,22
0378:  DATA 2C,22
037A:  DATA 47,50
037C:  DATA 52,53
037E:  DATA 22,0D
0380:  DATA 0A,00
0382:  MOVFF  FF2,0D
0386:  BCF    FF2.7
0388:  CLRF   FF7
038A:  ADDLW  9C
038C:  MOVWF  FF6
038E:  MOVLW  03
0390:  ADDWFC FF7,F
0392:  TBLRD*+
0394:  MOVF   FF5,W
0396:  BTFSC  0D.7
0398:  BSF    FF2.7
039A:  RETURN 0
039C:  DATA 41,54
039E:  DATA 2B,53
03A0:  DATA 41,50
03A2:  DATA 42,52
03A4:  DATA 3D,33
03A6:  DATA 2C,31
03A8:  DATA 2C,22
03AA:  DATA 41,50
03AC:  DATA 4E,22
03AE:  DATA 2C,22
03B0:  DATA 43,4D
03B2:  DATA 4E,45
03B4:  DATA 54,22
03B6:  DATA 0D,0A
03B8:  DATA 00,00
03BA:  MOVFF  FF2,0D
03BE:  BCF    FF2.7
03C0:  CLRF   FF7
03C2:  ADDLW  D4
03C4:  MOVWF  FF6
03C6:  MOVLW  03
03C8:  ADDWFC FF7,F
03CA:  TBLRD*+
03CC:  MOVF   FF5,W
03CE:  BTFSC  0D.7
03D0:  BSF    FF2.7
03D2:  RETURN 0
03D4:  DATA 41,54
03D6:  DATA 2B,53
03D8:  DATA 41,50
03DA:  DATA 42,52
03DC:  DATA 3D,31
03DE:  DATA 2C,31
03E0:  DATA 0D,0A
03E2:  DATA 00,00
03E4:  MOVFF  FF2,0D
03E8:  BCF    FF2.7
03EA:  CLRF   FF7
03EC:  ADDLW  FE
03EE:  MOVWF  FF6
03F0:  MOVLW  03
03F2:  ADDWFC FF7,F
03F4:  TBLRD*+
03F6:  MOVF   FF5,W
03F8:  BTFSC  0D.7
03FA:  BSF    FF2.7
03FC:  RETURN 0
03FE:  DATA 41,54
0400:  DATA 2B,53
0402:  DATA 41,50
0404:  DATA 42,52
0406:  DATA 3D,32
0408:  DATA 2C,31
040A:  DATA 0D,0A
040C:  DATA 00,00
040E:  MOVFF  FF2,0D
0412:  BCF    FF2.7
0414:  CLRF   FF7
0416:  ADDLW  28
0418:  MOVWF  FF6
041A:  MOVLW  04
041C:  ADDWFC FF7,F
041E:  TBLRD*+
0420:  MOVF   FF5,W
0422:  BTFSC  0D.7
0424:  BSF    FF2.7
0426:  RETURN 0
0428:  DATA 2B,53
042A:  DATA 41,50
042C:  DATA 42,52
042E:  DATA 3A,00
0430:  MOVFF  FF2,0D
0434:  BCF    FF2.7
0436:  CLRF   FF7
0438:  ADDLW  4A
043A:  MOVWF  FF6
043C:  MOVLW  04
043E:  ADDWFC FF7,F
0440:  TBLRD*+
0442:  MOVF   FF5,W
0444:  BTFSC  0D.7
0446:  BSF    FF2.7
0448:  RETURN 0
044A:  DATA 41,54
044C:  DATA 2B,43
044E:  DATA 4C,42
0450:  DATA 53,43
0452:  DATA 46,47
0454:  DATA 3D,30
0456:  DATA 2C,31
0458:  DATA 0D,0A
045A:  DATA 00,00
045C:  MOVFF  FF2,0D
0460:  BCF    FF2.7
0462:  CLRF   FF7
0464:  ADDLW  76
0466:  MOVWF  FF6
0468:  MOVLW  04
046A:  ADDWFC FF7,F
046C:  TBLRD*+
046E:  MOVF   FF5,W
0470:  BTFSC  0D.7
0472:  BSF    FF2.7
0474:  RETURN 0
0476:  DATA 2B,43
0478:  DATA 4C,42
047A:  DATA 53,43
047C:  DATA 46,47
047E:  DATA 3A,00
0480:  MOVFF  FF2,0D
0484:  BCF    FF2.7
0486:  CLRF   FF7
0488:  ADDLW  9A
048A:  MOVWF  FF6
048C:  MOVLW  04
048E:  ADDWFC FF7,F
0490:  TBLRD*+
0492:  MOVF   FF5,W
0494:  BTFSC  0D.7
0496:  BSF    FF2.7
0498:  RETURN 0
049A:  DATA 41,54
049C:  DATA 2B,43
049E:  DATA 4C,42
04A0:  DATA 53,3D
04A2:  DATA 31,2C
04A4:  DATA 31,0D
04A6:  DATA 0A,00
04A8:  MOVFF  FF2,0D
04AC:  BCF    FF2.7
04AE:  CLRF   FF7
04B0:  ADDLW  C2
04B2:  MOVWF  FF6
04B4:  MOVLW  04
04B6:  ADDWFC FF7,F
04B8:  TBLRD*+
04BA:  MOVF   FF5,W
04BC:  BTFSC  0D.7
04BE:  BSF    FF2.7
04C0:  RETURN 0
04C2:  DATA 2B,43
04C4:  DATA 4C,42
04C6:  DATA 53,3A
04C8:  DATA 00,00
04CA:  MOVFF  FF2,0D
04CE:  BCF    FF2.7
04D0:  CLRF   FF7
04D2:  ADDLW  E4
04D4:  MOVWF  FF6
04D6:  MOVLW  04
04D8:  ADDWFC FF7,F
04DA:  TBLRD*+
04DC:  MOVF   FF5,W
04DE:  BTFSC  0D.7
04E0:  BSF    FF2.7
04E2:  RETURN 0
04E4:  DATA 41,54
04E6:  DATA 2B,53
04E8:  DATA 41,50
04EA:  DATA 42,52
04EC:  DATA 3D,30
04EE:  DATA 2C,31
04F0:  DATA 0D,0A
04F2:  DATA 00,00
04F4:  MOVFF  FF2,0D
04F8:  BCF    FF2.7
04FA:  CLRF   FF7
04FC:  ADDLW  0E
04FE:  MOVWF  FF6
0500:  MOVLW  05
0502:  ADDWFC FF7,F
0504:  TBLRD*+
0506:  MOVF   FF5,W
0508:  BTFSC  0D.7
050A:  BSF    FF2.7
050C:  RETURN 0
050E:  DATA 30,33
0510:  DATA 31,39
0512:  DATA 39,35
0514:  DATA 38,32
0516:  DATA 32,37
0518:  DATA 33,39
051A:  DATA 00,00
051C:  MOVFF  FF2,0D
0520:  BCF    FF2.7
0522:  CLRF   FF7
0524:  ADDLW  36
0526:  MOVWF  FF6
0528:  MOVLW  05
052A:  ADDWFC FF7,F
052C:  TBLRD*+
052E:  MOVF   FF5,W
0530:  BTFSC  0D.7
0532:  BSF    FF2.7
0534:  RETURN 0
0536:  DATA 49,4E
0538:  DATA 49,43
053A:  DATA 49,41
053C:  DATA 4E,44
053E:  DATA 4F,2E
0540:  DATA 2E,2E
0542:  DATA 00,00
0544:  MOVFF  FF2,0D
0548:  BCF    FF2.7
054A:  CLRF   FF7
054C:  ADDLW  5E
054E:  MOVWF  FF6
0550:  MOVLW  05
0552:  ADDWFC FF7,F
0554:  TBLRD*+
0556:  MOVF   FF5,W
0558:  BTFSC  0D.7
055A:  BSF    FF2.7
055C:  RETURN 0
055E:  DATA 41,54
0560:  DATA 2B,43
0562:  DATA 4D,47
0564:  DATA 44,3D
0566:  DATA 31,2C
0568:  DATA 31,0D
056A:  DATA 0A,00
056C:  MOVFF  FF2,0D
0570:  BCF    FF2.7
0572:  CLRF   FF7
0574:  ADDLW  86
0576:  MOVWF  FF6
0578:  MOVLW  05
057A:  ADDWFC FF7,F
057C:  TBLRD*+
057E:  MOVF   FF5,W
0580:  BTFSC  0D.7
0582:  BSF    FF2.7
0584:  RETURN 0
0586:  DATA 21,21
0588:  DATA 21,21
058A:  DATA 41,4C
058C:  DATA 45,52
058E:  DATA 54,41
0590:  DATA 3A,20
0592:  DATA 42,61
0594:  DATA 74,65
0596:  DATA 72,69
0598:  DATA 61,20
059A:  DATA 65,6D
059C:  DATA 20,64
059E:  DATA 65,73
05A0:  DATA 63,61
05A2:  DATA 72,67
05A4:  DATA 61,20
05A6:  DATA 72,61
05A8:  DATA 70,69
05AA:  DATA 64,61
05AC:  DATA 20,56
05AE:  DATA 45,52
05B0:  DATA 49,46
05B2:  DATA 49,51
05B4:  DATA 55,45
05B6:  DATA 20,53
05B8:  DATA 45,55
05BA:  DATA 20,56
05BC:  DATA 45,49
05BE:  DATA 43,55
05C0:  DATA 4C,4F
05C2:  DATA 21,21
05C4:  DATA 21,00
*
0694:  DATA 43,6F
0696:  DATA 72,72
0698:  DATA 65,6E
069A:  DATA 74,65
069C:  DATA 20,4C
069E:  DATA 69,6D
06A0:  DATA 69,74
06A2:  DATA 65,20
06A4:  DATA 3D,20
06A6:  DATA 25,4C
06A8:  DATA 75,20
06AA:  DATA 6D,41
06AC:  DATA 00,00
06AE:  DATA 54,65
06B0:  DATA 6D,70
06B2:  DATA 6F,20
06B4:  DATA 45,6E
06B6:  DATA 74,72
06B8:  DATA 65,20
06BA:  DATA 41,6C
06BC:  DATA 65,72
06BE:  DATA 74,61
06C0:  DATA 73,20
06C2:  DATA 3D,20
06C4:  DATA 25,4C
06C6:  DATA 75,20
06C8:  DATA 6D,69
06CA:  DATA 6E,00
06CC:  DATA 54,65
06CE:  DATA 6D,70
06D0:  DATA 6F,20
06D2:  DATA 45,6E
06D4:  DATA 74,72
06D6:  DATA 65,20
06D8:  DATA 41,6C
06DA:  DATA 65,72
06DC:  DATA 74,61
06DE:  DATA 73,20
06E0:  DATA 3D,20
06E2:  DATA 25,4C
06E4:  DATA 75,20
06E6:  DATA 6D,69
06E8:  DATA 6E,20
06EA:  DATA 2F,20
06EC:  DATA 43,6F
06EE:  DATA 72,72
06F0:  DATA 65,6E
06F2:  DATA 74,65
06F4:  DATA 20,4C
06F6:  DATA 69,6D
06F8:  DATA 69,74
06FA:  DATA 65,20
06FC:  DATA 3D,20
06FE:  DATA 25,4C
0700:  DATA 75,20
0702:  DATA 6D,41
0704:  DATA 20,2F
0706:  DATA 20,43
0708:  DATA 6F,72
070A:  DATA 72,65
070C:  DATA 6E,74
070E:  DATA 65,20
0710:  DATA 41,74
0712:  DATA 75,61
0714:  DATA 6C,3A
0716:  DATA 20,25
0718:  DATA 36,2E
071A:  DATA 30,66
071C:  DATA 20,6D
071E:  DATA 41,20
0720:  DATA 2F,20
0722:  DATA 54,65
0724:  DATA 6E,73
0726:  DATA 61,6F
0728:  DATA 20,41
072A:  DATA 74,75
072C:  DATA 61,6C
072E:  DATA 3A,20
0730:  DATA 25,32
0732:  DATA 2E,32
0734:  DATA 66,20
0736:  DATA 56,20
0738:  DATA 2F,20
073A:  DATA 51,74
073C:  DATA 64,20
073E:  DATA 54,65
0740:  DATA 6C,65
0742:  DATA 66,6F
0744:  DATA 6E,65
0746:  DATA 73,3A
0748:  DATA 20,25
074A:  DATA 75,00
074C:  DATA 41,54
074E:  DATA 2B,43
0750:  DATA 4D,47
0752:  DATA 53,3D
0754:  DATA 22,25
0756:  DATA 73,22
0758:  DATA 0D,0A
075A:  DATA 00,00
075C:  CLRF   01
075E:  CLRF   02
0760:  CLRF   00
0762:  CLRF   03
0764:  MOVLB  7
0766:  MOVF   x34,W
0768:  BNZ   076E
076A:  MOVF   x33,W
076C:  BZ    079E
076E:  MOVLW  10
0770:  MOVWF  x35
0772:  BCF    FD8.0
0774:  RLCF   x31,F
0776:  RLCF   x32,F
0778:  RLCF   00,F
077A:  RLCF   03,F
077C:  MOVF   x34,W
077E:  SUBWF  03,W
0780:  BNZ   0786
0782:  MOVF   x33,W
0784:  SUBWF  00,W
0786:  BNC   0796
0788:  MOVF   x33,W
078A:  SUBWF  00,F
078C:  BTFSS  FD8.0
078E:  DECF   03,F
0790:  MOVF   x34,W
0792:  SUBWF  03,F
0794:  BSF    FD8.0
0796:  RLCF   01,F
0798:  RLCF   02,F
079A:  DECFSZ x35,F
079C:  BRA    0772
079E:  MOVLB  0
07A0:  GOTO   0824 (RETURN)
*
0948:  DATA 44,65
094A:  DATA 74,65
094C:  DATA 63,74
094E:  DATA 20,48
0950:  DATA 69,67
0952:  DATA 68,20
0954:  DATA 43,75
0956:  DATA 72,72
0958:  DATA 65,6E
095A:  DATA 74,0D
095C:  DATA 0A,00
095E:  DATA 44,65
0960:  DATA 74,65
0962:  DATA 63,74
0964:  DATA 20,4C
0966:  DATA 6F,77
0968:  DATA 20,43
096A:  DATA 75,72
096C:  DATA 72,65
096E:  DATA 6E,74
0970:  DATA 0D,0A
0972:  DATA 00,00
0974:  DATA 53,65
0976:  DATA 6E,64
0978:  DATA 20,53
097A:  DATA 4D,53
097C:  DATA 20,4E
097E:  DATA 75,6D
0980:  DATA 65,72
0982:  DATA 6F,20
0984:  DATA 28,25
0986:  DATA 75,2F
0988:  DATA 25,75
098A:  DATA 29,3A
098C:  DATA 20,25
098E:  DATA 73,0D
0990:  DATA 0A,00
0992:  DATA 43,6F
0994:  DATA 72,72
0996:  DATA 65,6E
0998:  DATA 74,65
099A:  DATA 3A,20
099C:  DATA 25,36
099E:  DATA 2E,30
09A0:  DATA 66,20
09A2:  DATA 54,65
09A4:  DATA 6E,73
09A6:  DATA 61,6F
09A8:  DATA 3A,20
09AA:  DATA 25,32
09AC:  DATA 2E,32
09AE:  DATA 66,20
09B0:  DATA 0D,0A
09B2:  DATA 00,00
*
0AE6:  MOVFF  19C,FEA
0AEA:  MOVFF  19B,FE9
0AEE:  MOVLB  7
0AF0:  MOVFF  71A,FEF
0AF4:  INCF   FE9,F
0AF6:  BTFSC  FD8.2
0AF8:  INCF   FEA,F
0AFA:  CLRF   FEF
0AFC:  MOVLB  1
0AFE:  INCF   x9B,F
0B00:  BTFSC  FD8.2
0B02:  INCF   x9C,F
0B04:  MOVLB  0
0B06:  RETURN 0
0B08:  TBLRD*+
0B0A:  MOVFF  FF6,718
0B0E:  MOVFF  FF7,719
0B12:  MOVFF  FF5,71A
0B16:  RCALL  0AE6
0B18:  MOVFF  718,FF6
0B1C:  MOVFF  719,FF7
0B20:  MOVLB  7
0B22:  DECFSZ x17,F
0B24:  BRA    0B28
0B26:  BRA    0B2C
0B28:  MOVLB  0
0B2A:  BRA    0B08
0B2C:  MOVLB  0
0B2E:  RETURN 0
0B30:  MOVF   FEF,F
0B32:  BZ    0B52
0B34:  MOVFF  FEA,718
0B38:  MOVFF  FE9,717
0B3C:  MOVFF  FEF,71A
0B40:  RCALL  0AE6
0B42:  MOVFF  718,FEA
0B46:  MOVFF  717,FE9
0B4A:  INCF   FE9,F
0B4C:  BTFSC  FD8.2
0B4E:  INCF   FEA,F
0B50:  BRA    0B30
0B52:  GOTO   0D2C (RETURN)
0B56:  MOVF   FEF,F
0B58:  BZ    0B7A
0B5A:  MOVFF  FEA,727
0B5E:  MOVFF  FE9,726
0B62:  MOVF   FEF,W
0B64:  BTFSS  F9E.4
0B66:  BRA    0B64
0B68:  MOVWF  FAD
0B6A:  MOVFF  727,FEA
0B6E:  MOVFF  726,FE9
0B72:  INCF   FE9,F
0B74:  BTFSC  FD8.2
0B76:  INCF   FEA,F
0B78:  BRA    0B56
0B7A:  GOTO   0C42 (RETURN)
*
0F6E:  MOVLW  8E
0F70:  MOVWF  00
0F72:  MOVFF  69F,01
0F76:  MOVFF  69E,02
0F7A:  CLRF   03
0F7C:  MOVF   01,F
0F7E:  BNZ   0F92
0F80:  MOVFF  02,01
0F84:  CLRF   02
0F86:  MOVLW  08
0F88:  SUBWF  00,F
0F8A:  MOVF   01,F
0F8C:  BNZ   0F92
0F8E:  CLRF   00
0F90:  BRA    0FA2
0F92:  BCF    FD8.0
0F94:  BTFSC  01.7
0F96:  BRA    0FA0
0F98:  RLCF   02,F
0F9A:  RLCF   01,F
0F9C:  DECF   00,F
0F9E:  BRA    0F92
0FA0:  BCF    01.7
0FA2:  RETURN 0
0FA4:  MOVLB  6
0FA6:  MOVF   xC0,W
0FA8:  BTFSC  FD8.2
0FAA:  BRA    108E
0FAC:  MOVWF  00
0FAE:  MOVF   xC4,W
0FB0:  BTFSC  FD8.2
0FB2:  BRA    108E
0FB4:  ADDWF  00,F
0FB6:  BNC   0FC0
0FB8:  MOVLW  81
0FBA:  ADDWF  00,F
0FBC:  BC    108E
0FBE:  BRA    0FC8
0FC0:  MOVLW  7F
0FC2:  SUBWF  00,F
0FC4:  BNC   108E
0FC6:  BZ    108E
0FC8:  MOVFF  6C1,6C8
0FCC:  MOVF   xC5,W
0FCE:  XORWF  xC8,F
0FD0:  BSF    xC1.7
0FD2:  BSF    xC5.7
0FD4:  MOVF   xC3,W
0FD6:  MULWF  xC7
0FD8:  MOVFF  FF4,6CA
0FDC:  MOVF   xC2,W
0FDE:  MULWF  xC6
0FE0:  MOVFF  FF4,03
0FE4:  MOVFF  FF3,6C9
0FE8:  MULWF  xC7
0FEA:  MOVF   FF3,W
0FEC:  ADDWF  xCA,F
0FEE:  MOVF   FF4,W
0FF0:  ADDWFC xC9,F
0FF2:  MOVLW  00
0FF4:  ADDWFC 03,F
0FF6:  MOVF   xC3,W
0FF8:  MULWF  xC6
0FFA:  MOVF   FF3,W
0FFC:  ADDWF  xCA,F
0FFE:  MOVF   FF4,W
1000:  ADDWFC xC9,F
1002:  MOVLW  00
1004:  CLRF   02
1006:  ADDWFC 03,F
1008:  ADDWFC 02,F
100A:  MOVF   xC1,W
100C:  MULWF  xC7
100E:  MOVF   FF3,W
1010:  ADDWF  xC9,F
1012:  MOVF   FF4,W
1014:  ADDWFC 03,F
1016:  MOVLW  00
1018:  ADDWFC 02,F
101A:  MOVF   xC1,W
101C:  MULWF  xC6
101E:  MOVF   FF3,W
1020:  ADDWF  03,F
1022:  MOVF   FF4,W
1024:  ADDWFC 02,F
1026:  MOVLW  00
1028:  CLRF   01
102A:  ADDWFC 01,F
102C:  MOVF   xC3,W
102E:  MULWF  xC5
1030:  MOVF   FF3,W
1032:  ADDWF  xC9,F
1034:  MOVF   FF4,W
1036:  ADDWFC 03,F
1038:  MOVLW  00
103A:  ADDWFC 02,F
103C:  ADDWFC 01,F
103E:  MOVF   xC2,W
1040:  MULWF  xC5
1042:  MOVF   FF3,W
1044:  ADDWF  03,F
1046:  MOVF   FF4,W
1048:  ADDWFC 02,F
104A:  MOVLW  00
104C:  ADDWFC 01,F
104E:  MOVF   xC1,W
1050:  MULWF  xC5
1052:  MOVF   FF3,W
1054:  ADDWF  02,F
1056:  MOVF   FF4,W
1058:  ADDWFC 01,F
105A:  INCF   00,F
105C:  BTFSC  01.7
105E:  BRA    106A
1060:  RLCF   xC9,F
1062:  RLCF   03,F
1064:  RLCF   02,F
1066:  RLCF   01,F
1068:  DECF   00,F
106A:  MOVLW  00
106C:  BTFSS  xC9.7
106E:  BRA    1084
1070:  INCF   03,F
1072:  ADDWFC 02,F
1074:  ADDWFC 01,F
1076:  MOVF   01,W
1078:  BNZ   1084
107A:  MOVF   02,W
107C:  BNZ   1084
107E:  MOVF   03,W
1080:  BNZ   1084
1082:  INCF   00,F
1084:  BTFSC  xC8.7
1086:  BSF    01.7
1088:  BTFSS  xC8.7
108A:  BCF    01.7
108C:  BRA    1096
108E:  CLRF   00
1090:  CLRF   01
1092:  CLRF   02
1094:  CLRF   03
1096:  MOVLB  0
1098:  RETURN 0
109A:  MOVLW  80
109C:  BTFSS  FD8.1
109E:  BRA    10A4
10A0:  MOVLB  6
10A2:  XORWF  xA3,F
10A4:  MOVLB  6
10A6:  CLRF   xA8
10A8:  CLRF   xA9
10AA:  MOVFF  69F,6A7
10AE:  MOVF   xA3,W
10B0:  XORWF  xA7,F
10B2:  MOVF   x9E,W
10B4:  BTFSC  FD8.2
10B6:  BRA    1276
10B8:  MOVWF  xA6
10BA:  MOVWF  00
10BC:  MOVF   xA2,W
10BE:  BTFSC  FD8.2
10C0:  BRA    1288
10C2:  SUBWF  xA6,F
10C4:  BTFSC  FD8.2
10C6:  BRA    11CE
10C8:  BNC   1146
10CA:  MOVFF  6A3,6AC
10CE:  BSF    xAC.7
10D0:  MOVFF  6A4,6AB
10D4:  MOVFF  6A5,6AA
10D8:  CLRF   xA9
10DA:  BCF    FD8.0
10DC:  RRCF   xAC,F
10DE:  RRCF   xAB,F
10E0:  RRCF   xAA,F
10E2:  RRCF   xA9,F
10E4:  DECFSZ xA6,F
10E6:  BRA    10D8
10E8:  BTFSS  xA7.7
10EA:  BRA    10F2
10EC:  BSF    xA8.0
10EE:  BRA    12B0
10F0:  BCF    xA8.0
10F2:  BCF    xA6.0
10F4:  BSF    xA8.4
10F6:  MOVLW  06
10F8:  MOVWF  FEA
10FA:  MOVLW  A1
10FC:  MOVWF  FE9
10FE:  BRA    12D6
1100:  BCF    xA8.4
1102:  BTFSC  xA7.7
1104:  BRA    111A
1106:  BTFSS  xA6.0
1108:  BRA    1130
110A:  RRCF   xAC,F
110C:  RRCF   xAB,F
110E:  RRCF   xAA,F
1110:  RRCF   xA9,F
1112:  INCF   00,F
1114:  BTFSC  FD8.2
1116:  BRA    12A6
1118:  BRA    1130
111A:  BTFSC  xAC.7
111C:  BRA    1136
111E:  BCF    FD8.0
1120:  RLCF   xA9,F
1122:  RLCF   xAA,F
1124:  RLCF   xAB,F
1126:  RLCF   xAC,F
1128:  DECF   00,F
112A:  BTFSC  FD8.2
112C:  BRA    12A6
112E:  BRA    111A
1130:  BSF    xA8.6
1132:  BRA    120E
1134:  BCF    xA8.6
1136:  MOVFF  69F,6A7
113A:  BTFSS  x9F.7
113C:  BRA    1142
113E:  BSF    xAC.7
1140:  BRA    1298
1142:  BCF    xAC.7
1144:  BRA    1298
1146:  MOVFF  6A2,6A6
114A:  MOVFF  6A2,00
114E:  MOVF   x9E,W
1150:  SUBWF  xA6,F
1152:  MOVFF  69F,6AC
1156:  BSF    xAC.7
1158:  MOVFF  6A0,6AB
115C:  MOVFF  6A1,6AA
1160:  CLRF   xA9
1162:  BCF    FD8.0
1164:  RRCF   xAC,F
1166:  RRCF   xAB,F
1168:  RRCF   xAA,F
116A:  RRCF   xA9,F
116C:  DECFSZ xA6,F
116E:  BRA    1160
1170:  BTFSS  xA7.7
1172:  BRA    117A
1174:  BSF    xA8.1
1176:  BRA    12B0
1178:  BCF    xA8.1
117A:  BCF    xA6.0
117C:  BSF    xA8.5
117E:  MOVLW  06
1180:  MOVWF  FEA
1182:  MOVLW  A5
1184:  MOVWF  FE9
1186:  BRA    12D6
1188:  BCF    xA8.5
118A:  BTFSC  xA7.7
118C:  BRA    11A2
118E:  BTFSS  xA6.0
1190:  BRA    11B8
1192:  RRCF   xAC,F
1194:  RRCF   xAB,F
1196:  RRCF   xAA,F
1198:  RRCF   xA9,F
119A:  INCF   00,F
119C:  BTFSC  FD8.2
119E:  BRA    12A6
11A0:  BRA    11B8
11A2:  BTFSC  xAC.7
11A4:  BRA    11BE
11A6:  BCF    FD8.0
11A8:  RLCF   xA9,F
11AA:  RLCF   xAA,F
11AC:  RLCF   xAB,F
11AE:  RLCF   xAC,F
11B0:  DECF   00,F
11B2:  BTFSC  FD8.2
11B4:  BRA    12A6
11B6:  BRA    11A2
11B8:  BSF    xA8.7
11BA:  BRA    120E
11BC:  BCF    xA8.7
11BE:  MOVFF  6A3,6A7
11C2:  BTFSS  xA3.7
11C4:  BRA    11CA
11C6:  BSF    xAC.7
11C8:  BRA    1298
11CA:  BCF    xAC.7
11CC:  BRA    1298
11CE:  MOVFF  6A3,6AC
11D2:  BSF    xAC.7
11D4:  MOVFF  6A4,6AB
11D8:  MOVFF  6A5,6AA
11DC:  BTFSS  xA7.7
11DE:  BRA    11E8
11E0:  BCF    xAC.7
11E2:  BSF    xA8.2
11E4:  BRA    12B0
11E6:  BCF    xA8.2
11E8:  CLRF   xA9
11EA:  BCF    xA6.0
11EC:  MOVLW  06
11EE:  MOVWF  FEA
11F0:  MOVLW  A1
11F2:  MOVWF  FE9
11F4:  BRA    12D6
11F6:  BTFSC  xA7.7
11F8:  BRA    1232
11FA:  MOVFF  69F,6A7
11FE:  BTFSS  xA6.0
1200:  BRA    120E
1202:  RRCF   xAC,F
1204:  RRCF   xAB,F
1206:  RRCF   xAA,F
1208:  RRCF   xA9,F
120A:  INCF   00,F
120C:  BZ    12A6
120E:  BTFSS  xA9.7
1210:  BRA    1228
1212:  INCF   xAA,F
1214:  BNZ   1228
1216:  INCF   xAB,F
1218:  BNZ   1228
121A:  INCF   xAC,F
121C:  BNZ   1228
121E:  RRCF   xAC,F
1220:  RRCF   xAB,F
1222:  RRCF   xAA,F
1224:  INCF   00,F
1226:  BZ    12A6
1228:  BTFSC  xA8.6
122A:  BRA    1134
122C:  BTFSC  xA8.7
122E:  BRA    11BC
1230:  BRA    126A
1232:  MOVLW  80
1234:  XORWF  xAC,F
1236:  BTFSS  xAC.7
1238:  BRA    1242
123A:  BRA    12B0
123C:  MOVFF  6A3,6A7
1240:  BRA    1256
1242:  MOVFF  69F,6A7
1246:  MOVF   xAC,F
1248:  BNZ   1256
124A:  MOVF   xAB,F
124C:  BNZ   1256
124E:  MOVF   xAA,F
1250:  BNZ   1256
1252:  CLRF   00
1254:  BRA    1298
1256:  BTFSC  xAC.7
1258:  BRA    126A
125A:  BCF    FD8.0
125C:  RLCF   xA9,F
125E:  RLCF   xAA,F
1260:  RLCF   xAB,F
1262:  RLCF   xAC,F
1264:  DECFSZ 00,F
1266:  BRA    1256
1268:  BRA    12A6
126A:  BTFSS  xA7.7
126C:  BRA    1272
126E:  BSF    xAC.7
1270:  BRA    1298
1272:  BCF    xAC.7
1274:  BRA    1298
1276:  MOVFF  6A2,00
127A:  MOVFF  6A3,6AC
127E:  MOVFF  6A4,6AB
1282:  MOVFF  6A5,6AA
1286:  BRA    1298
1288:  MOVFF  69E,00
128C:  MOVFF  69F,6AC
1290:  MOVFF  6A0,6AB
1294:  MOVFF  6A1,6AA
1298:  MOVFF  6AC,01
129C:  MOVFF  6AB,02
12A0:  MOVFF  6AA,03
12A4:  BRA    130E
12A6:  CLRF   00
12A8:  CLRF   01
12AA:  CLRF   02
12AC:  CLRF   03
12AE:  BRA    130E
12B0:  CLRF   xA9
12B2:  COMF   xAA,F
12B4:  COMF   xAB,F
12B6:  COMF   xAC,F
12B8:  COMF   xA9,F
12BA:  INCF   xA9,F
12BC:  BNZ   12C8
12BE:  INCF   xAA,F
12C0:  BNZ   12C8
12C2:  INCF   xAB,F
12C4:  BNZ   12C8
12C6:  INCF   xAC,F
12C8:  BTFSC  xA8.0
12CA:  BRA    10F0
12CC:  BTFSC  xA8.1
12CE:  BRA    1178
12D0:  BTFSC  xA8.2
12D2:  BRA    11E6
12D4:  BRA    123C
12D6:  MOVF   FEF,W
12D8:  ADDWF  xAA,F
12DA:  BNC   12E6
12DC:  INCF   xAB,F
12DE:  BNZ   12E6
12E0:  INCF   xAC,F
12E2:  BTFSC  FD8.2
12E4:  BSF    xA6.0
12E6:  MOVF   FED,F
12E8:  MOVF   FEF,W
12EA:  ADDWF  xAB,F
12EC:  BNC   12F4
12EE:  INCF   xAC,F
12F0:  BTFSC  FD8.2
12F2:  BSF    xA6.0
12F4:  MOVF   FED,F
12F6:  MOVF   FEF,W
12F8:  BTFSC  FEF.7
12FA:  BRA    12FE
12FC:  XORLW  80
12FE:  ADDWF  xAC,F
1300:  BTFSC  FD8.0
1302:  BSF    xA6.0
1304:  BTFSC  xA8.4
1306:  BRA    1100
1308:  BTFSC  xA8.5
130A:  BRA    1188
130C:  BRA    11F6
130E:  MOVLB  0
1310:  RETURN 0
1312:  MOVFF  69F,6A6
1316:  MOVLB  6
1318:  MOVF   xA3,W
131A:  XORWF  xA6,F
131C:  BTFSS  xA6.7
131E:  BRA    132A
1320:  BCF    FD8.2
1322:  BCF    FD8.0
1324:  BTFSC  x9F.7
1326:  BSF    FD8.0
1328:  BRA    1388
132A:  MOVFF  69F,6A6
132E:  MOVFF  6A2,6A7
1332:  MOVF   x9E,W
1334:  SUBWF  xA7,F
1336:  BZ    1344
1338:  BTFSS  xA6.7
133A:  BRA    1388
133C:  MOVF   FD8,W
133E:  XORLW  01
1340:  MOVWF  FD8
1342:  BRA    1388
1344:  MOVFF  6A3,6A7
1348:  MOVF   x9F,W
134A:  SUBWF  xA7,F
134C:  BZ    135A
134E:  BTFSS  xA6.7
1350:  BRA    1388
1352:  MOVF   FD8,W
1354:  XORLW  01
1356:  MOVWF  FD8
1358:  BRA    1388
135A:  MOVFF  6A4,6A7
135E:  MOVF   xA0,W
1360:  SUBWF  xA7,F
1362:  BZ    1370
1364:  BTFSS  xA6.7
1366:  BRA    1388
1368:  MOVF   FD8,W
136A:  XORLW  01
136C:  MOVWF  FD8
136E:  BRA    1388
1370:  MOVFF  6A5,6A7
1374:  MOVF   xA1,W
1376:  SUBWF  xA7,F
1378:  BZ    1386
137A:  BTFSS  xA6.7
137C:  BRA    1388
137E:  MOVF   FD8,W
1380:  XORLW  01
1382:  MOVWF  FD8
1384:  BRA    1388
1386:  BCF    FD8.0
1388:  MOVLB  0
138A:  RETURN 0
138C:  MOVLB  6
138E:  MOVF   xC0,W
1390:  SUBLW  B6
1392:  MOVWF  xC0
1394:  CLRF   03
1396:  MOVFF  6C1,6C4
139A:  BSF    xC1.7
139C:  BCF    FD8.0
139E:  RRCF   xC1,F
13A0:  RRCF   xC2,F
13A2:  RRCF   xC3,F
13A4:  RRCF   03,F
13A6:  RRCF   02,F
13A8:  RRCF   01,F
13AA:  RRCF   00,F
13AC:  DECFSZ xC0,F
13AE:  BRA    139C
13B0:  BTFSS  xC4.7
13B2:  BRA    13CA
13B4:  COMF   00,F
13B6:  COMF   01,F
13B8:  COMF   02,F
13BA:  COMF   03,F
13BC:  INCF   00,F
13BE:  BTFSC  FD8.2
13C0:  INCF   01,F
13C2:  BTFSC  FD8.2
13C4:  INCF   02,F
13C6:  BTFSC  FD8.2
13C8:  INCF   03,F
13CA:  MOVLB  0
13CC:  GOTO   14BA (RETURN)
13D0:  BTFSC  FD8.1
13D2:  BRA    13DC
13D4:  MOVLW  06
13D6:  MOVWF  FEA
13D8:  MOVLW  C8
13DA:  MOVWF  FE9
13DC:  CLRF   00
13DE:  CLRF   01
13E0:  CLRF   02
13E2:  CLRF   03
13E4:  MOVLB  6
13E6:  CLRF   xC8
13E8:  CLRF   xC9
13EA:  CLRF   xCA
13EC:  CLRF   xCB
13EE:  MOVF   xC7,W
13F0:  IORWF  xC6,W
13F2:  IORWF  xC5,W
13F4:  IORWF  xC4,W
13F6:  BZ    1450
13F8:  MOVLW  20
13FA:  MOVWF  xCC
13FC:  BCF    FD8.0
13FE:  RLCF   xC0,F
1400:  RLCF   xC1,F
1402:  RLCF   xC2,F
1404:  RLCF   xC3,F
1406:  RLCF   xC8,F
1408:  RLCF   xC9,F
140A:  RLCF   xCA,F
140C:  RLCF   xCB,F
140E:  MOVF   xC7,W
1410:  SUBWF  xCB,W
1412:  BNZ   1424
1414:  MOVF   xC6,W
1416:  SUBWF  xCA,W
1418:  BNZ   1424
141A:  MOVF   xC5,W
141C:  SUBWF  xC9,W
141E:  BNZ   1424
1420:  MOVF   xC4,W
1422:  SUBWF  xC8,W
1424:  BNC   1444
1426:  MOVF   xC4,W
1428:  SUBWF  xC8,F
142A:  MOVF   xC5,W
142C:  BTFSS  FD8.0
142E:  INCFSZ xC5,W
1430:  SUBWF  xC9,F
1432:  MOVF   xC6,W
1434:  BTFSS  FD8.0
1436:  INCFSZ xC6,W
1438:  SUBWF  xCA,F
143A:  MOVF   xC7,W
143C:  BTFSS  FD8.0
143E:  INCFSZ xC7,W
1440:  SUBWF  xCB,F
1442:  BSF    FD8.0
1444:  RLCF   00,F
1446:  RLCF   01,F
1448:  RLCF   02,F
144A:  RLCF   03,F
144C:  DECFSZ xCC,F
144E:  BRA    13FC
1450:  MOVFF  6C8,FEF
1454:  MOVFF  6C9,FEC
1458:  MOVFF  6CA,FEC
145C:  MOVFF  6CB,FEC
1460:  MOVLB  0
1462:  RETURN 0
1464:  MOVF   FE9,W
1466:  MOVLB  6
1468:  MOVWF  xB8
146A:  MOVF   xB7,W
146C:  MOVWF  xBA
146E:  BZ    14A6
1470:  MOVFF  6B6,6C3
1474:  MOVFF  6B5,6C2
1478:  MOVFF  6B4,6C1
147C:  MOVFF  6B3,6C0
1480:  CLRF   xC7
1482:  CLRF   xC6
1484:  MOVLW  20
1486:  MOVWF  xC5
1488:  MOVLW  82
148A:  MOVWF  xC4
148C:  MOVLB  0
148E:  RCALL  0FA4
1490:  MOVFF  03,6B6
1494:  MOVFF  02,6B5
1498:  MOVFF  01,6B4
149C:  MOVFF  00,6B3
14A0:  MOVLB  6
14A2:  DECFSZ xBA,F
14A4:  BRA    1470
14A6:  MOVFF  6B6,6C3
14AA:  MOVFF  6B5,6C2
14AE:  MOVFF  6B4,6C1
14B2:  MOVFF  6B3,6C0
14B6:  MOVLB  0
14B8:  BRA    138C
14BA:  MOVFF  03,6B6
14BE:  MOVFF  02,6B5
14C2:  MOVFF  01,6B4
14C6:  MOVFF  00,6B3
14CA:  MOVLB  6
14CC:  BTFSS  xB6.7
14CE:  BRA    14EA
14D0:  DECF   xB8,F
14D2:  BSF    xB8.5
14D4:  COMF   xB3,F
14D6:  COMF   xB4,F
14D8:  COMF   xB5,F
14DA:  COMF   xB6,F
14DC:  INCF   xB3,F
14DE:  BTFSC  FD8.2
14E0:  INCF   xB4,F
14E2:  BTFSC  FD8.2
14E4:  INCF   xB5,F
14E6:  BTFSC  FD8.2
14E8:  INCF   xB6,F
14EA:  MOVLW  3B
14EC:  MOVWF  xBF
14EE:  MOVLW  9A
14F0:  MOVWF  xBE
14F2:  MOVLW  CA
14F4:  MOVWF  xBD
14F6:  CLRF   xBC
14F8:  MOVLW  0A
14FA:  MOVWF  xBA
14FC:  MOVF   xB7,W
14FE:  BTFSC  FD8.2
1500:  INCF   xB8,F
1502:  BSF    FD8.1
1504:  MOVLW  06
1506:  MOVWF  FEA
1508:  MOVLW  B3
150A:  MOVWF  FE9
150C:  MOVFF  6B6,6C3
1510:  MOVFF  6B5,6C2
1514:  MOVFF  6B4,6C1
1518:  MOVFF  6B3,6C0
151C:  MOVFF  6BF,6C7
1520:  MOVFF  6BE,6C6
1524:  MOVFF  6BD,6C5
1528:  MOVFF  6BC,6C4
152C:  MOVLB  0
152E:  RCALL  13D0
1530:  MOVF   01,W
1532:  MOVF   00,F
1534:  BNZ   155C
1536:  MOVLB  6
1538:  INCF   xB7,W
153A:  SUBWF  xBA,W
153C:  BTFSS  FD8.2
153E:  BRA    1544
1540:  MOVLB  0
1542:  BRA    155C
1544:  MOVF   xB8,W
1546:  BZ    1562
1548:  ANDLW  0F
154A:  SUBWF  xBA,W
154C:  BZ    1550
154E:  BC    15DE
1550:  BTFSC  xB8.7
1552:  BRA    15DE
1554:  BTFSC  xB8.6
1556:  BRA    1562
1558:  MOVLW  20
155A:  BRA    15D0
155C:  MOVLW  20
155E:  MOVLB  6
1560:  ANDWF  xB8,F
1562:  BTFSS  xB8.5
1564:  BRA    1586
1566:  BCF    xB8.5
1568:  MOVF   xB7,W
156A:  BTFSS  FD8.2
156C:  DECF   xB8,F
156E:  MOVF   00,W
1570:  MOVWF  xB8
1572:  MOVLW  2D
1574:  MOVLB  7
1576:  MOVWF  x1A
1578:  MOVLB  0
157A:  CALL   0AE6
157E:  MOVLB  6
1580:  MOVF   xB8,W
1582:  MOVWF  00
1584:  CLRF   xB8
1586:  MOVF   xB7,W
1588:  SUBWF  xBA,W
158A:  BNZ   15A8
158C:  MOVF   00,W
158E:  MOVWF  xB8
1590:  MOVLW  2E
1592:  MOVLB  7
1594:  MOVWF  x1A
1596:  MOVLB  0
1598:  CALL   0AE6
159C:  MOVLB  6
159E:  MOVF   xB8,W
15A0:  MOVWF  00
15A2:  MOVLW  20
15A4:  ANDWF  xB8,F
15A6:  MOVLW  00
15A8:  MOVLW  30
15AA:  BTFSS  xB8.5
15AC:  BRA    15D0
15AE:  BCF    xB8.5
15B0:  MOVF   xB7,W
15B2:  BTFSS  FD8.2
15B4:  DECF   xB8,F
15B6:  MOVF   00,W
15B8:  MOVWF  xB8
15BA:  MOVLW  2D
15BC:  MOVLB  7
15BE:  MOVWF  x1A
15C0:  MOVLB  0
15C2:  CALL   0AE6
15C6:  MOVLB  6
15C8:  MOVF   xB8,W
15CA:  MOVWF  00
15CC:  CLRF   xB8
15CE:  MOVLW  30
15D0:  ADDWF  00,F
15D2:  MOVFF  00,71A
15D6:  MOVLB  0
15D8:  CALL   0AE6
15DC:  MOVLB  6
15DE:  BCF    FD8.1
15E0:  MOVFF  6BF,6C3
15E4:  MOVFF  6BE,6C2
15E8:  MOVFF  6BD,6C1
15EC:  MOVFF  6BC,6C0
15F0:  CLRF   xC7
15F2:  CLRF   xC6
15F4:  CLRF   xC5
15F6:  MOVLW  0A
15F8:  MOVWF  xC4
15FA:  MOVLB  0
15FC:  RCALL  13D0
15FE:  MOVFF  03,6BF
1602:  MOVFF  02,6BE
1606:  MOVFF  01,6BD
160A:  MOVFF  00,6BC
160E:  MOVLB  6
1610:  DECFSZ xBA,F
1612:  BRA    1502
1614:  MOVLB  0
1616:  RETURN 0
*
165E:  MOVF   FEF,F
1660:  BZ    1680
1662:  MOVFF  FEA,69F
1666:  MOVFF  FE9,69E
166A:  MOVFF  FEF,6A0
166E:  RCALL  1618
1670:  MOVFF  69F,FEA
1674:  MOVFF  69E,FE9
1678:  INCF   FE9,F
167A:  BTFSC  FD8.2
167C:  INCF   FEA,F
167E:  BRA    165E
1680:  RETURN 0
*
19C2:  MOVLW  B6
19C4:  MOVWF  00
19C6:  CLRF   03
19C8:  CLRF   02
19CA:  CLRF   01
19CC:  MOVLB  6
19CE:  MOVF   x6B,W
19D0:  IORWF  x6C,W
19D2:  IORWF  x6D,W
19D4:  IORWF  x6E,W
19D6:  BNZ   19DC
19D8:  CLRF   00
19DA:  BRA    19F6
19DC:  BCF    FD8.0
19DE:  BTFSC  01.7
19E0:  BRA    19F4
19E2:  RLCF   x6B,F
19E4:  RLCF   x6C,F
19E6:  RLCF   x6D,F
19E8:  RLCF   x6E,F
19EA:  RLCF   03,F
19EC:  RLCF   02,F
19EE:  RLCF   01,F
19F0:  DECFSZ 00,F
19F2:  BRA    19DC
19F4:  BCF    01.7
19F6:  MOVLB  0
19F8:  GOTO   2DF4 (RETURN)
19FC:  TBLRD*+
19FE:  MOVF   FF5,F
1A00:  BZ    1A1A
1A02:  MOVFF  FF6,66B
1A06:  MOVFF  FF7,66C
1A0A:  MOVFF  FF5,6A0
1A0E:  RCALL  1618
1A10:  MOVFF  66B,FF6
1A14:  MOVFF  66C,FF7
1A18:  BRA    19FC
1A1A:  RETURN 0
*
1D8E:  TSTFSZ 01
1D90:  BRA    1D98
1D92:  TSTFSZ 02
1D94:  BRA    1D9A
1D96:  BRA    1DA6
1D98:  INCF   02,F
1D9A:  MOVFF  00,FEE
1D9E:  DECFSZ 01,F
1DA0:  BRA    1D9A
1DA2:  DECFSZ 02,F
1DA4:  BRA    1D9A
1DA6:  RETURN 0
*
22F0:  MOVLB  6
22F2:  CLRF   xCF
22F4:  CLRF   xD0
22F6:  MOVLW  01
22F8:  MOVWF  xD1
22FA:  CLRF   FDA
22FC:  CLRF   FD9
22FE:  MOVLW  06
2300:  MOVWF  xD4
2302:  MOVLW  C7
2304:  MOVWF  xD3
2306:  MOVLW  06
2308:  MOVWF  FEA
230A:  MOVLW  CB
230C:  MOVWF  FE9
230E:  MOVFF  6D4,FE2
2312:  MOVFF  6D3,FE1
2316:  MOVFF  6D1,6D2
231A:  BCF    FD8.0
231C:  MOVF   FE5,W
231E:  MULWF  FEE
2320:  MOVF   FF3,W
2322:  ADDWFC xCF,F
2324:  MOVF   FF4,W
2326:  ADDWFC xD0,F
2328:  DECFSZ xD2,F
232A:  BRA    231A
232C:  MOVFF  6CF,FDE
2330:  MOVFF  6D0,6CF
2334:  CLRF   xD0
2336:  BTFSC  FD8.0
2338:  INCF   xD0,F
233A:  INCF   xD3,F
233C:  BTFSC  FD8.2
233E:  INCF   xD4,F
2340:  INCF   xD1,F
2342:  MOVF   xD1,W
2344:  SUBLW  05
2346:  BNZ   2306
2348:  MOVLB  0
234A:  RETURN 0
*
243E:  MOVF   FE9,W
2440:  MOVLB  6
2442:  MOVWF  xB7
2444:  MOVLW  3B
2446:  MOVWF  xBE
2448:  MOVLW  9A
244A:  MOVWF  xBD
244C:  MOVLW  CA
244E:  MOVWF  xBC
2450:  CLRF   xBB
2452:  MOVLW  0A
2454:  MOVWF  xB9
2456:  BSF    FD8.1
2458:  MOVLW  06
245A:  MOVWF  FEA
245C:  MOVLW  B3
245E:  MOVWF  FE9
2460:  MOVFF  6B6,6C3
2464:  MOVFF  6B5,6C2
2468:  MOVFF  6B4,6C1
246C:  MOVFF  6B3,6C0
2470:  MOVFF  6BE,6C7
2474:  MOVFF  6BD,6C6
2478:  MOVFF  6BC,6C5
247C:  MOVFF  6BB,6C4
2480:  MOVLB  0
2482:  CALL   13D0
2486:  MOVF   01,W
2488:  MOVF   00,F
248A:  BNZ   24B2
248C:  MOVLB  6
248E:  MOVF   xB9,W
2490:  XORLW  01
2492:  BTFSS  FD8.2
2494:  BRA    249A
2496:  MOVLB  0
2498:  BRA    24B2
249A:  MOVF   xB7,W
249C:  BZ    24B6
249E:  ANDLW  0F
24A0:  SUBWF  xB9,W
24A2:  BZ    24A6
24A4:  BC    24C6
24A6:  BTFSC  xB7.7
24A8:  BRA    24C6
24AA:  BTFSC  xB7.6
24AC:  BRA    24B6
24AE:  MOVLW  20
24B0:  BRA    24B8
24B2:  MOVLB  6
24B4:  CLRF   xB7
24B6:  MOVLW  30
24B8:  ADDWF  00,F
24BA:  MOVFF  00,71A
24BE:  MOVLB  0
24C0:  CALL   0AE6
24C4:  MOVLB  6
24C6:  BCF    FD8.1
24C8:  MOVFF  6BE,6C3
24CC:  MOVFF  6BD,6C2
24D0:  MOVFF  6BC,6C1
24D4:  MOVFF  6BB,6C0
24D8:  CLRF   xC7
24DA:  CLRF   xC6
24DC:  CLRF   xC5
24DE:  MOVLW  0A
24E0:  MOVWF  xC4
24E2:  MOVLB  0
24E4:  CALL   13D0
24E8:  MOVFF  03,6BE
24EC:  MOVFF  02,6BD
24F0:  MOVFF  01,6BC
24F4:  MOVFF  00,6BB
24F8:  MOVLB  6
24FA:  DECFSZ xB9,F
24FC:  BRA    2456
24FE:  MOVLB  0
2500:  RETURN 0
2502:  MOVLB  6
2504:  MOVF   xB6,W
2506:  CLRF   01
2508:  SUBWF  xB5,W
250A:  BC    2512
250C:  MOVFF  6B5,00
2510:  BRA    252A
2512:  CLRF   00
2514:  MOVLW  08
2516:  MOVWF  xB7
2518:  RLCF   xB5,F
251A:  RLCF   00,F
251C:  MOVF   xB6,W
251E:  SUBWF  00,W
2520:  BTFSC  FD8.0
2522:  MOVWF  00
2524:  RLCF   01,F
2526:  DECFSZ xB7,F
2528:  BRA    2518
252A:  MOVLB  0
252C:  RETURN 0
252E:  MOVF   01,W
2530:  MOVFF  6B3,6B5
2534:  MOVLW  64
2536:  MOVLB  6
2538:  MOVWF  xB6
253A:  MOVLB  0
253C:  RCALL  2502
253E:  MOVFF  00,6B3
2542:  MOVF   01,W
2544:  MOVLW  30
2546:  BNZ   2558
2548:  MOVLB  6
254A:  BTFSS  xB4.1
254C:  BRA    256E
254E:  BTFSC  xB4.3
2550:  BRA    256E
2552:  BTFSC  xB4.4
2554:  MOVLW  20
2556:  BRA    2560
2558:  MOVLB  6
255A:  BCF    xB4.3
255C:  BCF    xB4.4
255E:  BSF    xB4.0
2560:  ADDWF  01,F
2562:  MOVFF  01,71A
2566:  MOVLB  0
2568:  CALL   0AE6
256C:  MOVLB  6
256E:  MOVFF  6B3,6B5
2572:  MOVLW  0A
2574:  MOVWF  xB6
2576:  MOVLB  0
2578:  RCALL  2502
257A:  MOVFF  00,6B3
257E:  MOVF   01,W
2580:  MOVLW  30
2582:  BNZ   2594
2584:  MOVLB  6
2586:  BTFSC  xB4.3
2588:  BRA    25A0
258A:  BTFSS  xB4.0
258C:  BRA    25A0
258E:  BTFSC  xB4.4
2590:  MOVLW  20
2592:  MOVLB  0
2594:  ADDWF  01,F
2596:  MOVFF  01,71A
259A:  CALL   0AE6
259E:  MOVLB  6
25A0:  MOVLW  30
25A2:  ADDWF  xB3,F
25A4:  MOVFF  6B3,71A
25A8:  MOVLB  0
25AA:  CALL   0AE6
25AE:  GOTO   2C70 (RETURN)
*
2F96:  TBLRD*+
2F98:  MOVFF  FF6,69C
2F9C:  MOVFF  FF7,69D
2FA0:  MOVFF  FF5,6A0
2FA4:  CALL   1618
2FA8:  MOVFF  69C,FF6
2FAC:  MOVFF  69D,FF7
2FB0:  MOVLB  6
2FB2:  DECFSZ x9B,F
2FB4:  BRA    2FB8
2FB6:  BRA    2FBC
2FB8:  MOVLB  0
2FBA:  BRA    2F96
2FBC:  MOVLB  0
2FBE:  RETURN 0
2FC0:  MOVF   01,W
2FC2:  MOVFF  69B,6B5
2FC6:  MOVLW  64
2FC8:  MOVLB  6
2FCA:  MOVWF  xB6
2FCC:  MOVLB  0
2FCE:  CALL   2502
2FD2:  MOVFF  00,69B
2FD6:  MOVF   01,W
2FD8:  MOVLW  30
2FDA:  BNZ   2FEC
2FDC:  MOVLB  6
2FDE:  BTFSS  x9C.1
2FE0:  BRA    3002
2FE2:  BTFSC  x9C.3
2FE4:  BRA    3002
2FE6:  BTFSC  x9C.4
2FE8:  MOVLW  20
2FEA:  BRA    2FF4
2FEC:  MOVLB  6
2FEE:  BCF    x9C.3
2FF0:  BCF    x9C.4
2FF2:  BSF    x9C.0
2FF4:  ADDWF  01,F
2FF6:  MOVFF  01,6A0
2FFA:  MOVLB  0
2FFC:  CALL   1618
3000:  MOVLB  6
3002:  MOVFF  69B,6B5
3006:  MOVLW  0A
3008:  MOVWF  xB6
300A:  MOVLB  0
300C:  CALL   2502
3010:  MOVFF  00,69B
3014:  MOVF   01,W
3016:  MOVLW  30
3018:  BNZ   302A
301A:  MOVLB  6
301C:  BTFSC  x9C.3
301E:  BRA    3036
3020:  BTFSS  x9C.0
3022:  BRA    3036
3024:  BTFSC  x9C.4
3026:  MOVLW  20
3028:  MOVLB  0
302A:  ADDWF  01,F
302C:  MOVFF  01,6A0
3030:  CALL   1618
3034:  MOVLB  6
3036:  MOVLW  30
3038:  ADDWF  x9B,F
303A:  MOVFF  69B,6A0
303E:  MOVLB  0
3040:  CALL   1618
3044:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,NOPROTECT,NOLVP,MCLR,HSPLL,PLL4 
.................... #device PASS_STRINGS=IN_RAM,adc=10 
.................... #use delay(clock=16000000) 
*
0ABC:  MOVLW  07
0ABE:  MOVWF  FEA
0AC0:  MOVLW  26
0AC2:  MOVWF  FE9
0AC4:  MOVF   FEF,W
0AC6:  BZ    0AE4
0AC8:  MOVLW  05
0ACA:  MOVWF  01
0ACC:  CLRF   00
0ACE:  DECFSZ 00,F
0AD0:  BRA    0ACE
0AD2:  DECFSZ 01,F
0AD4:  BRA    0ACC
0AD6:  MOVLW  2E
0AD8:  MOVWF  00
0ADA:  DECFSZ 00,F
0ADC:  BRA    0ADA
0ADE:  BRA    0AE0
0AE0:  DECFSZ FEF,F
0AE2:  BRA    0AC8
0AE4:  RETURN 0
.................... #use rs232(uart1,baud=115200, xmit=PIN_C6, rcv=PIN_C7, stream = SIM800L_SERIAL, ERRORS) 
*
05C6:  BTFSS  F9E.5
05C8:  BRA    05C6
05CA:  MOVFF  FAB,16
05CE:  MOVFF  FAE,01
05D2:  BTFSS  16.1
05D4:  BRA    05DA
05D6:  BCF    FAB.4
05D8:  BSF    FAB.4
05DA:  RETURN 0
*
0C0C:  BTFSS  F9E.4
0C0E:  BRA    0C0C
0C10:  MOVWF  FAD
0C12:  GOTO   0C8C (RETURN)
.................... #use rs232(baud=9600, xmit=PIN_B2, rcv=PIN_B3, stream = MONITOR_SERIAL) 
*
1618:  BCF    F93.2
161A:  BCF    F8A.2
161C:  MOVLW  08
161E:  MOVWF  01
1620:  BRA    1622
1622:  NOP   
1624:  BSF    01.7
1626:  BRA    1648
1628:  BCF    01.7
162A:  MOVLB  6
162C:  RRCF   xA0,F
162E:  MOVLB  0
1630:  BTFSC  FD8.0
1632:  BSF    F8A.2
1634:  BTFSS  FD8.0
1636:  BCF    F8A.2
1638:  BSF    01.6
163A:  BRA    1648
163C:  BCF    01.6
163E:  DECFSZ 01,F
1640:  BRA    162A
1642:  BRA    1644
1644:  NOP   
1646:  BSF    F8A.2
1648:  MOVLW  84
164A:  MOVWF  FE9
164C:  DECFSZ FE9,F
164E:  BRA    164C
1650:  BRA    1652
1652:  NOP   
1654:  BTFSC  01.7
1656:  BRA    1628
1658:  BTFSC  01.6
165A:  BRA    163C
165C:  RETURN 0
.................... #use fast_io (ALL) 
.................... #priority ext,rda, rtcc, 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0B7E:  MOVFF  729,03
0B82:  MOVLB  7
0B84:  MOVFF  728,FE9
0B88:  MOVFF  729,FEA
0B8C:  MOVF   FEF,F
0B8E:  BZ    0C02
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0B90:  MOVFF  729,72D
0B94:  MOVFF  728,72C
0B98:  MOVFF  72B,72F
0B9C:  MOVFF  72A,72E
0BA0:  MOVFF  72F,03
0BA4:  MOVFF  72E,FE9
0BA8:  MOVFF  72F,FEA
0BAC:  MOVF   FEF,F
0BAE:  BZ    0BDC
0BB0:  MOVFF  72C,FE9
0BB4:  MOVFF  72D,FEA
0BB8:  MOVFF  FEF,730
0BBC:  MOVFF  72F,03
0BC0:  MOVFF  72E,FE9
0BC4:  MOVFF  72F,FEA
0BC8:  MOVF   FEF,W
0BCA:  SUBWF  x30,W
0BCC:  BNZ   0BDC
0BCE:  INCF   x2C,F
0BD0:  BTFSC  FD8.2
0BD2:  INCF   x2D,F
0BD4:  INCF   x2E,F
0BD6:  BTFSC  FD8.2
0BD8:  INCF   x2F,F
0BDA:  BRA    0BA0
....................  
....................       if (*t == '\0') 
0BDC:  MOVFF  72F,03
0BE0:  MOVFF  72E,FE9
0BE4:  MOVFF  03,FEA
0BE8:  MOVF   FEF,F
0BEA:  BNZ   0BF6
....................          return s1; 
0BEC:  MOVFF  728,01
0BF0:  MOVFF  729,02
0BF4:  BRA    0C08
....................       ++s1; 
0BF6:  INCF   x28,F
0BF8:  BTFSC  FD8.2
0BFA:  INCF   x29,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0BFC:  MOVLB  0
0BFE:  BRA    0B7E
0C00:  MOVLB  7
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
0C02:  MOVLW  00
0C04:  MOVWF  01
0C06:  MOVWF  02
0C08:  MOVLB  0
0C0A:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam); 
.................... void Calcula_SOC(); 
.................... void Obtem_SOH(); 
.................... void le_EEPROM (void); 
....................  
.................... #ENDIF 
....................  
.................... #include "SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
.................... #include"Serial.h" 
.................... #IFNDEF SERIAL_H 
.................... #DEFINE SERIAL_H 
....................  
.................... #define  SMS_COMMAND             1 
.................... #define  SMS_READ_COMMAND        2            
....................  
.................... void Executa_Comando(char comando); 
.................... char Get_Comando(); 
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao); 
.................... void get_numero(int nro_caracteres, int posicao, char *destino); 
.................... void clear_command(); 
....................  
.................... #include"Serial.c" 
.................... #include"SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
....................  
.................... #ENDIF 
....................  
.................... #include"TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam); 
.................... void Calcula_SOC(); 
.................... void Obtem_SOH(); 
.................... void le_EEPROM (void); 
....................  
.................... #ENDIF 
....................  
.................... #include"numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
.................... void obtem_numero(int8 pos_num, char *numero); 
....................  
.................... #include"numeros.c" 
.................... char numeros[50]; 
.................... extern int8 qtd_numeros; 
.................... char *posicao_numero; 
....................  
.................... int1 insere_numero(char *numero){ // >+5531995822739>+5531995822739>+5531995822739 
*
1C32:  MOVF   4F,W
1C34:  MULLW  0F
1C36:  MOVFF  FF3,6B5
1C3A:  MOVLB  6
1C3C:  CLRF   xB6
....................   
....................   int8 index = qtd_numeros*15; 
....................   int8 index_2 = 0; 
....................  
....................   if(qtd_numeros == 3){ 
1C3E:  MOVF   4F,W
1C40:  SUBLW  03
1C42:  BNZ   1C4A
....................  
....................     return 0; 
1C44:  MOVLW  00
1C46:  MOVWF  01
1C48:  BRA    1CEE
....................  
....................   } 
....................  
....................   posicao_numero = strstr(numeros,numero); 
1C4A:  MOVLB  7
1C4C:  CLRF   x29
1C4E:  MOVLW  1D
1C50:  MOVWF  x28
1C52:  MOVFF  6B4,72B
1C56:  MOVFF  6B3,72A
1C5A:  MOVLB  0
1C5C:  CALL   0B7E
1C60:  MOVFF  02,51
1C64:  MOVFF  01,50
....................    
....................   if(posicao_numero == 0){ 
1C68:  MOVF   50,F
1C6A:  BNZ   1CE8
1C6C:  MOVF   51,F
1C6E:  BNZ   1CE8
....................  
....................     numeros[index] ='>'; 
1C70:  CLRF   03
1C72:  MOVLB  6
1C74:  MOVF   xB5,W
1C76:  ADDLW  1D
1C78:  MOVWF  FE9
1C7A:  MOVLW  00
1C7C:  ADDWFC 03,W
1C7E:  MOVWF  FEA
1C80:  MOVLW  3E
1C82:  MOVWF  FEF
....................      
....................     for(index = index+1;numero[index_2]!='\0';index++){ 
1C84:  MOVLW  01
1C86:  ADDWF  xB5,F
1C88:  CLRF   03
1C8A:  MOVF   xB6,W
1C8C:  ADDWF  xB3,W
1C8E:  MOVWF  FE9
1C90:  MOVF   xB4,W
1C92:  ADDWFC 03,W
1C94:  MOVWF  FEA
1C96:  MOVF   FEF,F
1C98:  BZ    1CCE
....................       
....................       numeros[index] = numero[index_2]; 
1C9A:  CLRF   03
1C9C:  MOVF   xB5,W
1C9E:  ADDLW  1D
1CA0:  MOVWF  01
1CA2:  MOVLW  00
1CA4:  ADDWFC 03,F
1CA6:  MOVFF  03,6B8
1CAA:  CLRF   03
1CAC:  MOVF   xB6,W
1CAE:  ADDWF  xB3,W
1CB0:  MOVWF  FE9
1CB2:  MOVF   xB4,W
1CB4:  ADDWFC 03,W
1CB6:  MOVWF  FEA
1CB8:  MOVFF  FEF,6B9
1CBC:  MOVFF  6B8,FEA
1CC0:  MOVFF  01,FE9
1CC4:  MOVFF  6B9,FEF
....................       index_2++; 
1CC8:  INCF   xB6,F
1CCA:  INCF   xB5,F
1CCC:  BRA    1C88
....................         
....................     } 
....................     numeros[index]='\0'; 
1CCE:  CLRF   03
1CD0:  MOVF   xB5,W
1CD2:  ADDLW  1D
1CD4:  MOVWF  FE9
1CD6:  MOVLW  00
1CD8:  ADDWFC 03,W
1CDA:  MOVWF  FEA
1CDC:  CLRF   FEF
....................     qtd_numeros++; 
1CDE:  INCF   4F,F
....................     return 1; 
1CE0:  MOVLW  01
1CE2:  MOVWF  01
1CE4:  BRA    1CEE
1CE6:  MOVLB  0
....................    
....................   } 
....................   return 0; 
1CE8:  MOVLW  00
1CEA:  MOVWF  01
1CEC:  MOVLB  6
1CEE:  MOVLB  0
1CF0:  GOTO   26F8 (RETURN)
.................... } 
....................  
.................... void obtem_numero(int8 pos_num, char *numero){ 
*
2F38:  MOVLB  6
2F3A:  CLRF   x9D
2F3C:  CLRF   x9E
....................  
....................   int8 index = 0; 
....................   int8 index_2 = 0; 
....................  
....................   if(pos_num>qtd_numeros) return; 
2F3E:  MOVF   x9A,W
2F40:  SUBWF  4F,W
2F42:  BTFSS  FD8.0
2F44:  BRA    2F90
....................  
....................   for(index = ((pos_num*15)+1); index<(pos_num+1)*15;index++){ 
2F46:  MOVF   x9A,W
2F48:  MULLW  0F
2F4A:  MOVF   FF3,W
2F4C:  ADDLW  01
2F4E:  MOVWF  x9D
2F50:  MOVLW  01
2F52:  ADDWF  x9A,W
2F54:  MULLW  0F
2F56:  MOVF   FF3,W
2F58:  SUBWF  x9D,W
2F5A:  BC    2F90
....................  
....................     numero[index_2] = numeros[index]; 
2F5C:  CLRF   03
2F5E:  MOVF   x9E,W
2F60:  ADDWF  x9B,W
2F62:  MOVWF  01
2F64:  MOVF   x9C,W
2F66:  ADDWFC 03,F
2F68:  MOVFF  03,6A0
2F6C:  CLRF   03
2F6E:  MOVF   x9D,W
2F70:  ADDLW  1D
2F72:  MOVWF  FE9
2F74:  MOVLW  00
2F76:  ADDWFC 03,W
2F78:  MOVWF  FEA
2F7A:  MOVFF  FEF,6A1
2F7E:  MOVFF  6A0,FEA
2F82:  MOVFF  01,FE9
2F86:  MOVFF  6A1,FEF
....................     index_2++; 
2F8A:  INCF   x9E,F
2F8C:  INCF   x9D,F
2F8E:  BRA    2F50
....................   }   
....................    
....................   return; 
2F90:  MOVLB  0
2F92:  GOTO   30F8 (RETURN)
....................  
.................... } 
....................  
.................... void limpa_numeros(){ 
....................  
....................   qtd_numeros = 0; 
*
1DA8:  CLRF   4F
....................   memset (numeros, 0x00, sizeof(numeros)); 
1DAA:  CLRF   FEA
1DAC:  MOVLW  1D
1DAE:  MOVWF  FE9
1DB0:  CLRF   00
1DB2:  CLRF   02
1DB4:  MOVLW  32
1DB6:  MOVWF  01
1DB8:  RCALL  1D8E
1DBA:  GOTO   27BC (RETURN)
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include "Memory.h" 
.................... #IFNDEF MEMORY_H 
.................... #DEFINE MEMORY_H 
....................  
.................... //*********************************** ENDERECOS EEPROM *******************************************  
....................  
.................... #define ADDR_tempo_entre_alertas              getenv("EEPROM_ADDRESS") + 0  //int32 
.................... #define ADDR_tempo_ultimo_alerta              getenv("EEPROM_ADDRESS") + 4  //int32 
.................... #define ADDR_corrente_limite                  getenv("EEPROM_ADDRESS") + 8  //int32 
.................... #define ADDR_zero_set                         getenv("EEPROM_ADDRESS") + 12 //int32 
.................... #define ADDR_qtd_numeros                      getenv("EEPROM_ADDRESS") + 16 //int8 
.................... #define ADDR_vector_numeros                   getenv("EEPROM_ADDRESS") + 17 //Vetor int 8 com 50 posicoes 
....................  
.................... //************************************************************************************************* 
....................  
.................... //************************************ DEAFULT EEPROM ********************************************* 
....................  
.................... #rom int32 ADDR_tempo_entre_alertas = {0} 
.................... #rom int32 ADDR_tempo_ultimo_alerta = {0}  
.................... #rom int32 ADDR_corrente_limite = {0}  
.................... #rom int32 ADDR_zero_set = {0}  
.................... #rom int8  ADDR_qtd_numeros = {0}  
.................... #rom int8  ADDR_vector_numeros = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} 
....................  
.................... //************************************************************************************************* 
....................  
....................  
.................... void read_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
.................... void write_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
....................  
.................... #include "Memory.c" 
.................... void write_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count) { 
....................     
....................   address -= getenv("EEPROM_ADDRESS"); 
*
1CF4:  MOVLW  00
1CF6:  MOVLB  6
1CF8:  SUBWF  xB3,F
1CFA:  SUBWFB xB4,F
1CFC:  MOVLW  F0
1CFE:  SUBWFB xB5,F
1D00:  MOVLW  00
1D02:  SUBWFB xB6,F
....................   for(int8 i = 0; i < count; i++) { 
1D04:  CLRF   xBA
1D06:  MOVF   xB9,W
1D08:  SUBWF  xBA,W
1D0A:  BC    1D8A
....................     if(read_eeprom(address) != dataptr[i]) { 
1D0C:  MOVFF  FF2,6BB
1D10:  BCF    FF2.7
1D12:  MOVFF  6B3,FA9
1D16:  BCF    FA6.6
1D18:  BCF    FA6.7
1D1A:  BSF    FA6.0
1D1C:  MOVF   FA8,W
1D1E:  BTFSC  xBB.7
1D20:  BSF    FF2.7
1D22:  MOVWF  xBC
1D24:  CLRF   03
1D26:  MOVF   xBA,W
1D28:  ADDWF  xB7,W
1D2A:  MOVWF  FE9
1D2C:  MOVF   xB8,W
1D2E:  ADDWFC 03,W
1D30:  MOVWF  FEA
1D32:  MOVF   FEF,W
1D34:  SUBWF  xBC,W
1D36:  BZ    1D76
....................        write_eeprom(address, dataptr[i]); 
1D38:  CLRF   03
1D3A:  MOVF   xBA,W
1D3C:  ADDWF  xB7,W
1D3E:  MOVWF  FE9
1D40:  MOVF   xB8,W
1D42:  ADDWFC 03,W
1D44:  MOVWF  FEA
1D46:  MOVFF  FEF,6BB
1D4A:  MOVF   FF2,W
1D4C:  MOVWF  00
1D4E:  BCF    FF2.7
1D50:  MOVFF  6B3,FA9
1D54:  MOVFF  6BB,FA8
1D58:  BCF    FA6.6
1D5A:  BCF    FA6.7
1D5C:  BSF    FA6.2
1D5E:  MOVLB  F
1D60:  MOVLW  55
1D62:  MOVWF  FA7
1D64:  MOVLW  AA
1D66:  MOVWF  FA7
1D68:  BSF    FA6.1
1D6A:  BTFSC  FA6.1
1D6C:  BRA    1D6A
1D6E:  BCF    FA6.2
1D70:  MOVF   00,W
1D72:  IORWF  FF2,F
1D74:  MOVLB  6
....................     } 
....................     address++; 
1D76:  MOVLW  01
1D78:  ADDWF  xB3,F
1D7A:  BTFSC  FD8.0
1D7C:  INCF   xB4,F
1D7E:  BTFSC  FD8.2
1D80:  INCF   xB5,F
1D82:  BTFSC  FD8.2
1D84:  INCF   xB6,F
1D86:  INCF   xBA,F
1D88:  BRA    1D06
....................   } 
1D8A:  MOVLB  0
1D8C:  RETURN 0
....................     
.................... } 
....................  
.................... void read_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count) { 
....................     
....................   address -= getenv("EEPROM_ADDRESS"); 
*
09B4:  MOVLW  00
09B6:  MOVLB  6
09B8:  SUBWF  x5A,F
09BA:  SUBWFB x5B,F
09BC:  MOVLW  F0
09BE:  SUBWFB x5C,F
09C0:  MOVLW  00
09C2:  SUBWFB x5D,F
....................   for(int8 i = 0; i < count; i++) { 
09C4:  CLRF   x61
09C6:  MOVF   x60,W
09C8:  SUBWF  x61,W
09CA:  BC    0A06
....................     dataptr[i] = read_eeprom(address); 
09CC:  CLRF   03
09CE:  MOVF   x61,W
09D0:  ADDWF  x5E,W
09D2:  MOVWF  FE9
09D4:  MOVF   x5F,W
09D6:  ADDWFC 03,W
09D8:  MOVWF  FEA
09DA:  MOVFF  FF2,664
09DE:  BCF    FF2.7
09E0:  MOVFF  65A,FA9
09E4:  BCF    FA6.6
09E6:  BCF    FA6.7
09E8:  BSF    FA6.0
09EA:  MOVF   FA8,W
09EC:  BTFSC  x64.7
09EE:  BSF    FF2.7
09F0:  MOVWF  FEF
....................     address++; 
09F2:  MOVLW  01
09F4:  ADDWF  x5A,F
09F6:  BTFSC  FD8.0
09F8:  INCF   x5B,F
09FA:  BTFSC  FD8.2
09FC:  INCF   x5C,F
09FE:  BTFSC  FD8.2
0A00:  INCF   x5D,F
0A02:  INCF   x61,F
0A04:  BRA    09C6
....................   } 
0A06:  MOVLB  0
0A08:  RETURN 0
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define   UART_BUFFER_SIZE         150 
....................  
.................... char comando_recibido_UART[UART_BUFFER_SIZE]; 
.................... char comando_recibido_BUFF [UART_BUFFER_SIZE]; 
.................... int *posicao_valor_comando = 0; 
.................... int16 timeout_trama_UART = 100000; 
.................... extern int1 comando_disponivel_UART; 
.................... extern int32 corrente_limite; 
.................... extern int32 tempo_entre_alertas; 
.................... extern float aux_corrente; 
.................... extern float aux_tensao; 
.................... extern float zero_set; 
.................... extern float zero_set_aux; 
....................  
.................... #INT_RDA  
.................... void recepcao_UART() 
*
05DC:  MOVLW  01
05DE:  MOVLB  7
05E0:  MOVWF  x31
.................... { 
....................  int i = 1; 
....................  int8 caracterRx; 
....................    if(kbhit(SIM800L_SERIAL) && comando_disponivel_UART == 0) { 
05E2:  BTFSS  F9E.5
05E4:  BRA    068C
05E6:  MOVLB  1
05E8:  BTFSS  x82.0
05EA:  BRA    05F0
05EC:  MOVLB  7
05EE:  BRA    068C
....................       caracterRx = getc(SIM800L_SERIAL); 
05F0:  MOVLB  0
05F2:  RCALL  05C6
05F4:  MOVFF  01,732
....................       if(caracterRx == '>'||caracterRx == '+' ||caracterRx =='\n'||caracterRx =='\r') { 
05F8:  MOVLB  7
05FA:  MOVF   x32,W
05FC:  SUBLW  3E
05FE:  BZ    0612
0600:  MOVF   x32,W
0602:  SUBLW  2B
0604:  BZ    0612
0606:  MOVF   x32,W
0608:  SUBLW  0A
060A:  BZ    0612
060C:  MOVF   x32,W
060E:  SUBLW  0D
0610:  BNZ   068C
....................         comando_recibido_UART[0] = caracterRx; 
0612:  MOVFF  732,52
....................         while(i < (UART_BUFFER_SIZE-2) && timeout_trama_UART > 0) { 
0616:  MOVF   x31,W
0618:  SUBLW  93
061A:  BNC   066E
061C:  MOVLB  1
061E:  MOVF   x80,F
0620:  BNZ   062C
0622:  MOVF   x81,F
0624:  BTFSS  FD8.2
0626:  BRA    062C
0628:  MOVLB  7
062A:  BRA    066E
....................            if(kbhit(SIM800L_SERIAL)) { 
062C:  BTFSS  F9E.5
062E:  BRA    0662
....................              caracterRx = getc(SIM800L_SERIAL); 
0630:  MOVLB  0
0632:  RCALL  05C6
0634:  MOVFF  01,732
....................              comando_recibido_UART[i] = caracterRx; 
0638:  CLRF   03
063A:  MOVLB  7
063C:  MOVF   x31,W
063E:  ADDLW  52
0640:  MOVWF  FE9
0642:  MOVLW  00
0644:  ADDWFC 03,W
0646:  MOVWF  FEA
0648:  MOVFF  732,FEF
....................              if(caracterRx == ';') {  
064C:  MOVF   x32,W
064E:  SUBLW  3B
0650:  BNZ   0656
....................                i++; 
0652:  INCF   x31,F
....................                break; 
0654:  BRA    066E
....................              } 
....................              i++; 
0656:  INCF   x31,F
....................              timeout_trama_UART = 100000; 
0658:  MOVLW  86
065A:  MOVLB  1
065C:  MOVWF  x81
065E:  MOVLW  A0
0660:  MOVWF  x80
....................            } 
....................            timeout_trama_UART--; 
0662:  MOVF   x80,W
0664:  BTFSC  FD8.2
0666:  DECF   x81,F
0668:  DECF   x80,F
066A:  MOVLB  7
066C:  BRA    0616
....................         } 
....................         comando_disponivel_UART = 1; 
066E:  MOVLB  1
0670:  BSF    x82.0
....................         timeout_trama_UART = 100000; 
0672:  MOVLW  86
0674:  MOVWF  x81
0676:  MOVLW  A0
0678:  MOVWF  x80
....................         comando_recibido_UART[i] = 0; 
067A:  CLRF   03
067C:  MOVLB  7
067E:  MOVF   x31,W
0680:  ADDLW  52
0682:  MOVWF  FE9
0684:  MOVLW  00
0686:  ADDWFC 03,W
0688:  MOVWF  FEA
068A:  CLRF   FEF
....................       } 
....................    } 
....................   return; 
068C:  BCF    F9E.5
068E:  MOVLB  0
0690:  GOTO   006C
.................... } 
....................  
.................... char Get_Comando() 
.................... { 
....................   char CMD[15]; 
....................   strcpy (comando_recibido_BUFF, comando_recibido_UART);                            
*
1A64:  CLRF   FEA
1A66:  MOVLW  E8
1A68:  MOVWF  FE9
1A6A:  CLRF   FE2
1A6C:  MOVLW  52
1A6E:  MOVWF  FE1
1A70:  MOVF   FE7,F
1A72:  MOVFF  FE6,FEE
1A76:  BNZ   1A70
....................   strcpy (CMD, "+CMTI"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_COMMAND); 
1A78:  MOVLW  06
1A7A:  MOVWF  FEA
1A7C:  MOVLW  6B
1A7E:  MOVWF  FE9
1A80:  MOVFF  FF2,67A
1A84:  BCF    FF2.7
1A86:  MOVLW  00
1A88:  CALL   00AE
1A8C:  TBLRD*-
1A8E:  TBLRD*+
1A90:  MOVF   FF5,W
1A92:  MOVWF  FEE
1A94:  IORLW  00
1A96:  BNZ   1A8E
1A98:  MOVLB  6
1A9A:  BTFSC  x7A.7
1A9C:  BSF    FF2.7
1A9E:  MOVLB  7
1AA0:  CLRF   x29
1AA2:  MOVLW  E8
1AA4:  MOVWF  x28
1AA6:  MOVLW  06
1AA8:  MOVWF  x2B
1AAA:  MOVLW  6B
1AAC:  MOVWF  x2A
1AAE:  MOVLB  0
1AB0:  CALL   0B7E
1AB4:  MOVFF  02,17F
1AB8:  MOVFF  01,17E
1ABC:  MOVLB  1
1ABE:  MOVF   x7E,F
1AC0:  BNZ   1AC6
1AC2:  MOVF   x7F,F
1AC4:  BZ    1ACC
1AC6:  MOVLW  01
1AC8:  MOVWF  01
1ACA:  BRA    1B26
....................   strcpy (CMD, "+CMGL"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_READ_COMMAND); 
1ACC:  MOVLW  06
1ACE:  MOVWF  FEA
1AD0:  MOVLW  6B
1AD2:  MOVWF  FE9
1AD4:  MOVFF  FF2,67A
1AD8:  BCF    FF2.7
1ADA:  MOVLW  00
1ADC:  MOVLB  0
1ADE:  CALL   00CE
1AE2:  TBLRD*-
1AE4:  TBLRD*+
1AE6:  MOVF   FF5,W
1AE8:  MOVWF  FEE
1AEA:  IORLW  00
1AEC:  BNZ   1AE4
1AEE:  MOVLB  6
1AF0:  BTFSC  x7A.7
1AF2:  BSF    FF2.7
1AF4:  MOVLB  7
1AF6:  CLRF   x29
1AF8:  MOVLW  E8
1AFA:  MOVWF  x28
1AFC:  MOVLW  06
1AFE:  MOVWF  x2B
1B00:  MOVLW  6B
1B02:  MOVWF  x2A
1B04:  MOVLB  0
1B06:  CALL   0B7E
1B0A:  MOVFF  02,17F
1B0E:  MOVFF  01,17E
1B12:  MOVLB  1
1B14:  MOVF   x7E,F
1B16:  BNZ   1B1C
1B18:  MOVF   x7F,F
1B1A:  BZ    1B22
1B1C:  MOVLW  02
1B1E:  MOVWF  01
1B20:  BRA    1B26
....................  
....................   return(0); 
1B22:  MOVLW  00
1B24:  MOVWF  01
1B26:  MOVLB  0
1B28:  RETURN 0
.................... } 
....................  
....................  
.................... void Executa_Comando(char comando){ 
....................  
....................   char CMD[15]; 
....................   char numero[20]; 
....................  
....................   disable_interrupts(GLOBAL); 
*
25B2:  BCF    FF2.6
25B4:  BCF    FF2.7
25B6:  BTFSC  FF2.7
25B8:  BRA    25B4
....................    
....................   switch(comando){ 
25BA:  MOVLB  6
25BC:  MOVF   x6B,W
25BE:  XORLW  01
25C0:  MOVLB  0
25C2:  BZ    25CC
25C4:  XORLW  03
25C6:  BZ    25D4
25C8:  GOTO   2D84
....................       
....................     case SMS_COMMAND:       //+CMTI: "SM",10<CR><LF> 
....................       Read_SMS(); 
25CC:  GOTO   1B2A
....................     break; 
25D0:  GOTO   2D84
....................  
....................     case SMS_READ_COMMAND:  //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/13,21:57:54-12"<CR><LF> 
....................  
....................       strcpy (CMD, "OITAI");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); 
25D4:  MOVLW  06
25D6:  MOVWF  FEA
25D8:  MOVLW  6C
25DA:  MOVWF  FE9
25DC:  MOVFF  FF2,6B3
25E0:  BCF    FF2.7
25E2:  MOVLW  00
25E4:  CALL   00EE
25E8:  TBLRD*-
25EA:  TBLRD*+
25EC:  MOVF   FF5,W
25EE:  MOVWF  FEE
25F0:  IORLW  00
25F2:  BNZ   25EA
25F4:  MOVLB  6
25F6:  BTFSC  xB3.7
25F8:  BSF    FF2.7
25FA:  MOVLB  7
25FC:  CLRF   x29
25FE:  MOVLW  E8
2600:  MOVWF  x28
2602:  MOVLW  06
2604:  MOVWF  x2B
2606:  MOVLW  6C
2608:  MOVWF  x2A
260A:  MOVLB  0
260C:  CALL   0B7E
2610:  MOVFF  02,17F
2614:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2618:  MOVLB  1
261A:  MOVF   x7E,F
261C:  BNZ   2622
261E:  MOVF   x7F,F
2620:  BZ    2680
....................  
....................         get_numero(14,25,numero); 
2622:  MOVLW  0E
2624:  MOVLB  6
2626:  MOVWF  xB3
2628:  MOVLW  19
262A:  MOVWF  xB4
262C:  MOVLW  06
262E:  MOVWF  xB6
2630:  MOVLW  7B
2632:  MOVWF  xB5
2634:  MOVLB  0
2636:  CALL   1BDE
....................         Send_SMS(numero,"HEARTBEAT()"); 
263A:  MOVLW  06
263C:  MOVWF  FEA
263E:  MOVLW  8F
2640:  MOVWF  FE9
2642:  MOVFF  FF2,6B3
2646:  BCF    FF2.7
2648:  MOVLW  0C
264A:  MOVWF  01
264C:  CLRF   FF7
264E:  MOVLW  00
2650:  CALL   010E
2654:  TBLRD*-
2656:  TBLRD*+
2658:  MOVFF  FF5,FEE
265C:  DECFSZ 01,F
265E:  BRA    2656
2660:  MOVLB  6
2662:  BTFSC  xB3.7
2664:  BSF    FF2.7
2666:  MOVLW  06
2668:  MOVWF  xD9
266A:  MOVLW  7B
266C:  MOVWF  xD8
266E:  MOVLW  06
2670:  MOVWF  xDB
2672:  MOVLW  8F
2674:  MOVWF  xDA
2676:  MOVLB  0
2678:  CALL   0D06
....................         break; 
267C:  BRA    2D84
267E:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMADD");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/14,00:28:46-12"nr+NUMADD+5531995422738<CR><LF> 
2680:  MOVLW  06
2682:  MOVWF  FEA
2684:  MOVLW  6C
2686:  MOVWF  FE9
2688:  MOVFF  FF2,6B3
268C:  BCF    FF2.7
268E:  MOVLW  00
2690:  MOVLB  0
2692:  CALL   0134
2696:  TBLRD*-
2698:  TBLRD*+
269A:  MOVF   FF5,W
269C:  MOVWF  FEE
269E:  IORLW  00
26A0:  BNZ   2698
26A2:  MOVLB  6
26A4:  BTFSC  xB3.7
26A6:  BSF    FF2.7
26A8:  MOVLB  7
26AA:  CLRF   x29
26AC:  MOVLW  E8
26AE:  MOVWF  x28
26B0:  MOVLW  06
26B2:  MOVWF  x2B
26B4:  MOVLW  6C
26B6:  MOVWF  x2A
26B8:  MOVLB  0
26BA:  CALL   0B7E
26BE:  MOVFF  02,17F
26C2:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
26C6:  MOVLB  1
26C8:  MOVF   x7E,F
26CA:  BNZ   26D0
26CC:  MOVF   x7F,F
26CE:  BZ    2766
....................          
....................         get_numero(14,75,numero); 
26D0:  MOVLW  0E
26D2:  MOVLB  6
26D4:  MOVWF  xB3
26D6:  MOVLW  4B
26D8:  MOVWF  xB4
26DA:  MOVLW  06
26DC:  MOVWF  xB6
26DE:  MOVLW  7B
26E0:  MOVWF  xB5
26E2:  MOVLB  0
26E4:  CALL   1BDE
....................         insere_numero(numero); 
26E8:  MOVLW  06
26EA:  MOVLB  6
26EC:  MOVWF  xB4
26EE:  MOVLW  7B
26F0:  MOVWF  xB3
26F2:  MOVLB  0
26F4:  GOTO   1C32
....................         write_config(ADDR_qtd_numeros,&qtd_numeros,1); 
26F8:  MOVLB  6
26FA:  CLRF   xB6
26FC:  MOVLW  F0
26FE:  MOVWF  xB5
2700:  CLRF   xB4
2702:  MOVLW  10
2704:  MOVWF  xB3
2706:  CLRF   xB8
2708:  MOVLW  4F
270A:  MOVWF  xB7
270C:  MOVLW  01
270E:  MOVWF  xB9
2710:  MOVLB  0
2712:  CALL   1CF4
....................         write_config(ADDR_vector_numeros,&numeros,50); 
2716:  MOVLB  6
2718:  CLRF   xB6
271A:  MOVLW  F0
271C:  MOVWF  xB5
271E:  CLRF   xB4
2720:  MOVLW  11
2722:  MOVWF  xB3
2724:  CLRF   xB8
2726:  MOVLW  1D
2728:  MOVWF  xB7
272A:  MOVLW  32
272C:  MOVWF  xB9
272E:  MOVLB  0
2730:  CALL   1CF4
....................         get_numero(14,25,numero); 
2734:  MOVLW  0E
2736:  MOVLB  6
2738:  MOVWF  xB3
273A:  MOVLW  19
273C:  MOVWF  xB4
273E:  MOVLW  06
2740:  MOVWF  xB6
2742:  MOVLW  7B
2744:  MOVWF  xB5
2746:  MOVLB  0
2748:  CALL   1BDE
....................         Send_SMS(numero,numeros); 
274C:  MOVLW  06
274E:  MOVLB  6
2750:  MOVWF  xD9
2752:  MOVLW  7B
2754:  MOVWF  xD8
2756:  CLRF   xDB
2758:  MOVLW  1D
275A:  MOVWF  xDA
275C:  MOVLB  0
275E:  CALL   0D06
....................         break; 
2762:  BRA    2D84
2764:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMDEL");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+NUMDEL 
2766:  MOVLW  06
2768:  MOVWF  FEA
276A:  MOVLW  6C
276C:  MOVWF  FE9
276E:  MOVFF  FF2,6B3
2772:  BCF    FF2.7
2774:  MOVLW  00
2776:  MOVLB  0
2778:  CALL   0156
277C:  TBLRD*-
277E:  TBLRD*+
2780:  MOVF   FF5,W
2782:  MOVWF  FEE
2784:  IORLW  00
2786:  BNZ   277E
2788:  MOVLB  6
278A:  BTFSC  xB3.7
278C:  BSF    FF2.7
278E:  MOVLB  7
2790:  CLRF   x29
2792:  MOVLW  E8
2794:  MOVWF  x28
2796:  MOVLW  06
2798:  MOVWF  x2B
279A:  MOVLW  6C
279C:  MOVWF  x2A
279E:  MOVLB  0
27A0:  CALL   0B7E
27A4:  MOVFF  02,17F
27A8:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
27AC:  MOVLB  1
27AE:  MOVF   x7E,F
27B0:  BNZ   27B6
27B2:  MOVF   x7F,F
27B4:  BZ    2856
....................           
....................         limpa_numeros();  
27B6:  MOVLB  0
27B8:  GOTO   1DA8
....................         write_config(ADDR_qtd_numeros,&qtd_numeros,1); 
27BC:  MOVLB  6
27BE:  CLRF   xB6
27C0:  MOVLW  F0
27C2:  MOVWF  xB5
27C4:  CLRF   xB4
27C6:  MOVLW  10
27C8:  MOVWF  xB3
27CA:  CLRF   xB8
27CC:  MOVLW  4F
27CE:  MOVWF  xB7
27D0:  MOVLW  01
27D2:  MOVWF  xB9
27D4:  MOVLB  0
27D6:  CALL   1CF4
....................         write_config(ADDR_vector_numeros,&numeros,50); 
27DA:  MOVLB  6
27DC:  CLRF   xB6
27DE:  MOVLW  F0
27E0:  MOVWF  xB5
27E2:  CLRF   xB4
27E4:  MOVLW  11
27E6:  MOVWF  xB3
27E8:  CLRF   xB8
27EA:  MOVLW  1D
27EC:  MOVWF  xB7
27EE:  MOVLW  32
27F0:  MOVWF  xB9
27F2:  MOVLB  0
27F4:  CALL   1CF4
....................         get_numero(14,25,numero); 
27F8:  MOVLW  0E
27FA:  MOVLB  6
27FC:  MOVWF  xB3
27FE:  MOVLW  19
2800:  MOVWF  xB4
2802:  MOVLW  06
2804:  MOVWF  xB6
2806:  MOVLW  7B
2808:  MOVWF  xB5
280A:  MOVLB  0
280C:  CALL   1BDE
....................         Send_SMS(numero,"OK CLEAR ALL"); 
2810:  MOVLW  06
2812:  MOVWF  FEA
2814:  MOVLW  9B
2816:  MOVWF  FE9
2818:  MOVFF  FF2,6B3
281C:  BCF    FF2.7
281E:  MOVLW  0D
2820:  MOVWF  01
2822:  CLRF   FF7
2824:  MOVLW  00
2826:  CALL   0178
282A:  TBLRD*-
282C:  TBLRD*+
282E:  MOVFF  FF5,FEE
2832:  DECFSZ 01,F
2834:  BRA    282C
2836:  MOVLB  6
2838:  BTFSC  xB3.7
283A:  BSF    FF2.7
283C:  MOVLW  06
283E:  MOVWF  xD9
2840:  MOVLW  7B
2842:  MOVWF  xD8
2844:  MOVLW  06
2846:  MOVWF  xDB
2848:  MOVLW  9B
284A:  MOVWF  xDA
284C:  MOVLB  0
284E:  CALL   0D06
....................         break; 
2852:  BRA    2D84
2854:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+GSMLOCATE");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+GSMLOCATE 
2856:  MOVLW  06
2858:  MOVWF  FEA
285A:  MOVLW  6C
285C:  MOVWF  FE9
285E:  MOVFF  FF2,6B3
2862:  BCF    FF2.7
2864:  MOVLW  00
2866:  MOVLB  0
2868:  CALL   01A0
286C:  TBLRD*-
286E:  TBLRD*+
2870:  MOVF   FF5,W
2872:  MOVWF  FEE
2874:  IORLW  00
2876:  BNZ   286E
2878:  MOVLB  6
287A:  BTFSC  xB3.7
287C:  BSF    FF2.7
287E:  MOVLB  7
2880:  CLRF   x29
2882:  MOVLW  E8
2884:  MOVWF  x28
2886:  MOVLW  06
2888:  MOVWF  x2B
288A:  MOVLW  6C
288C:  MOVWF  x2A
288E:  MOVLB  0
2890:  CALL   0B7E
2894:  MOVFF  02,17F
2898:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
289C:  MOVLB  1
289E:  MOVF   x7E,F
28A0:  BNZ   28A6
28A2:  MOVF   x7F,F
28A4:  BZ    28D2
....................           
....................         get_numero(14,25,numero);  
28A6:  MOVLW  0E
28A8:  MOVLB  6
28AA:  MOVWF  xB3
28AC:  MOVLW  19
28AE:  MOVWF  xB4
28B0:  MOVLW  06
28B2:  MOVWF  xB6
28B4:  MOVLW  7B
28B6:  MOVWF  xB5
28B8:  MOVLB  0
28BA:  CALL   1BDE
....................         Get_Locate(numero);  
28BE:  MOVLW  06
28C0:  MOVLB  6
28C2:  MOVWF  xB4
28C4:  MOVLW  7B
28C6:  MOVWF  xB3
28C8:  MOVLB  0
28CA:  GOTO   1F20
....................         break; 
28CE:  BRA    2D84
28D0:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CURLIM");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //rn+CMGL: 1,"REC UNREAD","+5531995822739","","18/11/10,18:12:21-08"rn+CURLIM000001rn 
28D2:  MOVLW  06
28D4:  MOVWF  FEA
28D6:  MOVLW  6C
28D8:  MOVWF  FE9
28DA:  MOVFF  FF2,6B3
28DE:  BCF    FF2.7
28E0:  MOVLW  00
28E2:  MOVLB  0
28E4:  CALL   01C6
28E8:  TBLRD*-
28EA:  TBLRD*+
28EC:  MOVF   FF5,W
28EE:  MOVWF  FEE
28F0:  IORLW  00
28F2:  BNZ   28EA
28F4:  MOVLB  6
28F6:  BTFSC  xB3.7
28F8:  BSF    FF2.7
28FA:  MOVLB  7
28FC:  CLRF   x29
28FE:  MOVLW  E8
2900:  MOVWF  x28
2902:  MOVLW  06
2904:  MOVWF  x2B
2906:  MOVLW  6C
2908:  MOVWF  x2A
290A:  MOVLB  0
290C:  CALL   0B7E
2910:  MOVFF  02,17F
2914:  MOVFF  01,17E
....................  
....................       if(posicao_valor_comando!= 0){ 
2918:  MOVLB  1
291A:  MOVF   x7E,F
291C:  BNZ   2922
291E:  MOVF   x7F,F
2920:  BZ    29F2
....................           
....................         get_numero(14,25,numero); 
2922:  MOVLW  0E
2924:  MOVLB  6
2926:  MOVWF  xB3
2928:  MOVLW  19
292A:  MOVWF  xB4
292C:  MOVLW  06
292E:  MOVWF  xB6
2930:  MOVLW  7B
2932:  MOVWF  xB5
2934:  MOVLB  0
2936:  CALL   1BDE
....................         corrente_limite = get_value(posicao_valor_comando,6,7); //+CURALM001<CR><LF> 
293A:  MOVFF  17F,6B4
293E:  MOVFF  17E,6B3
2942:  MOVLW  06
2944:  MOVLB  6
2946:  MOVWF  xB5
2948:  MOVLW  07
294A:  MOVWF  xB6
294C:  MOVLB  0
294E:  RCALL  234C
2950:  MOVFF  03,186
2954:  MOVFF  02,185
2958:  MOVFF  01,184
295C:  MOVFF  00,183
....................         write_config(ADDR_corrente_limite,&corrente_limite,4); 
2960:  MOVLB  6
2962:  CLRF   xB6
2964:  MOVLW  F0
2966:  MOVWF  xB5
2968:  CLRF   xB4
296A:  MOVLW  08
296C:  MOVWF  xB3
296E:  MOVLW  01
2970:  MOVWF  xB8
2972:  MOVLW  83
2974:  MOVWF  xB7
2976:  MOVLW  04
2978:  MOVWF  xB9
297A:  MOVLB  0
297C:  CALL   1CF4
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2980:  CLRF   FEA
2982:  MOVLW  E8
2984:  MOVWF  FE9
2986:  CLRF   00
2988:  CLRF   02
298A:  MOVLW  96
298C:  MOVWF  01
298E:  CALL   1D8E
....................         sprintf(comando_recibido_BUFF, "Corrente Limite = %Lu mA",corrente_limite); 
2992:  MOVLB  1
2994:  CLRF   x9C
2996:  MOVLW  E8
2998:  MOVWF  x9B
299A:  MOVLW  94
299C:  MOVWF  FF6
299E:  MOVLW  06
29A0:  MOVWF  FF7
29A2:  MOVLW  12
29A4:  MOVLB  7
29A6:  MOVWF  x17
29A8:  MOVLB  0
29AA:  CALL   0B08
29AE:  MOVLW  41
29B0:  MOVWF  FE9
29B2:  MOVFF  186,6B6
29B6:  MOVFF  185,6B5
29BA:  MOVFF  184,6B4
29BE:  MOVFF  183,6B3
29C2:  RCALL  243E
29C4:  MOVLW  A9
29C6:  MOVWF  FF6
29C8:  MOVLW  06
29CA:  MOVWF  FF7
29CC:  MOVLW  03
29CE:  MOVLB  7
29D0:  MOVWF  x17
29D2:  MOVLB  0
29D4:  CALL   0B08
....................         Send_SMS(numero,comando_recibido_BUFF); 
29D8:  MOVLW  06
29DA:  MOVLB  6
29DC:  MOVWF  xD9
29DE:  MOVLW  7B
29E0:  MOVWF  xD8
29E2:  CLRF   xDB
29E4:  MOVLW  E8
29E6:  MOVWF  xDA
29E8:  MOVLB  0
29EA:  CALL   0D06
....................         break; 
29EE:  BRA    2D84
29F0:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CURALM");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //rn+CMGL: 1,"REC UNREAD","+5531995822739","","18/11/10,18:09:52-08"rn+CURALM001rn 
29F2:  MOVLW  06
29F4:  MOVWF  FEA
29F6:  MOVLW  6C
29F8:  MOVWF  FE9
29FA:  MOVFF  FF2,6B3
29FE:  BCF    FF2.7
2A00:  MOVLW  00
2A02:  MOVLB  0
2A04:  CALL   01E8
2A08:  TBLRD*-
2A0A:  TBLRD*+
2A0C:  MOVF   FF5,W
2A0E:  MOVWF  FEE
2A10:  IORLW  00
2A12:  BNZ   2A0A
2A14:  MOVLB  6
2A16:  BTFSC  xB3.7
2A18:  BSF    FF2.7
2A1A:  MOVLB  7
2A1C:  CLRF   x29
2A1E:  MOVLW  E8
2A20:  MOVWF  x28
2A22:  MOVLW  06
2A24:  MOVWF  x2B
2A26:  MOVLW  6C
2A28:  MOVWF  x2A
2A2A:  MOVLB  0
2A2C:  CALL   0B7E
2A30:  MOVFF  02,17F
2A34:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2A38:  MOVLB  1
2A3A:  MOVF   x7E,F
2A3C:  BNZ   2A42
2A3E:  MOVF   x7F,F
2A40:  BZ    2B10
....................           
....................         get_numero(14,25,numero); 
2A42:  MOVLW  0E
2A44:  MOVLB  6
2A46:  MOVWF  xB3
2A48:  MOVLW  19
2A4A:  MOVWF  xB4
2A4C:  MOVLW  06
2A4E:  MOVWF  xB6
2A50:  MOVLW  7B
2A52:  MOVWF  xB5
2A54:  MOVLB  0
2A56:  CALL   1BDE
....................         tempo_entre_alertas = get_value(posicao_valor_comando,3,7); //+CURLIM000001<CR><LF> 
2A5A:  MOVFF  17F,6B4
2A5E:  MOVFF  17E,6B3
2A62:  MOVLW  03
2A64:  MOVLB  6
2A66:  MOVWF  xB5
2A68:  MOVLW  07
2A6A:  MOVWF  xB6
2A6C:  MOVLB  0
2A6E:  RCALL  234C
2A70:  MOVFF  03,18A
2A74:  MOVFF  02,189
2A78:  MOVFF  01,188
2A7C:  MOVFF  00,187
....................         write_config(ADDR_tempo_entre_alertas,&tempo_entre_alertas,4); 
2A80:  MOVLB  6
2A82:  CLRF   xB6
2A84:  MOVLW  F0
2A86:  MOVWF  xB5
2A88:  CLRF   xB4
2A8A:  CLRF   xB3
2A8C:  MOVLW  01
2A8E:  MOVWF  xB8
2A90:  MOVLW  87
2A92:  MOVWF  xB7
2A94:  MOVLW  04
2A96:  MOVWF  xB9
2A98:  MOVLB  0
2A9A:  CALL   1CF4
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2A9E:  CLRF   FEA
2AA0:  MOVLW  E8
2AA2:  MOVWF  FE9
2AA4:  CLRF   00
2AA6:  CLRF   02
2AA8:  MOVLW  96
2AAA:  MOVWF  01
2AAC:  CALL   1D8E
....................         sprintf(comando_recibido_BUFF, "Tempo Entre Alertas = %Lu min",tempo_entre_alertas); 
2AB0:  MOVLB  1
2AB2:  CLRF   x9C
2AB4:  MOVLW  E8
2AB6:  MOVWF  x9B
2AB8:  MOVLW  AE
2ABA:  MOVWF  FF6
2ABC:  MOVLW  06
2ABE:  MOVWF  FF7
2AC0:  MOVLW  16
2AC2:  MOVLB  7
2AC4:  MOVWF  x17
2AC6:  MOVLB  0
2AC8:  CALL   0B08
2ACC:  MOVLW  41
2ACE:  MOVWF  FE9
2AD0:  MOVFF  18A,6B6
2AD4:  MOVFF  189,6B5
2AD8:  MOVFF  188,6B4
2ADC:  MOVFF  187,6B3
2AE0:  RCALL  243E
2AE2:  MOVLW  C7
2AE4:  MOVWF  FF6
2AE6:  MOVLW  06
2AE8:  MOVWF  FF7
2AEA:  MOVLW  04
2AEC:  MOVLB  7
2AEE:  MOVWF  x17
2AF0:  MOVLB  0
2AF2:  CALL   0B08
....................         Send_SMS(numero,comando_recibido_BUFF); 
2AF6:  MOVLW  06
2AF8:  MOVLB  6
2AFA:  MOVWF  xD9
2AFC:  MOVLW  7B
2AFE:  MOVWF  xD8
2B00:  CLRF   xDB
2B02:  MOVLW  E8
2B04:  MOVWF  xDA
2B06:  MOVLB  0
2B08:  CALL   0D06
....................         break; 
2B0C:  BRA    2D84
2B0E:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CSTATS");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CSTATS 
2B10:  MOVLW  06
2B12:  MOVWF  FEA
2B14:  MOVLW  6C
2B16:  MOVWF  FE9
2B18:  MOVFF  FF2,6B3
2B1C:  BCF    FF2.7
2B1E:  MOVLW  00
2B20:  MOVLB  0
2B22:  CALL   020A
2B26:  TBLRD*-
2B28:  TBLRD*+
2B2A:  MOVF   FF5,W
2B2C:  MOVWF  FEE
2B2E:  IORLW  00
2B30:  BNZ   2B28
2B32:  MOVLB  6
2B34:  BTFSC  xB3.7
2B36:  BSF    FF2.7
2B38:  MOVLB  7
2B3A:  CLRF   x29
2B3C:  MOVLW  E8
2B3E:  MOVWF  x28
2B40:  MOVLW  06
2B42:  MOVWF  x2B
2B44:  MOVLW  6C
2B46:  MOVWF  x2A
2B48:  MOVLB  0
2B4A:  CALL   0B7E
2B4E:  MOVFF  02,17F
2B52:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2B56:  MOVLB  1
2B58:  MOVF   x7E,F
2B5A:  BNZ   2B62
2B5C:  MOVF   x7F,F
2B5E:  BTFSC  FD8.2
2B60:  BRA    2CA4
....................           
....................         get_numero(14,25,numero); 
2B62:  MOVLW  0E
2B64:  MOVLB  6
2B66:  MOVWF  xB3
2B68:  MOVLW  19
2B6A:  MOVWF  xB4
2B6C:  MOVLW  06
2B6E:  MOVWF  xB6
2B70:  MOVLW  7B
2B72:  MOVWF  xB5
2B74:  MOVLB  0
2B76:  CALL   1BDE
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2B7A:  CLRF   FEA
2B7C:  MOVLW  E8
2B7E:  MOVWF  FE9
2B80:  CLRF   00
2B82:  CLRF   02
2B84:  MOVLW  96
2B86:  MOVWF  01
2B88:  CALL   1D8E
....................         sprintf(comando_recibido_BUFF, "Tempo Entre Alertas = %Lu min / Corrente Limite = %Lu mA / Corrente Atual: %6.0f mA / Tensao Atual: %2.2f V / Qtd Telefones: %u",tempo_entre_alertas,corrente_limite,aux_corrente,aux_tensao,qtd_numeros); 
2B8C:  MOVLB  1
2B8E:  CLRF   x9C
2B90:  MOVLW  E8
2B92:  MOVWF  x9B
2B94:  MOVLW  CC
2B96:  MOVWF  FF6
2B98:  MOVLW  06
2B9A:  MOVWF  FF7
2B9C:  MOVLW  16
2B9E:  MOVLB  7
2BA0:  MOVWF  x17
2BA2:  MOVLB  0
2BA4:  CALL   0B08
2BA8:  MOVLW  41
2BAA:  MOVWF  FE9
2BAC:  MOVFF  18A,6B6
2BB0:  MOVFF  189,6B5
2BB4:  MOVFF  188,6B4
2BB8:  MOVFF  187,6B3
2BBC:  RCALL  243E
2BBE:  MOVLW  E5
2BC0:  MOVWF  FF6
2BC2:  MOVLW  06
2BC4:  MOVWF  FF7
2BC6:  MOVLW  19
2BC8:  MOVLB  7
2BCA:  MOVWF  x17
2BCC:  MOVLB  0
2BCE:  CALL   0B08
2BD2:  MOVLW  41
2BD4:  MOVWF  FE9
2BD6:  MOVFF  186,6B6
2BDA:  MOVFF  185,6B5
2BDE:  MOVFF  184,6B4
2BE2:  MOVFF  183,6B3
2BE6:  RCALL  243E
2BE8:  MOVLW  01
2BEA:  MOVWF  FF6
2BEC:  MOVLW  07
2BEE:  MOVWF  FF7
2BF0:  MOVLW  16
2BF2:  MOVLB  7
2BF4:  MOVWF  x17
2BF6:  MOVLB  0
2BF8:  CALL   0B08
2BFC:  MOVLW  05
2BFE:  MOVWF  FE9
2C00:  MOVFF  18E,6B6
2C04:  MOVFF  18D,6B5
2C08:  MOVFF  18C,6B4
2C0C:  MOVFF  18B,6B3
2C10:  MOVLB  6
2C12:  CLRF   xB7
2C14:  MOVLB  0
2C16:  CALL   1464
2C1A:  MOVLW  1C
2C1C:  MOVWF  FF6
2C1E:  MOVLW  07
2C20:  MOVWF  FF7
2C22:  MOVLW  14
2C24:  MOVLB  7
2C26:  MOVWF  x17
2C28:  MOVLB  0
2C2A:  CALL   0B08
2C2E:  MOVLW  89
2C30:  MOVWF  FE9
2C32:  MOVFF  192,6B6
2C36:  MOVFF  191,6B5
2C3A:  MOVFF  190,6B4
2C3E:  MOVFF  18F,6B3
2C42:  MOVLW  02
2C44:  MOVLB  6
2C46:  MOVWF  xB7
2C48:  MOVLB  0
2C4A:  CALL   1464
2C4E:  MOVLW  35
2C50:  MOVWF  FF6
2C52:  MOVLW  07
2C54:  MOVWF  FF7
2C56:  MOVLW  14
2C58:  MOVLB  7
2C5A:  MOVWF  x17
2C5C:  MOVLB  0
2C5E:  CALL   0B08
2C62:  MOVFF  4F,6B3
2C66:  MOVLW  1B
2C68:  MOVLB  6
2C6A:  MOVWF  xB4
2C6C:  MOVLB  0
2C6E:  BRA    252E
....................         Send_SMS(numero,comando_recibido_BUFF); 
2C70:  MOVLW  06
2C72:  MOVLB  6
2C74:  MOVWF  xD9
2C76:  MOVLW  7B
2C78:  MOVWF  xD8
2C7A:  CLRF   xDB
2C7C:  MOVLW  E8
2C7E:  MOVWF  xDA
2C80:  MOVLB  0
2C82:  CALL   0D06
....................         if(qtd_numeros>0) Send_SMS(numero,numeros);      
2C86:  MOVF   4F,F
2C88:  BZ    2CA0
2C8A:  MOVLW  06
2C8C:  MOVLB  6
2C8E:  MOVWF  xD9
2C90:  MOVLW  7B
2C92:  MOVWF  xD8
2C94:  CLRF   xDB
2C96:  MOVLW  1D
2C98:  MOVWF  xDA
2C9A:  MOVLB  0
2C9C:  CALL   0D06
....................             
....................         break; 
2CA0:  BRA    2D84
2CA2:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+SETZERO");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+SETZERO 
2CA4:  MOVLW  06
2CA6:  MOVWF  FEA
2CA8:  MOVLW  6C
2CAA:  MOVWF  FE9
2CAC:  MOVFF  FF2,6B3
2CB0:  BCF    FF2.7
2CB2:  MOVLW  00
2CB4:  MOVLB  0
2CB6:  CALL   022C
2CBA:  TBLRD*-
2CBC:  TBLRD*+
2CBE:  MOVF   FF5,W
2CC0:  MOVWF  FEE
2CC2:  IORLW  00
2CC4:  BNZ   2CBC
2CC6:  MOVLB  6
2CC8:  BTFSC  xB3.7
2CCA:  BSF    FF2.7
2CCC:  MOVLB  7
2CCE:  CLRF   x29
2CD0:  MOVLW  E8
2CD2:  MOVWF  x28
2CD4:  MOVLW  06
2CD6:  MOVWF  x2B
2CD8:  MOVLW  6C
2CDA:  MOVWF  x2A
2CDC:  MOVLB  0
2CDE:  CALL   0B7E
2CE2:  MOVFF  02,17F
2CE6:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2CEA:  MOVLB  1
2CEC:  MOVF   x7E,F
2CEE:  BNZ   2CF4
2CF0:  MOVF   x7F,F
2CF2:  BZ    2D82
....................           
....................         get_numero(14,25,numero); 
2CF4:  MOVLW  0E
2CF6:  MOVLB  6
2CF8:  MOVWF  xB3
2CFA:  MOVLW  19
2CFC:  MOVWF  xB4
2CFE:  MOVLW  06
2D00:  MOVWF  xB6
2D02:  MOVLW  7B
2D04:  MOVWF  xB5
2D06:  MOVLB  0
2D08:  CALL   1BDE
....................         zero_set = zero_set_aux;  
2D0C:  MOVFF  19A,196
2D10:  MOVFF  199,195
2D14:  MOVFF  198,194
2D18:  MOVFF  197,193
....................         write_config(ADDR_zero_set,&zero_set,4); 
2D1C:  MOVLB  6
2D1E:  CLRF   xB6
2D20:  MOVLW  F0
2D22:  MOVWF  xB5
2D24:  CLRF   xB4
2D26:  MOVLW  0C
2D28:  MOVWF  xB3
2D2A:  MOVLW  01
2D2C:  MOVWF  xB8
2D2E:  MOVLW  93
2D30:  MOVWF  xB7
2D32:  MOVLW  04
2D34:  MOVWF  xB9
2D36:  MOVLB  0
2D38:  CALL   1CF4
....................         Send_SMS(numero,"ZERO SETED"); 
2D3C:  MOVLW  06
2D3E:  MOVWF  FEA
2D40:  MOVLW  A8
2D42:  MOVWF  FE9
2D44:  MOVFF  FF2,6B3
2D48:  BCF    FF2.7
2D4A:  MOVLW  0B
2D4C:  MOVWF  01
2D4E:  CLRF   FF7
2D50:  MOVLW  00
2D52:  CALL   0250
2D56:  TBLRD*-
2D58:  TBLRD*+
2D5A:  MOVFF  FF5,FEE
2D5E:  DECFSZ 01,F
2D60:  BRA    2D58
2D62:  MOVLB  6
2D64:  BTFSC  xB3.7
2D66:  BSF    FF2.7
2D68:  MOVLW  06
2D6A:  MOVWF  xD9
2D6C:  MOVLW  7B
2D6E:  MOVWF  xD8
2D70:  MOVLW  06
2D72:  MOVWF  xDB
2D74:  MOVLW  A8
2D76:  MOVWF  xDA
2D78:  MOVLB  0
2D7A:  CALL   0D06
....................  
....................         break; 
2D7E:  BRA    2D84
2D80:  MOVLB  1
....................       } 
....................           
....................     break; 
2D82:  MOVLB  0
....................  
....................  
....................   } 
....................  
....................   return; 
2D84:  RETURN 0
....................  
.................... } 
....................  
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao) //get_value(posicao_valor_comando,3,6); 
*
234C:  MOVLB  6
234E:  CLRF   xBA
2350:  CLRF   xB9
2352:  CLRF   xB8
2354:  CLRF   xB7
2356:  CLRF   xBB
2358:  CLRF   xBF
235A:  CLRF   xBE
235C:  CLRF   xBD
235E:  MOVLW  01
2360:  MOVWF  xBC
2362:  CLRF   xC0
.................... { 
....................   int32 valor = 0; 
....................   int i = 0; 
....................   int32 aux = 1; 
....................   int potencia = 0; 
....................  
....................   while(nro_caracteres > 0) 
2364:  MOVF   xB5,F
2366:  BZ    242A
....................   { 
....................     if( pointer_to_string[posicao+i] != '.' ) 
2368:  MOVF   xBB,W
236A:  ADDWF  xB6,W
236C:  CLRF   03
236E:  ADDWF  xB3,W
2370:  MOVWF  FE9
2372:  MOVF   xB4,W
2374:  ADDWFC 03,W
2376:  MOVWF  FEA
2378:  MOVF   FEF,W
237A:  SUBLW  2E
237C:  BZ    2426
....................     { 
....................       nro_caracteres--; 
237E:  DECF   xB5,F
....................       potencia = nro_caracteres; 
2380:  MOVFF  6B5,6C0
....................       aux = 1; 
2384:  CLRF   xBF
2386:  CLRF   xBE
2388:  CLRF   xBD
238A:  MOVLW  01
238C:  MOVWF  xBC
....................       while(potencia > 0) 
238E:  MOVF   xC0,F
2390:  BZ    23C6
....................       { 
....................         aux = aux * 10; 
2392:  MOVFF  6BF,6CA
2396:  MOVFF  6BE,6C9
239A:  MOVFF  6BD,6C8
239E:  MOVFF  6BC,6C7
23A2:  CLRF   xCE
23A4:  CLRF   xCD
23A6:  CLRF   xCC
23A8:  MOVLW  0A
23AA:  MOVWF  xCB
23AC:  MOVLB  0
23AE:  RCALL  22F0
23B0:  MOVFF  03,6BF
23B4:  MOVFF  02,6BE
23B8:  MOVFF  01,6BD
23BC:  MOVFF  00,6BC
....................         potencia--; 
23C0:  MOVLB  6
23C2:  DECF   xC0,F
23C4:  BRA    238E
....................       } 
....................       valor = valor + ((int32)(pointer_to_string[posicao+i]-48)*aux); 
23C6:  MOVF   xBB,W
23C8:  ADDWF  xB6,W
23CA:  CLRF   03
23CC:  ADDWF  xB3,W
23CE:  MOVWF  FE9
23D0:  MOVF   xB4,W
23D2:  ADDWFC 03,W
23D4:  MOVWF  FEA
23D6:  MOVLW  30
23D8:  SUBWF  FEF,W
23DA:  CLRF   xC4
23DC:  CLRF   xC3
23DE:  CLRF   xC2
23E0:  MOVWF  xC1
23E2:  MOVFF  FEA,6C6
23E6:  MOVFF  FE9,6C5
23EA:  MOVFF  6C4,6CA
23EE:  MOVFF  6C3,6C9
23F2:  MOVFF  6C2,6C8
23F6:  MOVWF  xC7
23F8:  MOVFF  6BF,6CE
23FC:  MOVFF  6BE,6CD
2400:  MOVFF  6BD,6CC
2404:  MOVFF  6BC,6CB
2408:  MOVLB  0
240A:  RCALL  22F0
240C:  MOVFF  6C6,FEA
2410:  MOVFF  6C5,FE9
2414:  MOVF   00,W
2416:  MOVLB  6
2418:  ADDWF  xB7,F
241A:  MOVF   01,W
241C:  ADDWFC xB8,F
241E:  MOVF   02,W
2420:  ADDWFC xB9,F
2422:  MOVF   03,W
2424:  ADDWFC xBA,F
....................     } 
....................     i++; 
2426:  INCF   xBB,F
2428:  BRA    2364
....................   } 
....................  
....................   return(valor); 
242A:  MOVFF  6B7,00
242E:  MOVFF  6B8,01
2432:  MOVFF  6B9,02
2436:  MOVFF  6BA,03
243A:  MOVLB  0
243C:  RETURN 0
.................... } 
....................  
.................... void get_numero(int nro_caracteres, int posicao, char *destino){ 
*
1BDE:  MOVLB  6
1BE0:  CLRF   xB7
....................  
....................   int8 index = 0; 
....................  
....................   for(index = 0;index< nro_caracteres;index++){ 
1BE2:  CLRF   xB7
1BE4:  MOVF   xB3,W
1BE6:  SUBWF  xB7,W
1BE8:  BC    1C1E
....................  
....................     destino[index] = comando_recibido_BUFF[index+posicao]; 
1BEA:  CLRF   03
1BEC:  MOVF   xB7,W
1BEE:  ADDWF  xB5,W
1BF0:  MOVWF  01
1BF2:  MOVF   xB6,W
1BF4:  ADDWFC 03,F
1BF6:  MOVFF  03,6B9
1BFA:  MOVF   xB4,W
1BFC:  ADDWF  xB7,W
1BFE:  CLRF   03
1C00:  ADDLW  E8
1C02:  MOVWF  FE9
1C04:  MOVLW  00
1C06:  ADDWFC 03,W
1C08:  MOVWF  FEA
1C0A:  MOVFF  FEF,6BA
1C0E:  MOVFF  6B9,FEA
1C12:  MOVFF  01,FE9
1C16:  MOVFF  6BA,FEF
1C1A:  INCF   xB7,F
1C1C:  BRA    1BE4
....................  
....................   } 
....................  
....................   destino[index] = '\0'; 
1C1E:  CLRF   03
1C20:  MOVF   xB7,W
1C22:  ADDWF  xB5,W
1C24:  MOVWF  FE9
1C26:  MOVF   xB6,W
1C28:  ADDWFC 03,W
1C2A:  MOVWF  FEA
1C2C:  CLRF   FEF
....................  
....................   return; 
1C2E:  MOVLB  0
1C30:  RETURN 0
.................... } 
....................  
.................... void clear_command(){ 
....................  
....................   delay_ms(200); 
*
2D86:  MOVLW  C8
2D88:  MOVLB  7
2D8A:  MOVWF  x26
2D8C:  MOVLB  0
2D8E:  CALL   0ABC
....................   memset (comando_recibido_UART, 0x00, sizeof(comando_recibido_UART)); 
2D92:  CLRF   FEA
2D94:  MOVLW  52
2D96:  MOVWF  FE9
2D98:  CLRF   00
2D9A:  CLRF   02
2D9C:  MOVLW  96
2D9E:  MOVWF  01
2DA0:  CALL   1D8E
....................   memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
2DA4:  CLRF   FEA
2DA6:  MOVLW  E8
2DA8:  MOVWF  FE9
2DAA:  CLRF   00
2DAC:  CLRF   02
2DAE:  MOVLW  96
2DB0:  MOVWF  01
2DB2:  CALL   1D8E
....................  
....................   comando_disponivel_UART = FALSE; 
2DB6:  MOVLB  1
2DB8:  BCF    x82.0
....................   enable_interrupts(GLOBAL); 
2DBA:  MOVLW  C0
2DBC:  IORWF  FF2,F
....................   enable_interrupts(INT_RTCC); 
2DBE:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
2DC0:  BSF    F9D.5
....................    
....................   return; 
2DC2:  MOVLB  0
2DC4:  GOTO   2F30 (RETURN)
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... extern int1 resposta_SIM; 
.................... extern comando_disponivel_UART; 
.................... int32 timeout = 7000000; 
.................... char coordenada[40]; 
....................  
.................... int1 envia_SIM800L(char *send, char *recive){ 
*
0C16:  MOVLW  02
0C18:  MOVLB  7
0C1A:  MOVWF  x1F
....................  
....................   int8 tentativas = 2; 
....................  
....................   disable_interrupts(INT_RTCC);  
0C1C:  BCF    FF2.5
....................   enable_interrupts(INT_RDA);                                               
0C1E:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
0C20:  MOVLW  C0
0C22:  IORWF  FF2,F
....................    
....................   do{ 
....................     timeout = 7000000;   
0C24:  MOVLB  1
0C26:  CLRF   xA0
0C28:  MOVLW  6A
0C2A:  MOVWF  x9F
0C2C:  MOVLW  CF
0C2E:  MOVWF  x9E
0C30:  MOVLW  C0
0C32:  MOVWF  x9D
....................     comando_disponivel_UART = 0; 
0C34:  BCF    x82.0
....................  
....................     fprintf(SIM800L_SERIAL,send);                                             // Envia comando para o SIM800L  
0C36:  MOVFF  71C,FEA
0C3A:  MOVFF  71B,FE9
0C3E:  MOVLB  0
0C40:  BRA    0B56
....................     if(strstr(recive,"+CMGS")!=0){ 
0C42:  MOVLW  2B
0C44:  MOVLB  7
0C46:  MOVWF  x20
0C48:  MOVLW  43
0C4A:  MOVWF  x21
0C4C:  MOVLW  4D
0C4E:  MOVWF  x22
0C50:  MOVLW  47
0C52:  MOVWF  x23
0C54:  MOVLW  53
0C56:  MOVWF  x24
0C58:  CLRF   x25
0C5A:  MOVFF  71E,729
0C5E:  MOVFF  71D,728
0C62:  MOVLW  07
0C64:  MOVWF  x2B
0C66:  MOVLW  20
0C68:  MOVWF  x2A
0C6A:  MOVLB  0
0C6C:  RCALL  0B7E
0C6E:  MOVFF  02,729
0C72:  MOVFF  01,728
0C76:  MOVLB  7
0C78:  MOVF   x28,F
0C7A:  BNZ   0C80
0C7C:  MOVF   x29,F
0C7E:  BZ    0C8E
....................       delay_ms(150); 
0C80:  MOVLW  96
0C82:  MOVWF  x26
0C84:  MOVLB  0
0C86:  RCALL  0ABC
....................       fputc(0x1A,SIM800L_SERIAL); 
0C88:  MOVLW  1A
0C8A:  BRA    0C0C
0C8C:  MOVLB  7
....................     }                                                                                         
....................     while(!comando_disponivel_UART && --timeout > 0);                         // Aguarda o SIM800L responder por ~23 segundos caso nao responda retorna 0 
0C8E:  MOVLB  1
0C90:  BTFSC  x82.0
0C92:  BRA    0CB4
0C94:  MOVLW  FF
0C96:  ADDWF  x9D,F
0C98:  BTFSS  FD8.0
0C9A:  ADDWF  x9E,F
0C9C:  BTFSS  FD8.0
0C9E:  ADDWF  x9F,F
0CA0:  BTFSS  FD8.0
0CA2:  ADDWF  xA0,F
0CA4:  MOVF   x9D,F
0CA6:  BNZ   0C90
0CA8:  MOVF   x9E,F
0CAA:  BNZ   0C90
0CAC:  MOVF   x9F,F
0CAE:  BNZ   0C90
0CB0:  MOVF   xA0,F
0CB2:  BNZ   0C90
....................                           
....................     if(comando_disponivel_UART){                                              // Caso receba a resposta  
0CB4:  BTFSS  x82.0
0CB6:  BRA    0CEE
....................       comando_disponivel_UART = 0;                   
0CB8:  BCF    x82.0
....................       posicao_valor_comando = strstr(comando_recibido_UART,recive);           // Procura a palavra recive da funcao na resposta recebida 
0CBA:  MOVLB  7
0CBC:  CLRF   x29
0CBE:  MOVLW  52
0CC0:  MOVWF  x28
0CC2:  MOVFF  71E,72B
0CC6:  MOVFF  71D,72A
0CCA:  MOVLB  0
0CCC:  RCALL  0B7E
0CCE:  MOVFF  02,17F
0CD2:  MOVFF  01,17E
....................                  
....................       if(posicao_valor_comando!= 0){                                          // Caso encontre a resposta esperada 
0CD6:  MOVLB  1
0CD8:  MOVF   x7E,F
0CDA:  BNZ   0CE0
0CDC:  MOVF   x7F,F
0CDE:  BZ    0CEE
....................         enable_interrupts(INT_RDA); 
0CE0:  BSF    F9D.5
....................         enable_interrupts(INT_RTCC); 
0CE2:  BSF    FF2.5
....................         enable_interrupts(GLOBAL); 
0CE4:  MOVLW  C0
0CE6:  IORWF  FF2,F
....................         return 1; 
0CE8:  MOVLW  01
0CEA:  MOVWF  01
0CEC:  BRA    0D02
....................       } 
....................     } 
....................   }while(--tentativas>0);                 
0CEE:  MOVLB  7
0CF0:  DECFSZ x1F,F
0CF2:  BRA    0C24
....................    
....................   enable_interrupts(GLOBAL); 
0CF4:  MOVLW  C0
0CF6:  IORWF  FF2,F
....................   enable_interrupts(INT_RDA); 
0CF8:  BSF    F9D.5
....................   enable_interrupts(INT_RTCC); 
0CFA:  BSF    FF2.5
....................  
....................   return 0; 
0CFC:  MOVLW  00
0CFE:  MOVWF  01
0D00:  MOVLB  1
0D02:  MOVLB  0
0D04:  RETURN 0
.................... } 
....................  
.................... int1 Send_SMS(char *numero,char *mensagem){ 
....................    
....................   char numero_envio[35]; 
....................  
....................   sprintf(numero_envio,"AT+CMGS=\"%s\"\r\n",numero); 
0D06:  MOVLW  06
0D08:  MOVLB  1
0D0A:  MOVWF  x9C
0D0C:  MOVLW  DC
0D0E:  MOVWF  x9B
0D10:  MOVLW  4C
0D12:  MOVWF  FF6
0D14:  MOVLW  07
0D16:  MOVWF  FF7
0D18:  MOVLW  09
0D1A:  MOVLB  7
0D1C:  MOVWF  x17
0D1E:  MOVLB  0
0D20:  RCALL  0B08
0D22:  MOVFF  6D9,FEA
0D26:  MOVFF  6D8,FE9
0D2A:  BRA    0B30
0D2C:  MOVLW  57
0D2E:  MOVWF  FF6
0D30:  MOVLW  07
0D32:  MOVWF  FF7
0D34:  MOVLW  03
0D36:  MOVLB  7
0D38:  MOVWF  x17
0D3A:  MOVLB  0
0D3C:  RCALL  0B08
....................  
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
0D3E:  MOVLW  06
0D40:  MOVWF  FEA
0D42:  SETF   FE9
0D44:  MOVFF  FF2,717
0D48:  BCF    FF2.7
0D4A:  MOVLW  0C
0D4C:  MOVWF  01
0D4E:  CLRF   FF7
0D50:  MOVLW  00
0D52:  CALL   0276
0D56:  TBLRD*-
0D58:  TBLRD*+
0D5A:  MOVFF  FF5,FEE
0D5E:  DECFSZ 01,F
0D60:  BRA    0D58
0D62:  MOVLB  7
0D64:  BTFSC  x17.7
0D66:  BSF    FF2.7
0D68:  MOVLW  4F
0D6A:  MOVWF  x0B
0D6C:  MOVLW  4B
0D6E:  MOVWF  x0C
0D70:  CLRF   x0D
0D72:  MOVLW  06
0D74:  MOVWF  x1C
0D76:  SETF   x1B
0D78:  MOVLW  07
0D7A:  MOVWF  x1E
0D7C:  MOVLW  0B
0D7E:  MOVWF  x1D
0D80:  MOVLB  0
0D82:  RCALL  0C16
0D84:  MOVF   01,F
0D86:  BZ    0E38
....................     if(envia_SIM800L("AT+CSMP=17,255,0,0\r\n","OK")) 
0D88:  MOVLW  06
0D8A:  MOVWF  FEA
0D8C:  SETF   FE9
0D8E:  MOVFF  FF2,717
0D92:  BCF    FF2.7
0D94:  MOVLW  15
0D96:  MOVWF  01
0D98:  CLRF   FF7
0D9A:  MOVLW  00
0D9C:  CALL   029C
0DA0:  TBLRD*-
0DA2:  TBLRD*+
0DA4:  MOVFF  FF5,FEE
0DA8:  DECFSZ 01,F
0DAA:  BRA    0DA2
0DAC:  MOVLB  7
0DAE:  BTFSC  x17.7
0DB0:  BSF    FF2.7
0DB2:  MOVLW  4F
0DB4:  MOVWF  x14
0DB6:  MOVLW  4B
0DB8:  MOVWF  x15
0DBA:  CLRF   x16
0DBC:  MOVLW  06
0DBE:  MOVWF  x1C
0DC0:  SETF   x1B
0DC2:  MOVLW  07
0DC4:  MOVWF  x1E
0DC6:  MOVLW  14
0DC8:  MOVWF  x1D
0DCA:  MOVLB  0
0DCC:  RCALL  0C16
0DCE:  MOVF   01,F
0DD0:  BZ    0E38
....................       if(envia_SIM800L(numero_envio, ">")) 
0DD2:  MOVLW  3E
0DD4:  MOVLB  6
0DD6:  MOVWF  xFF
0DD8:  MOVLB  7
0DDA:  CLRF   x00
0DDC:  MOVLW  06
0DDE:  MOVWF  x1C
0DE0:  MOVLW  DC
0DE2:  MOVWF  x1B
0DE4:  MOVLW  06
0DE6:  MOVWF  x1E
0DE8:  SETF   x1D
0DEA:  MOVLB  0
0DEC:  RCALL  0C16
0DEE:  MOVF   01,F
0DF0:  BZ    0E38
....................         if(envia_SIM800L(mensagem, "+CMGS:")) 
0DF2:  MOVLW  06
0DF4:  MOVWF  FEA
0DF6:  SETF   FE9
0DF8:  MOVFF  FF2,717
0DFC:  BCF    FF2.7
0DFE:  MOVLW  07
0E00:  MOVWF  01
0E02:  CLRF   FF7
0E04:  MOVLW  00
0E06:  CALL   02CC
0E0A:  TBLRD*-
0E0C:  TBLRD*+
0E0E:  MOVFF  FF5,FEE
0E12:  DECFSZ 01,F
0E14:  BRA    0E0C
0E16:  MOVLB  7
0E18:  BTFSC  x17.7
0E1A:  BSF    FF2.7
0E1C:  MOVFF  6DB,71C
0E20:  MOVFF  6DA,71B
0E24:  MOVLW  06
0E26:  MOVWF  x1E
0E28:  SETF   x1D
0E2A:  MOVLB  0
0E2C:  RCALL  0C16
0E2E:  MOVF   01,F
0E30:  BZ    0E38
....................           return 1; 
0E32:  MOVLW  01
0E34:  MOVWF  01
0E36:  BRA    0E3C
....................   return 0; 
0E38:  MOVLW  00
0E3A:  MOVWF  01
0E3C:  RETURN 0
.................... } 
....................  
.................... int1 Read_SMS(){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")){ 
*
1B2A:  MOVLW  06
1B2C:  MOVWF  FEA
1B2E:  MOVLW  B3
1B30:  MOVWF  FE9
1B32:  MOVFF  FF2,6CB
1B36:  BCF    FF2.7
1B38:  MOVLW  0C
1B3A:  MOVWF  01
1B3C:  CLRF   FF7
1B3E:  MOVLW  00
1B40:  CALL   0276
1B44:  TBLRD*-
1B46:  TBLRD*+
1B48:  MOVFF  FF5,FEE
1B4C:  DECFSZ 01,F
1B4E:  BRA    1B46
1B50:  MOVLB  6
1B52:  BTFSC  xCB.7
1B54:  BSF    FF2.7
1B56:  MOVLW  4F
1B58:  MOVWF  xBF
1B5A:  MOVLW  4B
1B5C:  MOVWF  xC0
1B5E:  CLRF   xC1
1B60:  MOVLW  06
1B62:  MOVLB  7
1B64:  MOVWF  x1C
1B66:  MOVLW  B3
1B68:  MOVWF  x1B
1B6A:  MOVLW  06
1B6C:  MOVWF  x1E
1B6E:  MOVLW  BF
1B70:  MOVWF  x1D
1B72:  MOVLB  0
1B74:  CALL   0C16
1B78:  MOVF   01,F
1B7A:  BZ    1BD2
....................     if(envia_SIM800L("AT+CMGL=\"REC UNREAD\"\r\n", "")){ 
1B7C:  MOVLW  06
1B7E:  MOVWF  FEA
1B80:  MOVLW  B3
1B82:  MOVWF  FE9
1B84:  MOVFF  FF2,6CB
1B88:  BCF    FF2.7
1B8A:  MOVLW  17
1B8C:  MOVWF  01
1B8E:  CLRF   FF7
1B90:  MOVLW  00
1B92:  CALL   02EE
1B96:  TBLRD*-
1B98:  TBLRD*+
1B9A:  MOVFF  FF5,FEE
1B9E:  DECFSZ 01,F
1BA0:  BRA    1B98
1BA2:  MOVLB  6
1BA4:  BTFSC  xCB.7
1BA6:  BSF    FF2.7
1BA8:  CLRF   xCA
1BAA:  MOVLW  06
1BAC:  MOVLB  7
1BAE:  MOVWF  x1C
1BB0:  MOVLW  B3
1BB2:  MOVWF  x1B
1BB4:  MOVLW  06
1BB6:  MOVWF  x1E
1BB8:  MOVLW  CA
1BBA:  MOVWF  x1D
1BBC:  MOVLB  0
1BBE:  CALL   0C16
1BC2:  MOVF   01,F
1BC4:  BZ    1BD2
....................       resposta_SIM = true; 
1BC6:  MOVLB  1
1BC8:  BSF    x82.1
....................       return 1;     
1BCA:  MOVLW  01
1BCC:  MOVWF  01
1BCE:  BRA    1BD8
1BD0:  MOVLB  0
....................     }   
....................   } 
....................   return 0; 
1BD2:  MOVLW  00
1BD4:  MOVWF  01
1BD6:  MOVLB  1
1BD8:  MOVLB  0
1BDA:  GOTO   2D84 (RETURN)
.................... } 
....................  
.................... int1 Get_Locate(char *numero){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
*
1F20:  MOVLW  06
1F22:  MOVWF  FEA
1F24:  MOVLW  B5
1F26:  MOVWF  FE9
1F28:  MOVFF  FF2,6D8
1F2C:  BCF    FF2.7
1F2E:  MOVLW  0C
1F30:  MOVWF  01
1F32:  CLRF   FF7
1F34:  MOVLW  00
1F36:  CALL   0276
1F3A:  TBLRD*-
1F3C:  TBLRD*+
1F3E:  MOVFF  FF5,FEE
1F42:  DECFSZ 01,F
1F44:  BRA    1F3C
1F46:  MOVLB  6
1F48:  BTFSC  xD8.7
1F4A:  BSF    FF2.7
1F4C:  MOVLW  4F
1F4E:  MOVWF  xC1
1F50:  MOVLW  4B
1F52:  MOVWF  xC2
1F54:  CLRF   xC3
1F56:  MOVLW  06
1F58:  MOVLB  7
1F5A:  MOVWF  x1C
1F5C:  MOVLW  B5
1F5E:  MOVWF  x1B
1F60:  MOVLW  06
1F62:  MOVWF  x1E
1F64:  MOVLW  C1
1F66:  MOVWF  x1D
1F68:  MOVLB  0
1F6A:  CALL   0C16
1F6E:  MOVF   01,F
1F70:  BTFSC  FD8.2
1F72:  BRA    229A
....................     if(envia_SIM800L("AT+CGATT=1\r\n","OK")) 
1F74:  MOVLW  06
1F76:  MOVWF  FEA
1F78:  MOVLW  B5
1F7A:  MOVWF  FE9
1F7C:  MOVFF  FF2,6D8
1F80:  BCF    FF2.7
1F82:  MOVLW  0D
1F84:  MOVWF  01
1F86:  CLRF   FF7
1F88:  MOVLW  00
1F8A:  CALL   0320
1F8E:  TBLRD*-
1F90:  TBLRD*+
1F92:  MOVFF  FF5,FEE
1F96:  DECFSZ 01,F
1F98:  BRA    1F90
1F9A:  MOVLB  6
1F9C:  BTFSC  xD8.7
1F9E:  BSF    FF2.7
1FA0:  MOVLW  4F
1FA2:  MOVWF  xC2
1FA4:  MOVLW  4B
1FA6:  MOVWF  xC3
1FA8:  CLRF   xC4
1FAA:  MOVLW  06
1FAC:  MOVLB  7
1FAE:  MOVWF  x1C
1FB0:  MOVLW  B5
1FB2:  MOVWF  x1B
1FB4:  MOVLW  06
1FB6:  MOVWF  x1E
1FB8:  MOVLW  C2
1FBA:  MOVWF  x1D
1FBC:  MOVLB  0
1FBE:  CALL   0C16
1FC2:  MOVF   01,F
1FC4:  BTFSC  FD8.2
1FC6:  BRA    229A
....................       if(envia_SIM800L("AT+SAPBR=3,1,\"CONTYPE\",\"GPRS\"\r\n","OK")) 
1FC8:  MOVLW  06
1FCA:  MOVWF  FEA
1FCC:  MOVLW  B5
1FCE:  MOVWF  FE9
1FD0:  MOVFF  FF2,6D8
1FD4:  BCF    FF2.7
1FD6:  MOVLW  20
1FD8:  MOVWF  01
1FDA:  CLRF   FF7
1FDC:  MOVLW  00
1FDE:  CALL   0348
1FE2:  TBLRD*-
1FE4:  TBLRD*+
1FE6:  MOVFF  FF5,FEE
1FEA:  DECFSZ 01,F
1FEC:  BRA    1FE4
1FEE:  MOVLB  6
1FF0:  BTFSC  xD8.7
1FF2:  BSF    FF2.7
1FF4:  MOVLW  4F
1FF6:  MOVWF  xD5
1FF8:  MOVLW  4B
1FFA:  MOVWF  xD6
1FFC:  CLRF   xD7
1FFE:  MOVLW  06
2000:  MOVLB  7
2002:  MOVWF  x1C
2004:  MOVLW  B5
2006:  MOVWF  x1B
2008:  MOVLW  06
200A:  MOVWF  x1E
200C:  MOVLW  D5
200E:  MOVWF  x1D
2010:  MOVLB  0
2012:  CALL   0C16
2016:  MOVF   01,F
2018:  BTFSC  FD8.2
201A:  BRA    229A
....................         if(envia_SIM800L("AT+SAPBR=3,1,\"APN\",\"CMNET\"\r\n","OK")) 
201C:  MOVLW  06
201E:  MOVWF  FEA
2020:  MOVLW  B5
2022:  MOVWF  FE9
2024:  MOVFF  FF2,6D8
2028:  BCF    FF2.7
202A:  MOVLW  1D
202C:  MOVWF  01
202E:  CLRF   FF7
2030:  MOVLW  00
2032:  CALL   0382
2036:  TBLRD*-
2038:  TBLRD*+
203A:  MOVFF  FF5,FEE
203E:  DECFSZ 01,F
2040:  BRA    2038
2042:  MOVLB  6
2044:  BTFSC  xD8.7
2046:  BSF    FF2.7
2048:  MOVLW  4F
204A:  MOVWF  xD2
204C:  MOVLW  4B
204E:  MOVWF  xD3
2050:  CLRF   xD4
2052:  MOVLW  06
2054:  MOVLB  7
2056:  MOVWF  x1C
2058:  MOVLW  B5
205A:  MOVWF  x1B
205C:  MOVLW  06
205E:  MOVWF  x1E
2060:  MOVLW  D2
2062:  MOVWF  x1D
2064:  MOVLB  0
2066:  CALL   0C16
206A:  MOVF   01,F
206C:  BTFSC  FD8.2
206E:  BRA    229A
....................           if(envia_SIM800L("AT+SAPBR=1,1\r\n","OK")) 
2070:  MOVLW  06
2072:  MOVWF  FEA
2074:  MOVLW  B5
2076:  MOVWF  FE9
2078:  MOVFF  FF2,6D8
207C:  BCF    FF2.7
207E:  MOVLW  0F
2080:  MOVWF  01
2082:  CLRF   FF7
2084:  MOVLW  00
2086:  CALL   03BA
208A:  TBLRD*-
208C:  TBLRD*+
208E:  MOVFF  FF5,FEE
2092:  DECFSZ 01,F
2094:  BRA    208C
2096:  MOVLB  6
2098:  BTFSC  xD8.7
209A:  BSF    FF2.7
209C:  MOVLW  4F
209E:  MOVWF  xC4
20A0:  MOVLW  4B
20A2:  MOVWF  xC5
20A4:  CLRF   xC6
20A6:  MOVLW  06
20A8:  MOVLB  7
20AA:  MOVWF  x1C
20AC:  MOVLW  B5
20AE:  MOVWF  x1B
20B0:  MOVLW  06
20B2:  MOVWF  x1E
20B4:  MOVLW  C4
20B6:  MOVWF  x1D
20B8:  MOVLB  0
20BA:  CALL   0C16
20BE:  MOVF   01,F
20C0:  BTFSC  FD8.2
20C2:  BRA    229A
....................             if(envia_SIM800L("AT+SAPBR=2,1\r\n","+SAPBR:")) 
20C4:  MOVLW  06
20C6:  MOVWF  FEA
20C8:  MOVLW  B5
20CA:  MOVWF  FE9
20CC:  MOVFF  FF2,6D8
20D0:  BCF    FF2.7
20D2:  MOVLW  0F
20D4:  MOVWF  01
20D6:  CLRF   FF7
20D8:  MOVLW  00
20DA:  CALL   03E4
20DE:  TBLRD*-
20E0:  TBLRD*+
20E2:  MOVFF  FF5,FEE
20E6:  DECFSZ 01,F
20E8:  BRA    20E0
20EA:  MOVLB  6
20EC:  BTFSC  xD8.7
20EE:  BSF    FF2.7
20F0:  MOVLW  06
20F2:  MOVWF  FEA
20F4:  MOVLW  C4
20F6:  MOVWF  FE9
20F8:  MOVFF  FF2,6DA
20FC:  BCF    FF2.7
20FE:  MOVLW  08
2100:  MOVWF  01
2102:  CLRF   FF7
2104:  MOVLW  00
2106:  MOVLB  0
2108:  CALL   040E
210C:  TBLRD*-
210E:  TBLRD*+
2110:  MOVFF  FF5,FEE
2114:  DECFSZ 01,F
2116:  BRA    210E
2118:  MOVLB  6
211A:  BTFSC  xDA.7
211C:  BSF    FF2.7
211E:  MOVLW  06
2120:  MOVLB  7
2122:  MOVWF  x1C
2124:  MOVLW  B5
2126:  MOVWF  x1B
2128:  MOVLW  06
212A:  MOVWF  x1E
212C:  MOVLW  C4
212E:  MOVWF  x1D
2130:  MOVLB  0
2132:  CALL   0C16
2136:  MOVF   01,F
2138:  BTFSC  FD8.2
213A:  BRA    229A
....................               if(envia_SIM800L("AT+CLBSCFG=0,1\r\n","+CLBSCFG:")){                 
213C:  MOVLW  06
213E:  MOVWF  FEA
2140:  MOVLW  B5
2142:  MOVWF  FE9
2144:  MOVFF  FF2,6D8
2148:  BCF    FF2.7
214A:  MOVLW  11
214C:  MOVWF  01
214E:  CLRF   FF7
2150:  MOVLW  00
2152:  CALL   0430
2156:  TBLRD*-
2158:  TBLRD*+
215A:  MOVFF  FF5,FEE
215E:  DECFSZ 01,F
2160:  BRA    2158
2162:  MOVLB  6
2164:  BTFSC  xD8.7
2166:  BSF    FF2.7
2168:  MOVLW  06
216A:  MOVWF  FEA
216C:  MOVLW  C6
216E:  MOVWF  FE9
2170:  MOVFF  FF2,6DA
2174:  BCF    FF2.7
2176:  MOVLW  0A
2178:  MOVWF  01
217A:  CLRF   FF7
217C:  MOVLW  00
217E:  MOVLB  0
2180:  CALL   045C
2184:  TBLRD*-
2186:  TBLRD*+
2188:  MOVFF  FF5,FEE
218C:  DECFSZ 01,F
218E:  BRA    2186
2190:  MOVLB  6
2192:  BTFSC  xDA.7
2194:  BSF    FF2.7
2196:  MOVLW  06
2198:  MOVLB  7
219A:  MOVWF  x1C
219C:  MOVLW  B5
219E:  MOVWF  x1B
21A0:  MOVLW  06
21A2:  MOVWF  x1E
21A4:  MOVLW  C6
21A6:  MOVWF  x1D
21A8:  MOVLB  0
21AA:  CALL   0C16
21AE:  MOVF   01,F
21B0:  BZ    229A
....................                 if(envia_SIM800L("AT+CLBS=1,1\r\n","+CLBS:")){ 
21B2:  MOVLW  06
21B4:  MOVWF  FEA
21B6:  MOVLW  B5
21B8:  MOVWF  FE9
21BA:  MOVFF  FF2,6D8
21BE:  BCF    FF2.7
21C0:  MOVLW  0E
21C2:  MOVWF  01
21C4:  CLRF   FF7
21C6:  MOVLW  00
21C8:  CALL   0480
21CC:  TBLRD*-
21CE:  TBLRD*+
21D0:  MOVFF  FF5,FEE
21D4:  DECFSZ 01,F
21D6:  BRA    21CE
21D8:  MOVLB  6
21DA:  BTFSC  xD8.7
21DC:  BSF    FF2.7
21DE:  MOVLW  06
21E0:  MOVWF  FEA
21E2:  MOVLW  C3
21E4:  MOVWF  FE9
21E6:  MOVFF  FF2,6DA
21EA:  BCF    FF2.7
21EC:  MOVLW  07
21EE:  MOVWF  01
21F0:  CLRF   FF7
21F2:  MOVLW  00
21F4:  MOVLB  0
21F6:  CALL   04A8
21FA:  TBLRD*-
21FC:  TBLRD*+
21FE:  MOVFF  FF5,FEE
2202:  DECFSZ 01,F
2204:  BRA    21FC
2206:  MOVLB  6
2208:  BTFSC  xDA.7
220A:  BSF    FF2.7
220C:  MOVLW  06
220E:  MOVLB  7
2210:  MOVWF  x1C
2212:  MOVLW  B5
2214:  MOVWF  x1B
2216:  MOVLW  06
2218:  MOVWF  x1E
221A:  MOVLW  C3
221C:  MOVWF  x1D
221E:  MOVLB  0
2220:  CALL   0C16
2224:  MOVF   01,F
2226:  BZ    229A
....................                   Get_Coordenadas(); 
2228:  BRA    1DBE
....................                   Send_SMS(numero,coordenada);  
222A:  MOVFF  6B4,6D9
222E:  MOVFF  6B3,6D8
2232:  MOVLW  01
2234:  MOVLB  6
2236:  MOVWF  xDB
2238:  MOVLW  A1
223A:  MOVWF  xDA
223C:  MOVLB  0
223E:  CALL   0D06
....................                   if(envia_SIM800L("AT+SAPBR=0,1\r\n","OK")) 
2242:  MOVLW  06
2244:  MOVWF  FEA
2246:  MOVLW  B5
2248:  MOVWF  FE9
224A:  MOVFF  FF2,6D8
224E:  BCF    FF2.7
2250:  MOVLW  0F
2252:  MOVWF  01
2254:  CLRF   FF7
2256:  MOVLW  00
2258:  CALL   04CA
225C:  TBLRD*-
225E:  TBLRD*+
2260:  MOVFF  FF5,FEE
2264:  DECFSZ 01,F
2266:  BRA    225E
2268:  MOVLB  6
226A:  BTFSC  xD8.7
226C:  BSF    FF2.7
226E:  MOVLW  4F
2270:  MOVWF  xC4
2272:  MOVLW  4B
2274:  MOVWF  xC5
2276:  CLRF   xC6
2278:  MOVLW  06
227A:  MOVLB  7
227C:  MOVWF  x1C
227E:  MOVLW  B5
2280:  MOVWF  x1B
2282:  MOVLW  06
2284:  MOVWF  x1E
2286:  MOVLW  C4
2288:  MOVWF  x1D
228A:  MOVLB  0
228C:  CALL   0C16
2290:  MOVF   01,F
2292:  BZ    229A
....................                     return 1;  
2294:  MOVLW  01
2296:  MOVWF  01
2298:  BRA    22EC
....................                 } 
....................               } 
....................   
....................   envia_SIM800L("AT+SAPBR=0,1\r\n","OK"); 
229A:  MOVLW  06
229C:  MOVWF  FEA
229E:  MOVLW  B5
22A0:  MOVWF  FE9
22A2:  MOVFF  FF2,6D8
22A6:  BCF    FF2.7
22A8:  MOVLW  0F
22AA:  MOVWF  01
22AC:  CLRF   FF7
22AE:  MOVLW  00
22B0:  CALL   04CA
22B4:  TBLRD*-
22B6:  TBLRD*+
22B8:  MOVFF  FF5,FEE
22BC:  DECFSZ 01,F
22BE:  BRA    22B6
22C0:  MOVLB  6
22C2:  BTFSC  xD8.7
22C4:  BSF    FF2.7
22C6:  MOVLW  4F
22C8:  MOVWF  xC4
22CA:  MOVLW  4B
22CC:  MOVWF  xC5
22CE:  CLRF   xC6
22D0:  MOVLW  06
22D2:  MOVLB  7
22D4:  MOVWF  x1C
22D6:  MOVLW  B5
22D8:  MOVWF  x1B
22DA:  MOVLW  06
22DC:  MOVWF  x1E
22DE:  MOVLW  C4
22E0:  MOVWF  x1D
22E2:  MOVLB  0
22E4:  CALL   0C16
....................   return 0;    
22E8:  MOVLW  00
22EA:  MOVWF  01
22EC:  GOTO   2D84 (RETURN)
.................... } 
....................  
.................... void Get_Coordenadas(){ 
*
1DBE:  MOVLB  6
1DC0:  CLRF   xD8
1DC2:  CLRF   xD9
....................   
....................  int8 index=0; 
....................  int8 index2=0; 
....................  
....................   memset (coordenada, 0x00, sizeof(coordenada)); 
1DC4:  MOVLW  01
1DC6:  MOVWF  FEA
1DC8:  MOVLW  A1
1DCA:  MOVWF  FE9
1DCC:  CLRF   00
1DCE:  CLRF   02
1DD0:  MOVLW  28
1DD2:  MOVWF  01
1DD4:  MOVLB  0
1DD6:  RCALL  1D8E
....................    
....................   coordenada[0] ='L'; 
1DD8:  MOVLW  4C
1DDA:  MOVLB  1
1DDC:  MOVWF  xA1
....................   coordenada[1] ='O'; 
1DDE:  MOVLW  4F
1DE0:  MOVWF  xA2
....................   coordenada[2] ='C'; 
1DE2:  MOVLW  43
1DE4:  MOVWF  xA3
....................   coordenada[3] ='A'; 
1DE6:  MOVLW  41
1DE8:  MOVWF  xA4
....................   coordenada[4] ='T'; 
1DEA:  MOVLW  54
1DEC:  MOVWF  xA5
....................   coordenada[5] ='E'; 
1DEE:  MOVLW  45
1DF0:  MOVWF  xA6
....................   coordenada[6] =':'; 
1DF2:  MOVLW  3A
1DF4:  MOVWF  xA7
....................   coordenada[7] =' '; 
1DF6:  MOVLW  20
1DF8:  MOVWF  xA8
....................   
....................   index2 = 8; 
1DFA:  MOVLW  08
1DFC:  MOVLB  6
1DFE:  MOVWF  xD9
....................   for(index=22;index<33;index++){ //Latitude 
1E00:  MOVLW  16
1E02:  MOVWF  xD8
1E04:  MOVF   xD8,W
1E06:  SUBLW  20
1E08:  BNC   1E3E
....................    coordenada[index2] = comando_recibido_UART[index]; 
1E0A:  CLRF   03
1E0C:  MOVF   xD9,W
1E0E:  ADDLW  A1
1E10:  MOVWF  01
1E12:  MOVLW  01
1E14:  ADDWFC 03,F
1E16:  MOVFF  03,6DB
1E1A:  CLRF   03
1E1C:  MOVF   xD8,W
1E1E:  ADDLW  52
1E20:  MOVWF  FE9
1E22:  MOVLW  00
1E24:  ADDWFC 03,W
1E26:  MOVWF  FEA
1E28:  MOVFF  FEF,6DC
1E2C:  MOVFF  6DB,FEA
1E30:  MOVFF  01,FE9
1E34:  MOVFF  6DC,FEF
....................    index2++;    
1E38:  INCF   xD9,F
1E3A:  INCF   xD8,F
1E3C:  BRA    1E04
....................   } 
....................  
....................   for(index=11;index<22;index++){ //Longitude 
1E3E:  MOVLW  0B
1E40:  MOVWF  xD8
1E42:  MOVF   xD8,W
1E44:  SUBLW  15
1E46:  BNC   1E7C
....................    coordenada[index2] = comando_recibido_UART[index]; 
1E48:  CLRF   03
1E4A:  MOVF   xD9,W
1E4C:  ADDLW  A1
1E4E:  MOVWF  01
1E50:  MOVLW  01
1E52:  ADDWFC 03,F
1E54:  MOVFF  03,6DB
1E58:  CLRF   03
1E5A:  MOVF   xD8,W
1E5C:  ADDLW  52
1E5E:  MOVWF  FE9
1E60:  MOVLW  00
1E62:  ADDWFC 03,W
1E64:  MOVWF  FEA
1E66:  MOVFF  FEF,6DC
1E6A:  MOVFF  6DB,FEA
1E6E:  MOVFF  01,FE9
1E72:  MOVFF  6DC,FEF
....................    index2++;    
1E76:  INCF   xD9,F
1E78:  INCF   xD8,F
1E7A:  BRA    1E42
....................   } 
....................    
....................   coordenada[index2++] =' '; 
1E7C:  MOVF   xD9,W
1E7E:  INCF   xD9,F
1E80:  CLRF   03
1E82:  ADDLW  A1
1E84:  MOVWF  FE9
1E86:  MOVLW  01
1E88:  ADDWFC 03,W
1E8A:  MOVWF  FEA
1E8C:  MOVLW  20
1E8E:  MOVWF  FEF
....................   coordenada[index2++] ='R'; 
1E90:  MOVF   xD9,W
1E92:  INCF   xD9,F
1E94:  CLRF   03
1E96:  ADDLW  A1
1E98:  MOVWF  FE9
1E9A:  MOVLW  01
1E9C:  ADDWFC 03,W
1E9E:  MOVWF  FEA
1EA0:  MOVLW  52
1EA2:  MOVWF  FEF
....................   coordenada[index2++] ='='; 
1EA4:  MOVF   xD9,W
1EA6:  INCF   xD9,F
1EA8:  CLRF   03
1EAA:  ADDLW  A1
1EAC:  MOVWF  FE9
1EAE:  MOVLW  01
1EB0:  ADDWFC 03,W
1EB2:  MOVWF  FEA
1EB4:  MOVLW  3D
1EB6:  MOVWF  FEF
....................  
....................   for(index=33;index<36;index++){ //Preciso 
1EB8:  MOVLW  21
1EBA:  MOVWF  xD8
1EBC:  MOVF   xD8,W
1EBE:  SUBLW  23
1EC0:  BNC   1EF6
....................    coordenada[index2] = comando_recibido_UART[index]; 
1EC2:  CLRF   03
1EC4:  MOVF   xD9,W
1EC6:  ADDLW  A1
1EC8:  MOVWF  01
1ECA:  MOVLW  01
1ECC:  ADDWFC 03,F
1ECE:  MOVFF  03,6DB
1ED2:  CLRF   03
1ED4:  MOVF   xD8,W
1ED6:  ADDLW  52
1ED8:  MOVWF  FE9
1EDA:  MOVLW  00
1EDC:  ADDWFC 03,W
1EDE:  MOVWF  FEA
1EE0:  MOVFF  FEF,6DC
1EE4:  MOVFF  6DB,FEA
1EE8:  MOVFF  01,FE9
1EEC:  MOVFF  6DC,FEF
....................    index2++;    
1EF0:  INCF   xD9,F
1EF2:  INCF   xD8,F
1EF4:  BRA    1EBC
....................   } 
....................    
....................   coordenada[index2++] ='m'; 
1EF6:  MOVF   xD9,W
1EF8:  INCF   xD9,F
1EFA:  CLRF   03
1EFC:  ADDLW  A1
1EFE:  MOVWF  FE9
1F00:  MOVLW  01
1F02:  ADDWFC 03,W
1F04:  MOVWF  FEA
1F06:  MOVLW  6D
1F08:  MOVWF  FEF
....................   coordenada[index2] = 0; 
1F0A:  CLRF   03
1F0C:  MOVF   xD9,W
1F0E:  ADDLW  A1
1F10:  MOVWF  FE9
1F12:  MOVLW  01
1F14:  ADDWFC 03,W
1F16:  MOVWF  FEA
1F18:  CLRF   FEF
1F1A:  MOVLB  0
1F1C:  GOTO   222A (RETURN)
....................  
.................... } 
....................  
....................  
.................... #ENDIF 
....................  
.................... #include "Memory.h" 
.................... #IFNDEF MEMORY_H 
.................... #DEFINE MEMORY_H 
....................  
.................... //*********************************** ENDERECOS EEPROM *******************************************  
....................  
.................... #define ADDR_tempo_entre_alertas              getenv("EEPROM_ADDRESS") + 0  //int32 
.................... #define ADDR_tempo_ultimo_alerta              getenv("EEPROM_ADDRESS") + 4  //int32 
.................... #define ADDR_corrente_limite                  getenv("EEPROM_ADDRESS") + 8  //int32 
.................... #define ADDR_zero_set                         getenv("EEPROM_ADDRESS") + 12 //int32 
.................... #define ADDR_qtd_numeros                      getenv("EEPROM_ADDRESS") + 16 //int8 
.................... #define ADDR_vector_numeros                   getenv("EEPROM_ADDRESS") + 17 //Vetor int 8 com 50 posicoes 
....................  
.................... //************************************************************************************************* 
....................  
.................... //************************************ DEAFULT EEPROM ********************************************* 
....................  
.................... #rom int32 ADDR_tempo_entre_alertas = {0} 
.................... #rom int32 ADDR_tempo_ultimo_alerta = {0}  
.................... #rom int32 ADDR_corrente_limite = {0}  
.................... #rom int32 ADDR_zero_set = {0}  
.................... #rom int8  ADDR_qtd_numeros = {0}  
.................... #rom int8  ADDR_vector_numeros = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} 
....................  
.................... //************************************************************************************************* 
....................  
....................  
.................... void read_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
.................... void write_config(unsigned int32 address, unsigned int8 *dataptr, unsigned int8 count); 
....................  
.................... #include "Memory.c" 
.................... #ENDIF 
....................  
.................... #include "numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
.................... void obtem_numero(int8 pos_num, char *numero); 
....................  
.................... #include"numeros.c" 
.................... #ENDIF 
....................  
....................  
.................... // Declaração de Variáveis 
....................  
.................... int1 comando_disponivel_UART = FALSE; 
.................... int1 One_Second = FALSE; 
.................... int1 One_Minute = FALSE; 
.................... int16 Miliseconds = 0; 
.................... int16 seconds = 0; 
.................... char comando = 0; 
.................... int1 resposta_SIM = false; 
.................... int8 leitura_tensao_partida[400]; 
.................... int1 partida_iniciada = FALSE; 
.................... int1 aquisicao_tensao_partida = FALSE; 
.................... int1 veiculo_ligado = FALSE; 
.................... int16 index = 0; 
.................... unsigned int8 index_1 = 0; 
.................... unsigned int8 index_2 = 0; 
.................... int8 V1 = 255; 
.................... int8 V2 = 255; 
.................... int1 sel_ad = FALSE; 
.................... unsigned int16 leitura_corrente[100]; 
.................... unsigned int16 offset_current_ref[100]; 
.................... unsigned int8 leitura_tensao[100]; 
.................... unsigned int16 aux_leitura[100]; 
.................... float aux_offset_current_ref = 0; 
.................... float aux_corrente = 0; 
.................... float aux_tensao = 0; 
.................... float zero_set = 0; 
.................... float zero_set_aux = 0; 
.................... int32 corrente_limite = 3000; 
.................... int8 qtd_numeros=0; 
.................... int8 tempo_corrente_verif = 0; 
.................... int8 tempo_corrente_verif_low = 0;  
.................... int8 index_envio = 0; 
.................... int32 tempo_entre_alertas = 1; 
.................... int32 tempo_ultimo_alerta = 1; 
.................... int1 detect_high_current = false; 
.................... char numero[20]; 
.................... //Fim declaração de variáveis 
....................  
.................... #INT_RTCC 
.................... void Timer_0(){ 
....................  
....................   set_timer0(6);   
*
07A4:  CLRF   FD7
07A6:  MOVLW  06
07A8:  MOVWF  FD6
....................    
....................   if(partida_iniciada){ 
07AA:  MOVLB  1
07AC:  BTFSS  x82.4
07AE:  BRA    080A
....................      
....................     output_high(PIN_D0); 
07B0:  BSF    F8C.0
....................     if(index<400){  
07B2:  MOVLB  3
07B4:  MOVF   x5F,W
07B6:  SUBLW  01
07B8:  BNC   07F4
07BA:  BNZ   07C2
07BC:  MOVF   x5E,W
07BE:  SUBLW  8F
07C0:  BNC   07F4
....................          
....................       leitura_tensao_partida[index] = (read_adc()>>2); 
07C2:  MOVLW  CE
07C4:  ADDWF  x5E,W
07C6:  MOVWF  FE9
07C8:  MOVLW  01
07CA:  ADDWFC x5F,W
07CC:  MOVWF  FEA
07CE:  BSF    FC2.1
07D0:  BTFSC  FC2.1
07D2:  BRA    07D0
07D4:  MOVLB  7
07D6:  RRCF   FC4,W
07D8:  MOVWF  03
07DA:  RRCF   FC3,W
07DC:  MOVWF  02
07DE:  RRCF   03,F
07E0:  RRCF   02,F
07E2:  MOVLW  3F
07E4:  ANDWF  03,F
07E6:  MOVFF  02,FEF
....................       index++; 
07EA:  MOVLB  3
07EC:  INCF   x5E,F
07EE:  BTFSC  FD8.2
07F0:  INCF   x5F,F
....................     }  
07F2:  BRA    0806
....................     else{ 
....................       index = 0; 
07F4:  CLRF   x5F
07F6:  CLRF   x5E
....................       partida_iniciada = FALSE; 
07F8:  MOVLB  1
07FA:  BCF    x82.4
....................       aquisicao_tensao_partida = TRUE; 
07FC:  BSF    x82.5
....................       output_low(PIN_D0); 
07FE:  BCF    F8C.0
....................       enable_interrupts(INT_RDA); 
0800:  BSF    F9D.5
....................       enable_interrupts(INT_EXT); 
0802:  BSF    FF2.4
0804:  MOVLB  3
....................     } 
....................   } 
0806:  BRA    091A
0808:  MOVLB  1
....................   else{ 
....................     Miliseconds++; 
080A:  INCF   xC9,F
080C:  BTFSC  FD8.2
080E:  INCF   xCA,F
....................  
....................     if(Miliseconds % 5 == 0){ 
0810:  MOVFF  1CA,732
0814:  MOVFF  1C9,731
0818:  MOVLB  7
081A:  CLRF   x34
081C:  MOVLW  05
081E:  MOVWF  x33
0820:  MOVLB  0
0822:  BRA    075C
0824:  MOVFF  00,731
0828:  MOVLB  7
082A:  MOVFF  03,732
082E:  MOVF   x31,F
0830:  BNZ   08E4
0832:  MOVF   x32,F
0834:  BNZ   08E4
....................       sel_ad = !sel_ad; 
0836:  MOVLB  1
0838:  BTG    x82.7
....................     
....................       if(sel_ad){ 
083A:  BTFSS  x82.7
083C:  BRA    08A6
....................         leitura_corrente[index_1] = read_adc(); 
083E:  BCF    FD8.0
0840:  MOVLB  3
0842:  RLCF   x60,W
0844:  CLRF   03
0846:  ADDLW  64
0848:  MOVWF  FE9
084A:  MOVLW  03
084C:  ADDWFC 03,W
084E:  MOVWF  FEA
0850:  BSF    FC2.1
0852:  BTFSC  FC2.1
0854:  BRA    0852
0856:  MOVFF  FC3,FEF
085A:  MOVFF  FC4,FEC
....................         set_adc_channel(3); 
085E:  MOVLW  0C
0860:  MOVWF  01
0862:  MOVF   FC2,W
0864:  ANDLW  C3
0866:  IORWF  01,W
0868:  MOVWF  FC2
....................         delay_us(10); 
086A:  MOVLW  0C
086C:  MOVWF  00
086E:  DECFSZ 00,F
0870:  BRA    086E
0872:  BRA    0874
0874:  NOP   
....................         offset_current_ref[index_1] = read_adc(); 
0876:  BCF    FD8.0
0878:  RLCF   x60,W
087A:  CLRF   03
087C:  ADDLW  2C
087E:  MOVWF  FE9
0880:  MOVLW  04
0882:  ADDWFC 03,W
0884:  MOVWF  FEA
0886:  BSF    FC2.1
0888:  BTFSC  FC2.1
088A:  BRA    0888
088C:  MOVFF  FC3,FEF
0890:  MOVFF  FC4,FEC
....................         set_adc_channel(1); 
0894:  MOVLW  04
0896:  MOVWF  01
0898:  MOVF   FC2,W
089A:  ANDLW  C3
089C:  IORWF  01,W
089E:  MOVWF  FC2
....................         index_1++; 
08A0:  INCF   x60,F
....................       } 
08A2:  BRA    08E2
08A4:  MOVLB  1
....................       else{ 
....................         leitura_tensao[index_2] = (read_adc()>>2); 
08A6:  CLRF   03
08A8:  MOVLB  3
08AA:  MOVF   x61,W
08AC:  ADDLW  F4
08AE:  MOVWF  FE9
08B0:  MOVLW  04
08B2:  ADDWFC 03,W
08B4:  MOVWF  FEA
08B6:  BSF    FC2.1
08B8:  BTFSC  FC2.1
08BA:  BRA    08B8
08BC:  MOVLB  7
08BE:  RRCF   FC4,W
08C0:  MOVWF  03
08C2:  RRCF   FC3,W
08C4:  MOVWF  02
08C6:  RRCF   03,F
08C8:  RRCF   02,F
08CA:  MOVLW  3F
08CC:  ANDWF  03,F
08CE:  MOVFF  02,FEF
....................         set_adc_channel(2); 
08D2:  MOVLW  08
08D4:  MOVWF  01
08D6:  MOVF   FC2,W
08D8:  ANDLW  C3
08DA:  IORWF  01,W
08DC:  MOVWF  FC2
....................         index_2++; 
08DE:  MOVLB  3
08E0:  INCF   x61,F
08E2:  MOVLB  7
....................       }  
....................     } 
....................  
....................     if(Miliseconds == 1000){ 
08E4:  MOVLB  1
08E6:  MOVF   xC9,W
08E8:  SUBLW  E8
08EA:  BNZ   0918
08EC:  MOVF   xCA,W
08EE:  SUBLW  03
08F0:  BNZ   0918
....................       seconds++; 
08F2:  INCF   xCB,F
08F4:  BTFSC  FD8.2
08F6:  INCF   xCC,F
....................       Miliseconds = 0; 
08F8:  CLRF   xCA
08FA:  CLRF   xC9
....................       One_Second = TRUE; 
08FC:  BSF    x82.2
....................       index_1 = 0; 
08FE:  MOVLB  3
0900:  CLRF   x60
....................       index_2 = 0; 
0902:  CLRF   x61
....................       output_toggle(PIN_A0); 
0904:  BTG    F89.0
....................       if(seconds==60){ 
0906:  MOVLB  1
0908:  MOVF   xCB,W
090A:  SUBLW  3C
090C:  BNZ   0918
090E:  MOVF   xCC,F
0910:  BNZ   0918
....................         seconds = 0; 
0912:  CLRF   xCC
0914:  CLRF   xCB
....................         One_Minute = TRUE; 
0916:  BSF    x82.3
0918:  MOVLB  3
....................       } 
....................     } 
....................   } 
....................   return; 
.................... } 
....................  
091A:  BCF    FF2.2
091C:  MOVLB  0
091E:  GOTO   006C
.................... #INT_EXT 
.................... void Interrupcao_Externa(){ 
....................    
....................   set_adc_channel(1); 
0922:  MOVLW  04
0924:  MOVWF  01
0926:  MOVF   FC2,W
0928:  ANDLW  C3
092A:  IORWF  01,W
092C:  MOVWF  FC2
....................   disable_interrupts(INT_RDA); 
092E:  BCF    F9D.5
....................   disable_interrupts(INT_EXT); 
0930:  BCF    FF2.4
....................   partida_iniciada = TRUE; 
0932:  MOVLB  1
0934:  BSF    x82.4
....................   veiculo_ligado = TRUE; 
0936:  BSF    x82.6
....................   aquisicao_tensao_partida = FALSE; 
0938:  BCF    x82.5
....................   index = 0; 
093A:  MOVLB  3
093C:  CLRF   x5F
093E:  CLRF   x5E
....................  
....................   return; 
0940:  BCF    FF2.1
0942:  MOVLB  0
0944:  GOTO   006C
.................... } 
....................  
.................... void main() 
*
31CA:  CLRF   FF8
31CC:  BCF    FD0.7
31CE:  BSF    07.7
31D0:  CLRF   16
31D2:  BSF    FB8.3
31D4:  MOVLW  22
31D6:  MOVWF  FAF
31D8:  MOVLW  00
31DA:  MOVWF  FB0
31DC:  MOVLW  A6
31DE:  MOVWF  FAC
31E0:  MOVLW  90
31E2:  MOVWF  FAB
31E4:  BCF    F93.2
31E6:  BSF    F8A.2
31E8:  MOVLB  1
31EA:  CLRF   x7F
31EC:  CLRF   x7E
31EE:  MOVLW  86
31F0:  MOVWF  x81
31F2:  MOVLW  A0
31F4:  MOVWF  x80
31F6:  CLRF   x9C
31F8:  CLRF   x9B
31FA:  CLRF   xA0
31FC:  MOVLW  6A
31FE:  MOVWF  x9F
3200:  MOVLW  CF
3202:  MOVWF  x9E
3204:  MOVLW  C0
3206:  MOVWF  x9D
3208:  BCF    x82.0
320A:  BCF    x82.2
320C:  BCF    x82.3
320E:  CLRF   xCA
3210:  CLRF   xC9
3212:  CLRF   xCC
3214:  CLRF   xCB
3216:  CLRF   xCD
3218:  BCF    x82.1
321A:  BCF    x82.4
321C:  BCF    x82.5
321E:  BCF    x82.6
3220:  MOVLB  3
3222:  CLRF   x5F
3224:  CLRF   x5E
3226:  CLRF   x60
3228:  CLRF   x61
322A:  SETF   x62
322C:  SETF   x63
322E:  MOVLB  1
3230:  BCF    x82.7
3232:  MOVLB  6
3234:  CLRF   x23
3236:  CLRF   x22
3238:  CLRF   x21
323A:  CLRF   x20
323C:  MOVLB  1
323E:  CLRF   x8E
3240:  CLRF   x8D
3242:  CLRF   x8C
3244:  CLRF   x8B
3246:  CLRF   x92
3248:  CLRF   x91
324A:  CLRF   x90
324C:  CLRF   x8F
324E:  CLRF   x96
3250:  CLRF   x95
3252:  CLRF   x94
3254:  CLRF   x93
3256:  CLRF   x9A
3258:  CLRF   x99
325A:  CLRF   x98
325C:  CLRF   x97
325E:  CLRF   x86
3260:  CLRF   x85
3262:  MOVLW  0B
3264:  MOVWF  x84
3266:  MOVLW  B8
3268:  MOVWF  x83
326A:  CLRF   4F
326C:  MOVLB  6
326E:  CLRF   x24
3270:  CLRF   x25
3272:  CLRF   x26
3274:  MOVLB  1
3276:  CLRF   x8A
3278:  CLRF   x89
327A:  CLRF   x88
327C:  MOVLW  01
327E:  MOVWF  x87
3280:  MOVLB  6
3282:  CLRF   x2A
3284:  CLRF   x29
3286:  CLRF   x28
3288:  MOVWF  x27
328A:  BCF    x2B.0
328C:  MOVF   FC1,W
328E:  ANDLW  C0
3290:  IORLW  0F
3292:  MOVWF  FC1
3294:  MOVLW  07
3296:  MOVWF  FB4
3298:  CLRF   17
329A:  CLRF   18
.................... { 
....................   set_tris_a (0b00001110);                                                     //Ra7-Ra6-Ra5-Ra4-Ra3-Ra2-Ra1-Ra0 
329C:  MOVLW  0E
329E:  MOVWF  F92
....................   set_tris_b (0b00001001);                                                     //Rb7-Rb6-Rb5-Rb4-Rb3-Rb2-Rb1-Rb0 
32A0:  MOVLW  09
32A2:  MOVWF  F93
....................   set_tris_c (0b10000000);                                                     //Rc7-Rc6-Rc5-Rc4-Rc3-Rc2-Rc1-Rc0 
32A4:  MOVLW  80
32A6:  MOVWF  F94
....................   set_tris_d (0b00000000);  
32A8:  MOVLW  00
32AA:  MOVWF  F95
....................    
....................   setup_adc_ports(AN0_TO_AN3); 
32AC:  MOVF   FC1,W
32AE:  ANDLW  C0
32B0:  IORLW  0B
32B2:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_2); 
32B4:  MOVF   FC0,W
32B6:  ANDLW  C0
32B8:  MOVWF  FC0
32BA:  BSF    FC0.7
32BC:  BSF    FC2.0
....................   set_adc_channel(1); 
32BE:  MOVLW  04
32C0:  MOVWF  01
32C2:  MOVF   FC2,W
32C4:  ANDLW  C3
32C6:  IORWF  01,W
32C8:  MOVWF  FC2
....................   setup_wdt(WDT_OFF); 
32CA:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 | RTCC_8_BIT); 
32CC:  MOVLW  C3
32CE:  MOVWF  FD5
....................   set_timer0(6); 
32D0:  CLRF   FD7
32D2:  MOVLW  06
32D4:  MOVWF  FD6
....................   ext_int_edge(H_TO_L); 
32D6:  BCF    FF1.6
....................  
....................   output_low(PIN_D0); 
32D8:  BCF    F8C.0
....................   enable_interrupts(INT_RTCC); 
32DA:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
32DC:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
32DE:  MOVLW  C0
32E0:  IORWF  FF2,F
....................  
....................   le_EEPROM();  
32E2:  MOVLB  0
32E4:  GOTO   0A0A
....................   output_low(PIN_D2); 
32E8:  BCF    F8C.2
....................   delay_ms(2000); 
32EA:  MOVLW  08
32EC:  MOVLB  6
32EE:  MOVWF  x5A
32F0:  MOVLW  FA
32F2:  MOVLB  7
32F4:  MOVWF  x26
32F6:  MOVLB  0
32F8:  CALL   0ABC
32FC:  MOVLB  6
32FE:  DECFSZ x5A,F
3300:  BRA    32F0
....................   output_high(PIN_D2); 
3302:  BSF    F8C.2
....................   delay_ms(15000); 
3304:  MOVLW  3C
3306:  MOVWF  x5A
3308:  MOVLW  FA
330A:  MOVLB  7
330C:  MOVWF  x26
330E:  MOVLB  0
3310:  CALL   0ABC
3314:  MOVLB  6
3316:  DECFSZ x5A,F
3318:  BRA    3308
....................   Send_SMS("031995822739","INICIANDO..."); 
331A:  MOVLW  06
331C:  MOVWF  FEA
331E:  MOVLW  40
3320:  MOVWF  FE9
3322:  MOVFF  FF2,65A
3326:  BCF    FF2.7
3328:  MOVLW  0D
332A:  MOVWF  01
332C:  CLRF   FF7
332E:  MOVLW  00
3330:  MOVLB  0
3332:  CALL   04F4
3336:  TBLRD*-
3338:  TBLRD*+
333A:  MOVFF  FF5,FEE
333E:  DECFSZ 01,F
3340:  BRA    3338
3342:  MOVLB  6
3344:  BTFSC  x5A.7
3346:  BSF    FF2.7
3348:  MOVLW  06
334A:  MOVWF  FEA
334C:  MOVLW  4D
334E:  MOVWF  FE9
3350:  MOVFF  FF2,65C
3354:  BCF    FF2.7
3356:  MOVLW  0D
3358:  MOVWF  01
335A:  CLRF   FF7
335C:  MOVLW  00
335E:  MOVLB  0
3360:  CALL   051C
3364:  TBLRD*-
3366:  TBLRD*+
3368:  MOVFF  FF5,FEE
336C:  DECFSZ 01,F
336E:  BRA    3366
3370:  MOVLB  6
3372:  BTFSC  x5C.7
3374:  BSF    FF2.7
3376:  MOVLW  06
3378:  MOVWF  xD9
337A:  MOVLW  40
337C:  MOVWF  xD8
337E:  MOVLW  06
3380:  MOVWF  xDB
3382:  MOVLW  4D
3384:  MOVWF  xDA
3386:  MOVLB  0
3388:  CALL   0D06
....................  
....................   enable_interrupts(INT_EXT_H2L); 
338C:  BSF    FF2.4
338E:  BCF    FF1.6
....................  
....................   while(TRUE){ 
....................  
....................     if(One_Second){ 
3390:  MOVLB  1
3392:  BTFSS  x82.2
3394:  BRA    339E
....................  
....................       One_Second = FALSE; 
3396:  BCF    x82.2
....................       Executar_Cada_Segundo(); 
3398:  MOVLB  0
339A:  BRA    2DC8
339C:  MOVLB  1
....................  
....................     } 
....................  
....................     if(One_Minute){ 
339E:  BTFSS  x82.3
33A0:  BRA    33AA
....................  
....................       One_Minute = FALSE; 
33A2:  BCF    x82.3
....................       Executar_Cada_Minuto(); 
33A4:  MOVLB  0
33A6:  BRA    3046
33A8:  MOVLB  1
....................  
....................     } 
33AA:  BRA    3392
....................  
....................   } 
....................  
.................... } 
....................  
33AC:  SLEEP 
.................... void le_EEPROM(void){ 
....................  
....................   read_config(ADDR_tempo_entre_alertas,&tempo_entre_alertas,4); 
*
0A0A:  MOVLB  6
0A0C:  CLRF   x5D
0A0E:  MOVLW  F0
0A10:  MOVWF  x5C
0A12:  CLRF   x5B
0A14:  CLRF   x5A
0A16:  MOVLW  01
0A18:  MOVWF  x5F
0A1A:  MOVLW  87
0A1C:  MOVWF  x5E
0A1E:  MOVLW  04
0A20:  MOVWF  x60
0A22:  MOVLB  0
0A24:  RCALL  09B4
....................   read_config(ADDR_tempo_ultimo_alerta,&tempo_ultimo_alerta,4); 
0A26:  MOVLB  6
0A28:  CLRF   x5D
0A2A:  MOVLW  F0
0A2C:  MOVWF  x5C
0A2E:  CLRF   x5B
0A30:  MOVLW  04
0A32:  MOVWF  x5A
0A34:  MOVLW  06
0A36:  MOVWF  x5F
0A38:  MOVLW  27
0A3A:  MOVWF  x5E
0A3C:  MOVLW  04
0A3E:  MOVWF  x60
0A40:  MOVLB  0
0A42:  RCALL  09B4
....................   read_config(ADDR_corrente_limite,&corrente_limite,4); 
0A44:  MOVLB  6
0A46:  CLRF   x5D
0A48:  MOVLW  F0
0A4A:  MOVWF  x5C
0A4C:  CLRF   x5B
0A4E:  MOVLW  08
0A50:  MOVWF  x5A
0A52:  MOVLW  01
0A54:  MOVWF  x5F
0A56:  MOVLW  83
0A58:  MOVWF  x5E
0A5A:  MOVLW  04
0A5C:  MOVWF  x60
0A5E:  MOVLB  0
0A60:  RCALL  09B4
....................   read_config(ADDR_zero_set,&zero_set,4); 
0A62:  MOVLB  6
0A64:  CLRF   x5D
0A66:  MOVLW  F0
0A68:  MOVWF  x5C
0A6A:  CLRF   x5B
0A6C:  MOVLW  0C
0A6E:  MOVWF  x5A
0A70:  MOVLW  01
0A72:  MOVWF  x5F
0A74:  MOVLW  93
0A76:  MOVWF  x5E
0A78:  MOVLW  04
0A7A:  MOVWF  x60
0A7C:  MOVLB  0
0A7E:  RCALL  09B4
....................   read_config(ADDR_qtd_numeros,&qtd_numeros,1); 
0A80:  MOVLB  6
0A82:  CLRF   x5D
0A84:  MOVLW  F0
0A86:  MOVWF  x5C
0A88:  CLRF   x5B
0A8A:  MOVLW  10
0A8C:  MOVWF  x5A
0A8E:  CLRF   x5F
0A90:  MOVLW  4F
0A92:  MOVWF  x5E
0A94:  MOVLW  01
0A96:  MOVWF  x60
0A98:  MOVLB  0
0A9A:  RCALL  09B4
....................   read_config(ADDR_vector_numeros,&numeros,50); 
0A9C:  MOVLB  6
0A9E:  CLRF   x5D
0AA0:  MOVLW  F0
0AA2:  MOVWF  x5C
0AA4:  CLRF   x5B
0AA6:  MOVLW  11
0AA8:  MOVWF  x5A
0AAA:  CLRF   x5F
0AAC:  MOVLW  1D
0AAE:  MOVWF  x5E
0AB0:  MOVLW  32
0AB2:  MOVWF  x60
0AB4:  MOVLB  0
0AB6:  RCALL  09B4
0AB8:  GOTO   32E8 (RETURN)
....................  
.................... } 
....................  
.................... void Executar_Cada_Segundo(){ 
....................    
....................   Calcula_SOC(); 
*
2DC8:  GOTO   1682
....................   if(corrente_limite != 0){ 
2DCC:  MOVLB  1
2DCE:  MOVF   x83,F
2DD0:  BNZ   2DDE
2DD2:  MOVF   x84,F
2DD4:  BNZ   2DDE
2DD6:  MOVF   x85,F
2DD8:  BNZ   2DDE
2DDA:  MOVF   x86,F
2DDC:  BZ    2E78
....................     if(aux_corrente > corrente_limite){ 
2DDE:  MOVFF  186,66E
2DE2:  MOVFF  185,66D
2DE6:  MOVFF  184,66C
2DEA:  MOVFF  183,66B
2DEE:  MOVLB  0
2DF0:  GOTO   19C2
2DF4:  MOVFF  03,6A1
2DF8:  MOVFF  02,6A0
2DFC:  MOVFF  01,69F
2E00:  MOVFF  00,69E
2E04:  MOVFF  18E,6A5
2E08:  MOVFF  18D,6A4
2E0C:  MOVFF  18C,6A3
2E10:  MOVFF  18B,6A2
2E14:  CALL   1312
2E18:  BNC   2E4A
....................       tempo_corrente_verif++; 
2E1A:  MOVLB  6
2E1C:  INCF   x24,F
....................       if(tempo_corrente_verif > 30){ 
2E1E:  MOVF   x24,W
2E20:  SUBLW  1E
2E22:  BC    2E46
....................         tempo_corrente_verif = 0; 
2E24:  CLRF   x24
....................         tempo_corrente_verif_low = 0; 
2E26:  CLRF   x25
....................         detect_high_current = true; 
2E28:  BSF    x2B.0
....................         disable_interrupts(GLOBAL); 
2E2A:  BCF    FF2.6
2E2C:  BCF    FF2.7
2E2E:  BTFSC  FF2.7
2E30:  BRA    2E2C
....................         fprintf(MONITOR_SERIAL,"Detect High Current\r\n"); 
2E32:  MOVLW  48
2E34:  MOVWF  FF6
2E36:  MOVLW  09
2E38:  MOVWF  FF7
2E3A:  MOVLB  0
2E3C:  CALL   19FC
....................         enable_interrupts(GLOBAL); 
2E40:  MOVLW  C0
2E42:  IORWF  FF2,F
2E44:  MOVLB  6
....................       } 
....................     } 
2E46:  BRA    2E76
2E48:  MOVLB  0
....................     else{ 
....................       tempo_corrente_verif_low++; 
2E4A:  MOVLB  6
2E4C:  INCF   x25,F
....................       if(tempo_corrente_verif_low > 30){ 
2E4E:  MOVF   x25,W
2E50:  SUBLW  1E
2E52:  BC    2E76
....................         tempo_corrente_verif_low = 0; 
2E54:  CLRF   x25
....................         tempo_corrente_verif = 0; 
2E56:  CLRF   x24
....................         detect_high_current = false; 
2E58:  BCF    x2B.0
....................         disable_interrupts(GLOBAL); 
2E5A:  BCF    FF2.6
2E5C:  BCF    FF2.7
2E5E:  BTFSC  FF2.7
2E60:  BRA    2E5C
....................         fprintf(MONITOR_SERIAL,"Detect Low Current\r\n"); 
2E62:  MOVLW  5E
2E64:  MOVWF  FF6
2E66:  MOVLW  09
2E68:  MOVWF  FF7
2E6A:  MOVLB  0
2E6C:  CALL   19FC
....................         enable_interrupts(GLOBAL); 
2E70:  MOVLW  C0
2E72:  IORWF  FF2,F
2E74:  MOVLB  6
2E76:  MOVLB  1
....................       } 
....................        
....................     } 
....................   } 
....................   if(aquisicao_tensao_partida){ 
2E78:  BTFSS  x82.5
2E7A:  BRA    2E86
....................  
....................     aquisicao_tensao_partida = FALSE; 
2E7C:  BCF    x82.5
....................     Obtem_SOH(); 
2E7E:  MOVLB  0
2E80:  GOTO   1A1C
2E84:  MOVLB  1
....................  
....................   } 
....................   if(comando_disponivel_UART){ 
2E86:  BTFSS  x82.0
2E88:  BRA    2F32
....................    
....................     disable_interrupts(GLOBAL); 
2E8A:  BCF    FF2.6
2E8C:  BCF    FF2.7
2E8E:  BTFSC  FF2.7
2E90:  BRA    2E8C
....................     comando = Get_Comando(); 
2E92:  MOVLB  0
2E94:  CALL   1A64
2E98:  MOVFF  01,1CD
....................      
....................     if(comando != 0){ 
2E9C:  MOVLB  1
2E9E:  MOVF   xCD,F
2EA0:  BZ    2EAE
....................  
....................       Executa_Comando(comando); 
2EA2:  MOVFF  1CD,66B
2EA6:  MOVLB  0
2EA8:  CALL   25B2
2EAC:  MOVLB  1
....................        
....................     } 
....................     if(resposta_SIM == 1){ 
2EAE:  BTFSS  x82.1
2EB0:  BRA    2F2A
....................       disable_interrupts(GLOBAL); 
2EB2:  BCF    FF2.6
2EB4:  BCF    FF2.7
2EB6:  BTFSC  FF2.7
2EB8:  BRA    2EB4
....................       resposta_SIM = 0; 
2EBA:  BCF    x82.1
....................       comando = Get_Comando(); 
2EBC:  MOVLB  0
2EBE:  CALL   1A64
2EC2:  MOVFF  01,1CD
....................       Executa_Comando(comando); 
2EC6:  MOVFF  1CD,66B
2ECA:  CALL   25B2
....................       delay_ms(100); 
2ECE:  MOVLW  64
2ED0:  MOVLB  7
2ED2:  MOVWF  x26
2ED4:  MOVLB  0
2ED6:  CALL   0ABC
....................       envia_SIM800L("AT+CMGD=1,1\r\n", "OK"); 
2EDA:  MOVLW  06
2EDC:  MOVWF  FEA
2EDE:  MOVLW  5A
2EE0:  MOVWF  FE9
2EE2:  MOVFF  FF2,66B
2EE6:  BCF    FF2.7
2EE8:  MOVLW  0E
2EEA:  MOVWF  01
2EEC:  CLRF   FF7
2EEE:  MOVLW  00
2EF0:  CALL   0544
2EF4:  TBLRD*-
2EF6:  TBLRD*+
2EF8:  MOVFF  FF5,FEE
2EFC:  DECFSZ 01,F
2EFE:  BRA    2EF6
2F00:  MOVLB  6
2F02:  BTFSC  x6B.7
2F04:  BSF    FF2.7
2F06:  MOVLW  4F
2F08:  MOVWF  x68
2F0A:  MOVLW  4B
2F0C:  MOVWF  x69
2F0E:  CLRF   x6A
2F10:  MOVLW  06
2F12:  MOVLB  7
2F14:  MOVWF  x1C
2F16:  MOVLW  5A
2F18:  MOVWF  x1B
2F1A:  MOVLW  06
2F1C:  MOVWF  x1E
2F1E:  MOVLW  68
2F20:  MOVWF  x1D
2F22:  MOVLB  0
2F24:  CALL   0C16
2F28:  MOVLB  1
....................     } 
....................     comando = 0; 
2F2A:  CLRF   xCD
....................     clear_command(); 
2F2C:  MOVLB  0
2F2E:  BRA    2D86
2F30:  MOVLB  1
....................   } 
....................    
....................   return; 
2F32:  MOVLB  0
2F34:  GOTO   339C (RETURN)
.................... } 
....................  
.................... void Executar_Cada_Minuto(){ 
....................    
....................   index_envio = 0; 
*
3046:  MOVLB  6
3048:  CLRF   x26
....................   if(detect_high_current){ 
304A:  BTFSS  x2B.0
304C:  BRA    31C4
....................      
....................     if((qtd_numeros>0 && qtd_numeros<4) && tempo_entre_alertas>0){ 
304E:  MOVF   4F,F
3050:  BTFSC  FD8.2
3052:  BRA    31C4
3054:  MOVF   4F,W
3056:  SUBLW  03
3058:  BTFSS  FD8.0
305A:  BRA    31C4
305C:  MOVLB  1
305E:  MOVF   x87,F
3060:  BNZ   3074
3062:  MOVF   x88,F
3064:  BNZ   3074
3066:  MOVF   x89,F
3068:  BNZ   3074
306A:  MOVF   x8A,F
306C:  BTFSS  FD8.2
306E:  BRA    3074
3070:  MOVLB  6
3072:  BRA    31C4
....................       tempo_ultimo_alerta++; 
3074:  MOVLW  01
3076:  MOVLB  6
3078:  ADDWF  x27,F
307A:  BTFSC  FD8.0
307C:  INCF   x28,F
307E:  BTFSC  FD8.2
3080:  INCF   x29,F
3082:  BTFSC  FD8.2
3084:  INCF   x2A,F
....................       disable_interrupts(INT_EXT);  
3086:  BCF    FF2.4
....................  
....................       if(tempo_ultimo_alerta >= tempo_entre_alertas){    
3088:  MOVLB  1
308A:  MOVF   x8A,W
308C:  MOVLB  6
308E:  SUBWF  x2A,W
3090:  BTFSS  FD8.0
3092:  BRA    31C2
3094:  BNZ   30BE
3096:  MOVLB  1
3098:  MOVF   x89,W
309A:  MOVLB  6
309C:  SUBWF  x29,W
309E:  BTFSS  FD8.0
30A0:  BRA    31C2
30A2:  BNZ   30BE
30A4:  MOVLB  1
30A6:  MOVF   x88,W
30A8:  MOVLB  6
30AA:  SUBWF  x28,W
30AC:  BTFSS  FD8.0
30AE:  BRA    31C2
30B0:  BNZ   30BE
30B2:  MOVLB  1
30B4:  MOVF   x87,W
30B6:  MOVLB  6
30B8:  SUBWF  x27,W
30BA:  BTFSS  FD8.0
30BC:  BRA    31C2
....................         tempo_ultimo_alerta = 0; 
30BE:  CLRF   x2A
30C0:  CLRF   x29
30C2:  CLRF   x28
30C4:  CLRF   x27
....................         for(index_envio = 0; index_envio < qtd_numeros; index_envio++){ 
30C6:  CLRF   x26
30C8:  MOVF   4F,W
30CA:  SUBWF  x26,W
30CC:  BTFSC  FD8.0
30CE:  BRA    31C2
....................           memset (numero, 0x00, sizeof(numero)); 
30D0:  MOVLW  06
30D2:  MOVWF  FEA
30D4:  MOVLW  2C
30D6:  MOVWF  FE9
30D8:  CLRF   00
30DA:  CLRF   02
30DC:  MOVLW  14
30DE:  MOVWF  01
30E0:  MOVLB  0
30E2:  CALL   1D8E
....................           obtem_numero(index_envio,numero); 
30E6:  MOVFF  626,69A
30EA:  MOVLW  06
30EC:  MOVLB  6
30EE:  MOVWF  x9C
30F0:  MOVLW  2C
30F2:  MOVWF  x9B
30F4:  MOVLB  0
30F6:  BRA    2F38
....................           disable_interrupts(GLOBAL); 
30F8:  BCF    FF2.6
30FA:  BCF    FF2.7
30FC:  BTFSC  FF2.7
30FE:  BRA    30FA
....................           fprintf(MONITOR_SERIAL,"Send SMS Numero (%u/%u): %s\r\n",index_envio+1,qtd_numeros,numero); 
3100:  MOVLW  01
3102:  MOVLB  6
3104:  ADDWF  x26,W
3106:  MOVWF  x9A
3108:  MOVLW  74
310A:  MOVWF  FF6
310C:  MOVLW  09
310E:  MOVWF  FF7
3110:  MOVLW  11
3112:  MOVWF  x9B
3114:  MOVLB  0
3116:  RCALL  2F96
3118:  MOVFF  69A,69B
311C:  MOVLW  1B
311E:  MOVLB  6
3120:  MOVWF  x9C
3122:  MOVLB  0
3124:  RCALL  2FC0
3126:  MOVLW  2F
3128:  MOVLB  6
312A:  MOVWF  xA0
312C:  MOVLB  0
312E:  CALL   1618
3132:  MOVFF  4F,69B
3136:  MOVLW  1B
3138:  MOVLB  6
313A:  MOVWF  x9C
313C:  MOVLB  0
313E:  RCALL  2FC0
3140:  MOVLW  8A
3142:  MOVWF  FF6
3144:  MOVLW  09
3146:  MOVWF  FF7
3148:  MOVLW  03
314A:  MOVLB  6
314C:  MOVWF  x9B
314E:  MOVLB  0
3150:  RCALL  2F96
3152:  MOVLW  06
3154:  MOVWF  FEA
3156:  MOVLW  2C
3158:  MOVWF  FE9
315A:  CALL   165E
315E:  MOVLW  0D
3160:  MOVLB  6
3162:  MOVWF  xA0
3164:  MOVLB  0
3166:  CALL   1618
316A:  MOVLW  0A
316C:  MOVLB  6
316E:  MOVWF  xA0
3170:  MOVLB  0
3172:  CALL   1618
....................           enable_interrupts(GLOBAL); 
3176:  MOVLW  C0
3178:  IORWF  FF2,F
....................           Send_SMS(numero,"!!!!ALERTA: Bateria em descarga rapida VERIFIQUE SEU VEICULO!!!"); 
317A:  MOVLW  06
317C:  MOVWF  FEA
317E:  MOVLW  5A
3180:  MOVWF  FE9
3182:  MOVFF  FF2,69A
3186:  BCF    FF2.7
3188:  MOVLW  40
318A:  MOVWF  01
318C:  CLRF   FF7
318E:  MOVLW  00
3190:  CALL   056C
3194:  TBLRD*-
3196:  TBLRD*+
3198:  MOVFF  FF5,FEE
319C:  DECFSZ 01,F
319E:  BRA    3196
31A0:  MOVLB  6
31A2:  BTFSC  x9A.7
31A4:  BSF    FF2.7
31A6:  MOVLW  06
31A8:  MOVWF  xD9
31AA:  MOVLW  2C
31AC:  MOVWF  xD8
31AE:  MOVLW  06
31B0:  MOVWF  xDB
31B2:  MOVLW  5A
31B4:  MOVWF  xDA
31B6:  MOVLB  0
31B8:  CALL   0D06
31BC:  MOVLB  6
31BE:  INCF   x26,F
31C0:  BRA    30C8
....................    
....................         } 
....................       } 
....................       enable_interrupts(INT_EXT); 
31C2:  BSF    FF2.4
....................     } 
....................        
....................   }   
....................   return; 
31C4:  MOVLB  0
31C6:  GOTO   33A8 (RETURN)
.................... } 
....................  
.................... void Obtem_SOH(){ 
....................   
....................   V1 = 255; 
*
1A1C:  MOVLB  3
1A1E:  SETF   x62
....................   V2 = 255; 
1A20:  SETF   x63
....................   index = 0; 
1A22:  CLRF   x5F
1A24:  CLRF   x5E
....................  
....................   for(index=0;index<15;index++){ 
1A26:  CLRF   x5F
1A28:  CLRF   x5E
1A2A:  MOVF   x5F,F
1A2C:  BNZ   1A5E
1A2E:  MOVF   x5E,W
1A30:  SUBLW  0E
1A32:  BNC   1A5E
....................      
....................     if(leitura_tensao_partida[index]<V1) 
1A34:  MOVLW  CE
1A36:  ADDWF  x5E,W
1A38:  MOVWF  FE9
1A3A:  MOVLW  01
1A3C:  ADDWFC x5F,W
1A3E:  MOVWF  FEA
1A40:  MOVF   x62,W
1A42:  SUBWF  FEF,W
1A44:  BC    1A56
....................       V1 = leitura_tensao[index]; 
1A46:  MOVLW  F4
1A48:  ADDWF  x5E,W
1A4A:  MOVWF  FE9
1A4C:  MOVLW  04
1A4E:  ADDWFC x5F,W
1A50:  MOVWF  FEA
1A52:  MOVFF  FEF,362
1A56:  INCF   x5E,F
1A58:  BTFSC  FD8.2
1A5A:  INCF   x5F,F
1A5C:  BRA    1A2A
....................     
....................   } 
....................    
....................  
....................   return; 
1A5E:  MOVLB  0
1A60:  GOTO   2E84 (RETURN)
.................... } 
....................  
.................... void Calcula_SOC(){ 
*
1682:  MOVLB  6
1684:  CLRF   x6B
....................    
....................   int8 i=0; 
....................   char exibe[50]; 
....................  
....................   for(i=0; i<100;i++) 
1686:  CLRF   x6B
1688:  MOVF   x6B,W
168A:  SUBLW  63
168C:  BNC   16D8
....................     aux_leitura[i] = leitura_corrente[i]; 
168E:  BCF    FD8.0
1690:  RLCF   x6B,W
1692:  CLRF   03
1694:  ADDLW  58
1696:  MOVWF  01
1698:  MOVLW  05
169A:  ADDWFC 03,F
169C:  MOVFF  01,69E
16A0:  MOVFF  03,69F
16A4:  BCF    FD8.0
16A6:  RLCF   x6B,W
16A8:  CLRF   03
16AA:  ADDLW  64
16AC:  MOVWF  FE9
16AE:  MOVLW  03
16B0:  ADDWFC 03,W
16B2:  MOVWF  FEA
16B4:  MOVFF  FEC,03
16B8:  MOVF   FED,F
16BA:  MOVFF  FEF,6A0
16BE:  MOVFF  03,6A1
16C2:  MOVFF  69F,FEA
16C6:  MOVFF  01,FE9
16CA:  MOVFF  03,FEC
16CE:  MOVF   FED,F
16D0:  MOVFF  6A0,FEF
16D4:  INCF   x6B,F
16D6:  BRA    1688
....................   aux_corrente = obtem_mediana(aux_leitura,100); 
16D8:  MOVLW  05
16DA:  MOVWF  x9F
16DC:  MOVLW  58
16DE:  MOVWF  x9E
16E0:  MOVLW  64
16E2:  MOVWF  xA0
16E4:  MOVLB  0
16E6:  CALL   0E3E
16EA:  MOVFF  02,69F
16EE:  MOVFF  01,69E
16F2:  RCALL  0F6E
16F4:  MOVFF  03,18E
16F8:  MOVFF  02,18D
16FC:  MOVFF  01,18C
1700:  MOVFF  00,18B
....................    
....................   for(i=0; i<100;i++) 
1704:  MOVLB  6
1706:  CLRF   x6B
1708:  MOVF   x6B,W
170A:  SUBLW  63
170C:  BNC   1758
....................     aux_leitura[i] = offset_current_ref[i]; 
170E:  BCF    FD8.0
1710:  RLCF   x6B,W
1712:  CLRF   03
1714:  ADDLW  58
1716:  MOVWF  01
1718:  MOVLW  05
171A:  ADDWFC 03,F
171C:  MOVFF  01,69E
1720:  MOVFF  03,69F
1724:  BCF    FD8.0
1726:  RLCF   x6B,W
1728:  CLRF   03
172A:  ADDLW  2C
172C:  MOVWF  FE9
172E:  MOVLW  04
1730:  ADDWFC 03,W
1732:  MOVWF  FEA
1734:  MOVFF  FEC,03
1738:  MOVF   FED,F
173A:  MOVFF  FEF,6A0
173E:  MOVFF  03,6A1
1742:  MOVFF  69F,FEA
1746:  MOVFF  01,FE9
174A:  MOVFF  03,FEC
174E:  MOVF   FED,F
1750:  MOVFF  6A0,FEF
1754:  INCF   x6B,F
1756:  BRA    1708
....................   aux_offset_current_ref = obtem_mediana(aux_leitura,100); 
1758:  MOVLW  05
175A:  MOVWF  x9F
175C:  MOVLW  58
175E:  MOVWF  x9E
1760:  MOVLW  64
1762:  MOVWF  xA0
1764:  MOVLB  0
1766:  CALL   0E3E
176A:  MOVFF  02,69F
176E:  MOVFF  01,69E
1772:  CALL   0F6E
1776:  MOVFF  03,623
177A:  MOVFF  02,622
177E:  MOVFF  01,621
1782:  MOVFF  00,620
....................  
....................   for(i=0; i<100;i++) 
1786:  MOVLB  6
1788:  CLRF   x6B
178A:  MOVF   x6B,W
178C:  SUBLW  63
178E:  BNC   17CC
....................     aux_leitura[i] = leitura_tensao[i]; 
1790:  BCF    FD8.0
1792:  RLCF   x6B,W
1794:  CLRF   03
1796:  ADDLW  58
1798:  MOVWF  01
179A:  MOVLW  05
179C:  ADDWFC 03,F
179E:  MOVFF  01,69E
17A2:  MOVFF  03,69F
17A6:  CLRF   03
17A8:  MOVF   x6B,W
17AA:  ADDLW  F4
17AC:  MOVWF  FE9
17AE:  MOVLW  04
17B0:  ADDWFC 03,W
17B2:  MOVWF  FEA
17B4:  MOVFF  FEF,6A0
17B8:  MOVFF  69F,FEA
17BC:  MOVFF  01,FE9
17C0:  CLRF   FEC
17C2:  MOVF   FED,F
17C4:  MOVFF  6A0,FEF
17C8:  INCF   x6B,F
17CA:  BRA    178A
....................   aux_tensao = obtem_mediana(aux_leitura,100); 
17CC:  MOVLW  05
17CE:  MOVWF  x9F
17D0:  MOVLW  58
17D2:  MOVWF  x9E
17D4:  MOVLW  64
17D6:  MOVWF  xA0
17D8:  MOVLB  0
17DA:  CALL   0E3E
17DE:  MOVFF  02,69F
17E2:  MOVFF  01,69E
17E6:  CALL   0F6E
17EA:  MOVFF  03,192
17EE:  MOVFF  02,191
17F2:  MOVFF  01,190
17F6:  MOVFF  00,18F
....................    
....................   aux_tensao = aux_tensao*(15.0/255.0); 
17FA:  MOVFF  192,6C3
17FE:  MOVFF  191,6C2
1802:  MOVFF  190,6C1
1806:  MOVFF  18F,6C0
180A:  MOVLW  F1
180C:  MOVLB  6
180E:  MOVWF  xC7
1810:  MOVLW  F0
1812:  MOVWF  xC6
1814:  MOVLW  70
1816:  MOVWF  xC5
1818:  MOVLW  7A
181A:  MOVWF  xC4
181C:  MOVLB  0
181E:  CALL   0FA4
1822:  MOVFF  03,192
1826:  MOVFF  02,191
182A:  MOVFF  01,190
182E:  MOVFF  00,18F
....................   zero_set_aux = (aux_corrente-(aux_offset_current_ref)); 
1832:  BSF    FD8.1
1834:  MOVFF  18E,6A1
1838:  MOVFF  18D,6A0
183C:  MOVFF  18C,69F
1840:  MOVFF  18B,69E
1844:  MOVFF  623,6A5
1848:  MOVFF  622,6A4
184C:  MOVFF  621,6A3
1850:  MOVFF  620,6A2
1854:  RCALL  109A
1856:  MOVFF  03,19A
185A:  MOVFF  02,199
185E:  MOVFF  01,198
1862:  MOVFF  00,197
....................   aux_corrente = (zero_set_aux-zero_set)*355; 
1866:  BSF    FD8.1
1868:  MOVFF  19A,6A1
186C:  MOVFF  199,6A0
1870:  MOVFF  198,69F
1874:  MOVFF  197,69E
1878:  MOVFF  196,6A5
187C:  MOVFF  195,6A4
1880:  MOVFF  194,6A3
1884:  MOVFF  193,6A2
1888:  RCALL  109A
188A:  MOVFF  03,6A1
188E:  MOVFF  02,6A0
1892:  MOVFF  01,69F
1896:  MOVFF  00,69E
189A:  MOVFF  03,6C3
189E:  MOVFF  02,6C2
18A2:  MOVFF  01,6C1
18A6:  MOVFF  00,6C0
18AA:  MOVLB  6
18AC:  CLRF   xC7
18AE:  MOVLW  80
18B0:  MOVWF  xC6
18B2:  MOVLW  31
18B4:  MOVWF  xC5
18B6:  MOVLW  87
18B8:  MOVWF  xC4
18BA:  MOVLB  0
18BC:  CALL   0FA4
18C0:  MOVFF  03,18E
18C4:  MOVFF  02,18D
18C8:  MOVFF  01,18C
18CC:  MOVFF  00,18B
....................   if(aux_corrente > -750 && aux_corrente < 750) aux_corrente = 0; 
18D0:  MOVLB  6
18D2:  CLRF   xA1
18D4:  MOVLW  80
18D6:  MOVWF  xA0
18D8:  MOVLW  BB
18DA:  MOVWF  x9F
18DC:  MOVLW  88
18DE:  MOVWF  x9E
18E0:  MOVFF  18E,6A5
18E4:  MOVFF  18D,6A4
18E8:  MOVFF  18C,6A3
18EC:  MOVFF  18B,6A2
18F0:  MOVLB  0
18F2:  RCALL  1312
18F4:  BNC   1928
18F6:  MOVFF  18E,6A1
18FA:  MOVFF  18D,6A0
18FE:  MOVFF  18C,69F
1902:  MOVFF  18B,69E
1906:  MOVLB  6
1908:  CLRF   xA5
190A:  MOVLW  80
190C:  MOVWF  xA4
190E:  MOVLW  3B
1910:  MOVWF  xA3
1912:  MOVLW  88
1914:  MOVWF  xA2
1916:  MOVLB  0
1918:  RCALL  1312
191A:  BNC   1928
191C:  MOVLB  1
191E:  CLRF   x8E
1920:  CLRF   x8D
1922:  CLRF   x8C
1924:  CLRF   x8B
1926:  MOVLB  0
....................  
....................   disable_interrupts(GLOBAL); 
1928:  BCF    FF2.6
192A:  BCF    FF2.7
192C:  BTFSC  FF2.7
192E:  BRA    192A
....................   sprintf(exibe,"Corrente: %6.0f Tensao: %2.2f \r\n",aux_corrente,aux_tensao); 
1930:  MOVLW  06
1932:  MOVLB  1
1934:  MOVWF  x9C
1936:  MOVLW  6C
1938:  MOVWF  x9B
193A:  MOVLW  92
193C:  MOVWF  FF6
193E:  MOVLW  09
1940:  MOVWF  FF7
1942:  MOVLW  0A
1944:  MOVLB  7
1946:  MOVWF  x17
1948:  MOVLB  0
194A:  CALL   0B08
194E:  MOVLW  05
1950:  MOVWF  FE9
1952:  MOVFF  18E,6B6
1956:  MOVFF  18D,6B5
195A:  MOVFF  18C,6B4
195E:  MOVFF  18B,6B3
1962:  MOVLB  6
1964:  CLRF   xB7
1966:  MOVLB  0
1968:  RCALL  1464
196A:  MOVLW  A1
196C:  MOVWF  FF6
196E:  MOVLW  09
1970:  MOVWF  FF7
1972:  MOVLW  09
1974:  MOVLB  7
1976:  MOVWF  x17
1978:  MOVLB  0
197A:  CALL   0B08
197E:  MOVLW  89
1980:  MOVWF  FE9
1982:  MOVFF  192,6B6
1986:  MOVFF  191,6B5
198A:  MOVFF  190,6B4
198E:  MOVFF  18F,6B3
1992:  MOVLW  02
1994:  MOVLB  6
1996:  MOVWF  xB7
1998:  MOVLB  0
199A:  RCALL  1464
199C:  MOVLW  AF
199E:  MOVWF  FF6
19A0:  MOVLW  09
19A2:  MOVWF  FF7
19A4:  MOVLW  03
19A6:  MOVLB  7
19A8:  MOVWF  x17
19AA:  MOVLB  0
19AC:  CALL   0B08
....................   fprintf(MONITOR_SERIAL,exibe); 
19B0:  MOVLW  06
19B2:  MOVWF  FEA
19B4:  MOVLW  6C
19B6:  MOVWF  FE9
19B8:  RCALL  165E
....................   enable_interrupts(GLOBAL); 
19BA:  MOVLW  C0
19BC:  IORWF  FF2,F
19BE:  GOTO   2DCC (RETURN)
....................  
.................... } 
....................  
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam){   
....................  
....................   int16 aux;  
....................   int16 i, j; 
....................  
....................   for (i = 0; i < (tam-1); i++){ 
*
0E3E:  MOVLB  6
0E40:  CLRF   xA4
0E42:  CLRF   xA3
0E44:  MOVLW  01
0E46:  SUBWF  xA0,W
0E48:  MOVF   xA4,F
0E4A:  BTFSS  FD8.2
0E4C:  BRA    0F52
0E4E:  SUBWF  xA3,W
0E50:  BTFSC  FD8.0
0E52:  BRA    0F52
....................     for (j = i+1; j < tam; j++){ 
0E54:  MOVLW  01
0E56:  ADDWF  xA3,W
0E58:  MOVWF  xA5
0E5A:  MOVLW  00
0E5C:  ADDWFC xA4,W
0E5E:  MOVWF  xA6
0E60:  MOVF   xA6,F
0E62:  BNZ   0F4A
0E64:  MOVF   xA0,W
0E66:  SUBWF  xA5,W
0E68:  BC    0F4A
....................       if (num[i] < num[j]) 
0E6A:  BCF    FD8.0
0E6C:  RLCF   xA3,W
0E6E:  MOVWF  02
0E70:  RLCF   xA4,W
0E72:  MOVWF  03
0E74:  MOVF   02,W
0E76:  ADDWF  x9E,W
0E78:  MOVWF  FE9
0E7A:  MOVF   x9F,W
0E7C:  ADDWFC 03,W
0E7E:  MOVWF  FEA
0E80:  MOVFF  FEC,6A8
0E84:  MOVF   FED,F
0E86:  MOVFF  FEF,6A7
0E8A:  BCF    FD8.0
0E8C:  RLCF   xA5,W
0E8E:  MOVWF  02
0E90:  RLCF   xA6,W
0E92:  MOVWF  03
0E94:  MOVF   02,W
0E96:  ADDWF  x9E,W
0E98:  MOVWF  FE9
0E9A:  MOVF   x9F,W
0E9C:  ADDWFC 03,W
0E9E:  MOVWF  FEA
0EA0:  MOVFF  FEC,03
0EA4:  MOVF   FED,F
0EA6:  MOVFF  FEF,01
0EAA:  MOVF   xA8,W
0EAC:  SUBWF  03,W
0EAE:  BNC   0F42
0EB0:  BNZ   0EB8
0EB2:  MOVF   01,W
0EB4:  SUBWF  xA7,W
0EB6:  BC    0F42
....................       { 
....................         aux = num[i]; 
0EB8:  BCF    FD8.0
0EBA:  RLCF   xA3,W
0EBC:  MOVWF  02
0EBE:  RLCF   xA4,W
0EC0:  MOVWF  03
0EC2:  MOVF   02,W
0EC4:  ADDWF  x9E,W
0EC6:  MOVWF  FE9
0EC8:  MOVF   x9F,W
0ECA:  ADDWFC 03,W
0ECC:  MOVWF  FEA
0ECE:  MOVFF  FEC,6A2
0ED2:  MOVF   FED,F
0ED4:  MOVFF  FEF,6A1
....................         num[i] = num[j]; 
0ED8:  BCF    FD8.0
0EDA:  RLCF   xA3,W
0EDC:  MOVWF  02
0EDE:  RLCF   xA4,W
0EE0:  MOVWF  03
0EE2:  MOVF   02,W
0EE4:  ADDWF  x9E,W
0EE6:  MOVWF  01
0EE8:  MOVF   x9F,W
0EEA:  ADDWFC 03,F
0EEC:  MOVFF  03,6A8
0EF0:  BCF    FD8.0
0EF2:  RLCF   xA5,W
0EF4:  MOVWF  02
0EF6:  RLCF   xA6,W
0EF8:  MOVWF  03
0EFA:  MOVF   02,W
0EFC:  ADDWF  x9E,W
0EFE:  MOVWF  FE9
0F00:  MOVF   x9F,W
0F02:  ADDWFC 03,W
0F04:  MOVWF  FEA
0F06:  MOVFF  FEC,03
0F0A:  MOVF   FED,F
0F0C:  MOVFF  FEF,6A9
0F10:  MOVFF  6A8,FEA
0F14:  MOVFF  01,FE9
0F18:  MOVFF  03,FEC
0F1C:  MOVF   FED,F
0F1E:  MOVFF  6A9,FEF
....................         num[j] = aux; 
0F22:  BCF    FD8.0
0F24:  RLCF   xA5,W
0F26:  MOVWF  02
0F28:  RLCF   xA6,W
0F2A:  MOVWF  03
0F2C:  MOVF   02,W
0F2E:  ADDWF  x9E,W
0F30:  MOVWF  FE9
0F32:  MOVF   x9F,W
0F34:  ADDWFC 03,W
0F36:  MOVWF  FEA
0F38:  MOVFF  6A2,FEC
0F3C:  MOVF   FED,F
0F3E:  MOVFF  6A1,FEF
....................       } 
0F42:  INCF   xA5,F
0F44:  BTFSC  FD8.2
0F46:  INCF   xA6,F
0F48:  BRA    0E60
....................     } 
0F4A:  INCF   xA3,F
0F4C:  BTFSC  FD8.2
0F4E:  INCF   xA4,F
0F50:  BRA    0E44
....................   } 
....................   return num[50];  
0F52:  MOVLW  64
0F54:  ADDWF  x9E,W
0F56:  MOVWF  FE9
0F58:  MOVLW  00
0F5A:  ADDWFC x9F,W
0F5C:  MOVWF  FEA
0F5E:  MOVFF  FEF,01
0F62:  INCF   FE9,F
0F64:  MOVF   FEF,W
0F66:  DECF   FE9,F
0F68:  MOVWF  02
0F6A:  MOVLB  0
0F6C:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: CE3B   PLL4 CPUDIV4 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
F00040: 00 00 00 
