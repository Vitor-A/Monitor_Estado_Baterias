CCS PCH C Compiler, Version 5.015, 5967               10-nov-18 21:02

               Filename:   C:\Users\Vitor\Desktop\Monitor_Estado_Baterias\TAI_Bateria.lst

               ROM used:   11880 bytes (36%)
                           Largest free fragment is 20884
               RAM used:   1604 (78%) at main() level
                           1844 (90%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   2C94
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.4
004A:  GOTO   0054
004E:  BTFSC  FF2.1
0050:  GOTO   090C
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   05DC
0060:  BTFSS  FF2.5
0062:  GOTO   006C
0066:  BTFSC  FF2.2
0068:  GOTO   0790
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Projeto Monitor do Estado de Baterias - TAI  
.................... // Data: Setembro de 2018 
....................  
....................  
.................... //******************* Interrupção do Timer 0 / RTCC ************************** 
.................... //   
.................... //  Cristal externo = 16 MHz - Uso de PLL*4 -> Frequencia de trabalho = 16MHz  
.................... //  Prescaler = 1:16 
.................... //  Tout =(4*prescaler* (256-TMR0))/fclk   
.................... //  Para interrup��o a cada 1 ms 
.................... //  TMR0 = 6  
.................... //  
.................... //**************************************************************************** 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  MOVFF  FF2,0D
00B2:  BCF    FF2.7
00B4:  CLRF   FF7
00B6:  ADDLW  C8
00B8:  MOVWF  FF6
00BA:  MOVLW  00
00BC:  ADDWFC FF7,F
00BE:  TBLRD*+
00C0:  MOVF   FF5,W
00C2:  BTFSC  0D.7
00C4:  BSF    FF2.7
00C6:  RETURN 0
00C8:  DATA 2B,43
00CA:  DATA 4D,54
00CC:  DATA 49,00
00CE:  MOVFF  FF2,0D
00D2:  BCF    FF2.7
00D4:  CLRF   FF7
00D6:  ADDLW  E8
00D8:  MOVWF  FF6
00DA:  MOVLW  00
00DC:  ADDWFC FF7,F
00DE:  TBLRD*+
00E0:  MOVF   FF5,W
00E2:  BTFSC  0D.7
00E4:  BSF    FF2.7
00E6:  RETURN 0
00E8:  DATA 2B,43
00EA:  DATA 4D,47
00EC:  DATA 4C,00
00EE:  MOVFF  FF2,0D
00F2:  BCF    FF2.7
00F4:  CLRF   FF7
00F6:  ADDLW  08
00F8:  MOVWF  FF6
00FA:  MOVLW  01
00FC:  ADDWFC FF7,F
00FE:  TBLRD*+
0100:  MOVF   FF5,W
0102:  BTFSC  0D.7
0104:  BSF    FF2.7
0106:  RETURN 0
0108:  DATA 4F,49
010A:  DATA 54,41
010C:  DATA 49,00
010E:  MOVFF  FF2,0D
0112:  BCF    FF2.7
0114:  CLRF   FF7
0116:  ADDLW  28
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  BTFSC  0D.7
0124:  BSF    FF2.7
0126:  RETURN 0
0128:  DATA 48,45
012A:  DATA 41,52
012C:  DATA 54,42
012E:  DATA 45,41
0130:  DATA 54,28
0132:  DATA 29,00
0134:  MOVFF  FF2,0D
0138:  BCF    FF2.7
013A:  CLRF   FF7
013C:  ADDLW  4E
013E:  MOVWF  FF6
0140:  MOVLW  01
0142:  ADDWFC FF7,F
0144:  TBLRD*+
0146:  MOVF   FF5,W
0148:  BTFSC  0D.7
014A:  BSF    FF2.7
014C:  RETURN 0
014E:  DATA 2B,4E
0150:  DATA 55,4D
0152:  DATA 41,44
0154:  DATA 44,00
0156:  MOVFF  FF2,0D
015A:  BCF    FF2.7
015C:  CLRF   FF7
015E:  ADDLW  70
0160:  MOVWF  FF6
0162:  MOVLW  01
0164:  ADDWFC FF7,F
0166:  TBLRD*+
0168:  MOVF   FF5,W
016A:  BTFSC  0D.7
016C:  BSF    FF2.7
016E:  RETURN 0
0170:  DATA 2B,4E
0172:  DATA 55,4D
0174:  DATA 44,45
0176:  DATA 4C,00
0178:  MOVFF  FF2,0D
017C:  BCF    FF2.7
017E:  CLRF   FF7
0180:  ADDLW  92
0182:  MOVWF  FF6
0184:  MOVLW  01
0186:  ADDWFC FF7,F
0188:  TBLRD*+
018A:  MOVF   FF5,W
018C:  BTFSC  0D.7
018E:  BSF    FF2.7
0190:  RETURN 0
0192:  DATA 4F,4B
0194:  DATA 20,43
0196:  DATA 4C,45
0198:  DATA 41,52
019A:  DATA 20,41
019C:  DATA 4C,4C
019E:  DATA 00,00
01A0:  MOVFF  FF2,0D
01A4:  BCF    FF2.7
01A6:  CLRF   FF7
01A8:  ADDLW  BA
01AA:  MOVWF  FF6
01AC:  MOVLW  01
01AE:  ADDWFC FF7,F
01B0:  TBLRD*+
01B2:  MOVF   FF5,W
01B4:  BTFSC  0D.7
01B6:  BSF    FF2.7
01B8:  RETURN 0
01BA:  DATA 2B,47
01BC:  DATA 53,4D
01BE:  DATA 4C,4F
01C0:  DATA 43,41
01C2:  DATA 54,45
01C4:  DATA 00,00
01C6:  MOVFF  FF2,0D
01CA:  BCF    FF2.7
01CC:  CLRF   FF7
01CE:  ADDLW  E0
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  BTFSC  0D.7
01DC:  BSF    FF2.7
01DE:  RETURN 0
01E0:  DATA 2B,43
01E2:  DATA 55,52
01E4:  DATA 4C,49
01E6:  DATA 4D,00
01E8:  MOVFF  FF2,0D
01EC:  BCF    FF2.7
01EE:  CLRF   FF7
01F0:  ADDLW  02
01F2:  MOVWF  FF6
01F4:  MOVLW  02
01F6:  ADDWFC FF7,F
01F8:  TBLRD*+
01FA:  MOVF   FF5,W
01FC:  BTFSC  0D.7
01FE:  BSF    FF2.7
0200:  RETURN 0
0202:  DATA 2B,43
0204:  DATA 55,52
0206:  DATA 41,4C
0208:  DATA 4D,00
020A:  MOVFF  FF2,0D
020E:  BCF    FF2.7
0210:  CLRF   FF7
0212:  ADDLW  24
0214:  MOVWF  FF6
0216:  MOVLW  02
0218:  ADDWFC FF7,F
021A:  TBLRD*+
021C:  MOVF   FF5,W
021E:  BTFSC  0D.7
0220:  BSF    FF2.7
0222:  RETURN 0
0224:  DATA 2B,43
0226:  DATA 53,54
0228:  DATA 41,54
022A:  DATA 53,00
022C:  MOVFF  FF2,0D
0230:  BCF    FF2.7
0232:  CLRF   FF7
0234:  ADDLW  46
0236:  MOVWF  FF6
0238:  MOVLW  02
023A:  ADDWFC FF7,F
023C:  TBLRD*+
023E:  MOVF   FF5,W
0240:  BTFSC  0D.7
0242:  BSF    FF2.7
0244:  RETURN 0
0246:  DATA 2B,53
0248:  DATA 45,54
024A:  DATA 5A,45
024C:  DATA 52,4F
024E:  DATA 00,00
0250:  MOVFF  FF2,0D
0254:  BCF    FF2.7
0256:  CLRF   FF7
0258:  ADDLW  6A
025A:  MOVWF  FF6
025C:  MOVLW  02
025E:  ADDWFC FF7,F
0260:  TBLRD*+
0262:  MOVF   FF5,W
0264:  BTFSC  0D.7
0266:  BSF    FF2.7
0268:  RETURN 0
026A:  DATA 5A,45
026C:  DATA 52,4F
026E:  DATA 20,53
0270:  DATA 45,54
0272:  DATA 45,44
0274:  DATA 00,00
0276:  MOVFF  FF2,0D
027A:  BCF    FF2.7
027C:  CLRF   FF7
027E:  ADDLW  90
0280:  MOVWF  FF6
0282:  MOVLW  02
0284:  ADDWFC FF7,F
0286:  TBLRD*+
0288:  MOVF   FF5,W
028A:  BTFSC  0D.7
028C:  BSF    FF2.7
028E:  RETURN 0
0290:  DATA 41,54
0292:  DATA 2B,43
0294:  DATA 4D,47
0296:  DATA 46,3D
0298:  DATA 31,0D
029A:  DATA 0A,00
029C:  MOVFF  FF2,0D
02A0:  BCF    FF2.7
02A2:  CLRF   FF7
02A4:  ADDLW  B6
02A6:  MOVWF  FF6
02A8:  MOVLW  02
02AA:  ADDWFC FF7,F
02AC:  TBLRD*+
02AE:  MOVF   FF5,W
02B0:  BTFSC  0D.7
02B2:  BSF    FF2.7
02B4:  RETURN 0
02B6:  DATA 41,54
02B8:  DATA 2B,43
02BA:  DATA 53,4D
02BC:  DATA 50,3D
02BE:  DATA 31,37
02C0:  DATA 2C,32
02C2:  DATA 35,35
02C4:  DATA 2C,30
02C6:  DATA 2C,30
02C8:  DATA 0D,0A
02CA:  DATA 00,00
02CC:  MOVFF  FF2,0D
02D0:  BCF    FF2.7
02D2:  CLRF   FF7
02D4:  ADDLW  E6
02D6:  MOVWF  FF6
02D8:  MOVLW  02
02DA:  ADDWFC FF7,F
02DC:  TBLRD*+
02DE:  MOVF   FF5,W
02E0:  BTFSC  0D.7
02E2:  BSF    FF2.7
02E4:  RETURN 0
02E6:  DATA 2B,43
02E8:  DATA 4D,47
02EA:  DATA 53,3A
02EC:  DATA 00,00
02EE:  MOVFF  FF2,0D
02F2:  BCF    FF2.7
02F4:  CLRF   FF7
02F6:  ADDLW  08
02F8:  MOVWF  FF6
02FA:  MOVLW  03
02FC:  ADDWFC FF7,F
02FE:  TBLRD*+
0300:  MOVF   FF5,W
0302:  BTFSC  0D.7
0304:  BSF    FF2.7
0306:  RETURN 0
0308:  DATA 41,54
030A:  DATA 2B,43
030C:  DATA 4D,47
030E:  DATA 4C,3D
0310:  DATA 22,52
0312:  DATA 45,43
0314:  DATA 20,55
0316:  DATA 4E,52
0318:  DATA 45,41
031A:  DATA 44,22
031C:  DATA 0D,0A
031E:  DATA 00,00
0320:  MOVFF  FF2,0D
0324:  BCF    FF2.7
0326:  CLRF   FF7
0328:  ADDLW  3A
032A:  MOVWF  FF6
032C:  MOVLW  03
032E:  ADDWFC FF7,F
0330:  TBLRD*+
0332:  MOVF   FF5,W
0334:  BTFSC  0D.7
0336:  BSF    FF2.7
0338:  RETURN 0
033A:  DATA 41,54
033C:  DATA 2B,43
033E:  DATA 47,41
0340:  DATA 54,54
0342:  DATA 3D,31
0344:  DATA 0D,0A
0346:  DATA 00,00
0348:  MOVFF  FF2,0D
034C:  BCF    FF2.7
034E:  CLRF   FF7
0350:  ADDLW  62
0352:  MOVWF  FF6
0354:  MOVLW  03
0356:  ADDWFC FF7,F
0358:  TBLRD*+
035A:  MOVF   FF5,W
035C:  BTFSC  0D.7
035E:  BSF    FF2.7
0360:  RETURN 0
0362:  DATA 41,54
0364:  DATA 2B,53
0366:  DATA 41,50
0368:  DATA 42,52
036A:  DATA 3D,33
036C:  DATA 2C,31
036E:  DATA 2C,22
0370:  DATA 43,4F
0372:  DATA 4E,54
0374:  DATA 59,50
0376:  DATA 45,22
0378:  DATA 2C,22
037A:  DATA 47,50
037C:  DATA 52,53
037E:  DATA 22,0D
0380:  DATA 0A,00
0382:  MOVFF  FF2,0D
0386:  BCF    FF2.7
0388:  CLRF   FF7
038A:  ADDLW  9C
038C:  MOVWF  FF6
038E:  MOVLW  03
0390:  ADDWFC FF7,F
0392:  TBLRD*+
0394:  MOVF   FF5,W
0396:  BTFSC  0D.7
0398:  BSF    FF2.7
039A:  RETURN 0
039C:  DATA 41,54
039E:  DATA 2B,53
03A0:  DATA 41,50
03A2:  DATA 42,52
03A4:  DATA 3D,33
03A6:  DATA 2C,31
03A8:  DATA 2C,22
03AA:  DATA 41,50
03AC:  DATA 4E,22
03AE:  DATA 2C,22
03B0:  DATA 43,4D
03B2:  DATA 4E,45
03B4:  DATA 54,22
03B6:  DATA 0D,0A
03B8:  DATA 00,00
03BA:  MOVFF  FF2,0D
03BE:  BCF    FF2.7
03C0:  CLRF   FF7
03C2:  ADDLW  D4
03C4:  MOVWF  FF6
03C6:  MOVLW  03
03C8:  ADDWFC FF7,F
03CA:  TBLRD*+
03CC:  MOVF   FF5,W
03CE:  BTFSC  0D.7
03D0:  BSF    FF2.7
03D2:  RETURN 0
03D4:  DATA 41,54
03D6:  DATA 2B,53
03D8:  DATA 41,50
03DA:  DATA 42,52
03DC:  DATA 3D,31
03DE:  DATA 2C,31
03E0:  DATA 0D,0A
03E2:  DATA 00,00
03E4:  MOVFF  FF2,0D
03E8:  BCF    FF2.7
03EA:  CLRF   FF7
03EC:  ADDLW  FE
03EE:  MOVWF  FF6
03F0:  MOVLW  03
03F2:  ADDWFC FF7,F
03F4:  TBLRD*+
03F6:  MOVF   FF5,W
03F8:  BTFSC  0D.7
03FA:  BSF    FF2.7
03FC:  RETURN 0
03FE:  DATA 41,54
0400:  DATA 2B,53
0402:  DATA 41,50
0404:  DATA 42,52
0406:  DATA 3D,32
0408:  DATA 2C,31
040A:  DATA 0D,0A
040C:  DATA 00,00
040E:  MOVFF  FF2,0D
0412:  BCF    FF2.7
0414:  CLRF   FF7
0416:  ADDLW  28
0418:  MOVWF  FF6
041A:  MOVLW  04
041C:  ADDWFC FF7,F
041E:  TBLRD*+
0420:  MOVF   FF5,W
0422:  BTFSC  0D.7
0424:  BSF    FF2.7
0426:  RETURN 0
0428:  DATA 2B,53
042A:  DATA 41,50
042C:  DATA 42,52
042E:  DATA 3A,00
0430:  MOVFF  FF2,0D
0434:  BCF    FF2.7
0436:  CLRF   FF7
0438:  ADDLW  4A
043A:  MOVWF  FF6
043C:  MOVLW  04
043E:  ADDWFC FF7,F
0440:  TBLRD*+
0442:  MOVF   FF5,W
0444:  BTFSC  0D.7
0446:  BSF    FF2.7
0448:  RETURN 0
044A:  DATA 41,54
044C:  DATA 2B,43
044E:  DATA 4C,42
0450:  DATA 53,43
0452:  DATA 46,47
0454:  DATA 3D,30
0456:  DATA 2C,31
0458:  DATA 0D,0A
045A:  DATA 00,00
045C:  MOVFF  FF2,0D
0460:  BCF    FF2.7
0462:  CLRF   FF7
0464:  ADDLW  76
0466:  MOVWF  FF6
0468:  MOVLW  04
046A:  ADDWFC FF7,F
046C:  TBLRD*+
046E:  MOVF   FF5,W
0470:  BTFSC  0D.7
0472:  BSF    FF2.7
0474:  RETURN 0
0476:  DATA 2B,43
0478:  DATA 4C,42
047A:  DATA 53,43
047C:  DATA 46,47
047E:  DATA 3A,00
0480:  MOVFF  FF2,0D
0484:  BCF    FF2.7
0486:  CLRF   FF7
0488:  ADDLW  9A
048A:  MOVWF  FF6
048C:  MOVLW  04
048E:  ADDWFC FF7,F
0490:  TBLRD*+
0492:  MOVF   FF5,W
0494:  BTFSC  0D.7
0496:  BSF    FF2.7
0498:  RETURN 0
049A:  DATA 41,54
049C:  DATA 2B,43
049E:  DATA 4C,42
04A0:  DATA 53,3D
04A2:  DATA 31,2C
04A4:  DATA 31,0D
04A6:  DATA 0A,00
04A8:  MOVFF  FF2,0D
04AC:  BCF    FF2.7
04AE:  CLRF   FF7
04B0:  ADDLW  C2
04B2:  MOVWF  FF6
04B4:  MOVLW  04
04B6:  ADDWFC FF7,F
04B8:  TBLRD*+
04BA:  MOVF   FF5,W
04BC:  BTFSC  0D.7
04BE:  BSF    FF2.7
04C0:  RETURN 0
04C2:  DATA 2B,43
04C4:  DATA 4C,42
04C6:  DATA 53,3A
04C8:  DATA 00,00
04CA:  MOVFF  FF2,0D
04CE:  BCF    FF2.7
04D0:  CLRF   FF7
04D2:  ADDLW  E4
04D4:  MOVWF  FF6
04D6:  MOVLW  04
04D8:  ADDWFC FF7,F
04DA:  TBLRD*+
04DC:  MOVF   FF5,W
04DE:  BTFSC  0D.7
04E0:  BSF    FF2.7
04E2:  RETURN 0
04E4:  DATA 41,54
04E6:  DATA 2B,53
04E8:  DATA 41,50
04EA:  DATA 42,52
04EC:  DATA 3D,30
04EE:  DATA 2C,31
04F0:  DATA 0D,0A
04F2:  DATA 00,00
04F4:  MOVFF  FF2,0D
04F8:  BCF    FF2.7
04FA:  CLRF   FF7
04FC:  ADDLW  0E
04FE:  MOVWF  FF6
0500:  MOVLW  05
0502:  ADDWFC FF7,F
0504:  TBLRD*+
0506:  MOVF   FF5,W
0508:  BTFSC  0D.7
050A:  BSF    FF2.7
050C:  RETURN 0
050E:  DATA 30,33
0510:  DATA 31,39
0512:  DATA 39,35
0514:  DATA 38,32
0516:  DATA 32,37
0518:  DATA 33,39
051A:  DATA 00,00
051C:  MOVFF  FF2,0D
0520:  BCF    FF2.7
0522:  CLRF   FF7
0524:  ADDLW  36
0526:  MOVWF  FF6
0528:  MOVLW  05
052A:  ADDWFC FF7,F
052C:  TBLRD*+
052E:  MOVF   FF5,W
0530:  BTFSC  0D.7
0532:  BSF    FF2.7
0534:  RETURN 0
0536:  DATA 49,4E
0538:  DATA 49,43
053A:  DATA 49,41
053C:  DATA 4E,44
053E:  DATA 4F,2E
0540:  DATA 2E,2E
0542:  DATA 00,00
0544:  MOVFF  FF2,0D
0548:  BCF    FF2.7
054A:  CLRF   FF7
054C:  ADDLW  5E
054E:  MOVWF  FF6
0550:  MOVLW  05
0552:  ADDWFC FF7,F
0554:  TBLRD*+
0556:  MOVF   FF5,W
0558:  BTFSC  0D.7
055A:  BSF    FF2.7
055C:  RETURN 0
055E:  DATA 41,54
0560:  DATA 2B,43
0562:  DATA 4D,47
0564:  DATA 44,3D
0566:  DATA 31,2C
0568:  DATA 31,0D
056A:  DATA 0A,00
056C:  MOVFF  FF2,0D
0570:  BCF    FF2.7
0572:  CLRF   FF7
0574:  ADDLW  86
0576:  MOVWF  FF6
0578:  MOVLW  05
057A:  ADDWFC FF7,F
057C:  TBLRD*+
057E:  MOVF   FF5,W
0580:  BTFSC  0D.7
0582:  BSF    FF2.7
0584:  RETURN 0
0586:  DATA 21,21
0588:  DATA 21,41
058A:  DATA 4C,45
058C:  DATA 52,54
058E:  DATA 41,3A
0590:  DATA 20,42
0592:  DATA 61,74
0594:  DATA 65,72
0596:  DATA 69,61
0598:  DATA 20,65
059A:  DATA 6D,20
059C:  DATA 64,65
059E:  DATA 73,63
05A0:  DATA 61,72
05A2:  DATA 67,61
05A4:  DATA 20,72
05A6:  DATA 61,70
05A8:  DATA 69,64
05AA:  DATA 61,20
05AC:  DATA 56,45
05AE:  DATA 52,49
05B0:  DATA 46,49
05B2:  DATA 51,55
05B4:  DATA 45,20
05B6:  DATA 53,45
05B8:  DATA 55,20
05BA:  DATA 56,45
05BC:  DATA 49,43
05BE:  DATA 55,4C
05C0:  DATA 4F,21
05C2:  DATA 21,21
05C4:  DATA 00,00
*
0694:  DATA 43,6F
0696:  DATA 72,72
0698:  DATA 65,6E
069A:  DATA 74,65
069C:  DATA 20,4C
069E:  DATA 69,6D
06A0:  DATA 69,74
06A2:  DATA 65,20
06A4:  DATA 3D,20
06A6:  DATA 25,4C
06A8:  DATA 75,20
06AA:  DATA 6D,41
06AC:  DATA 00,00
06AE:  DATA 54,65
06B0:  DATA 6D,70
06B2:  DATA 6F,20
06B4:  DATA 45,6E
06B6:  DATA 74,72
06B8:  DATA 65,20
06BA:  DATA 41,6C
06BC:  DATA 65,72
06BE:  DATA 74,61
06C0:  DATA 73,20
06C2:  DATA 3D,20
06C4:  DATA 25,4C
06C6:  DATA 75,20
06C8:  DATA 6D,69
06CA:  DATA 6E,00
06CC:  DATA 54,65
06CE:  DATA 6D,70
06D0:  DATA 6F,20
06D2:  DATA 45,6E
06D4:  DATA 74,72
06D6:  DATA 65,20
06D8:  DATA 41,6C
06DA:  DATA 65,72
06DC:  DATA 74,61
06DE:  DATA 73,20
06E0:  DATA 3D,20
06E2:  DATA 25,4C
06E4:  DATA 75,20
06E6:  DATA 6D,69
06E8:  DATA 6E,20
06EA:  DATA 2F,20
06EC:  DATA 43,6F
06EE:  DATA 72,72
06F0:  DATA 65,6E
06F2:  DATA 74,65
06F4:  DATA 20,4C
06F6:  DATA 69,6D
06F8:  DATA 69,74
06FA:  DATA 65,20
06FC:  DATA 3D,20
06FE:  DATA 25,4C
0700:  DATA 75,20
0702:  DATA 6D,41
0704:  DATA 20,2F
0706:  DATA 20,43
0708:  DATA 6F,72
070A:  DATA 72,65
070C:  DATA 6E,74
070E:  DATA 65,20
0710:  DATA 41,74
0712:  DATA 75,61
0714:  DATA 6C,3A
0716:  DATA 20,25
0718:  DATA 36,2E
071A:  DATA 30,66
071C:  DATA 20,6D
071E:  DATA 41,20
0720:  DATA 2F,20
0722:  DATA 54,65
0724:  DATA 6E,73
0726:  DATA 61,6F
0728:  DATA 20,41
072A:  DATA 74,75
072C:  DATA 61,6C
072E:  DATA 3A,20
0730:  DATA 25,32
0732:  DATA 2E,32
0734:  DATA 66,20
0736:  DATA 56,00
0738:  DATA 41,54
073A:  DATA 2B,43
073C:  DATA 4D,47
073E:  DATA 53,3D
0740:  DATA 22,25
0742:  DATA 73,22
0744:  DATA 0D,0A
0746:  DATA 00,00
0748:  CLRF   01
074A:  CLRF   02
074C:  CLRF   00
074E:  CLRF   03
0750:  MOVLB  7
0752:  MOVF   x32,W
0754:  BNZ   075A
0756:  MOVF   x31,W
0758:  BZ    078A
075A:  MOVLW  10
075C:  MOVWF  x33
075E:  BCF    FD8.0
0760:  RLCF   x2F,F
0762:  RLCF   x30,F
0764:  RLCF   00,F
0766:  RLCF   03,F
0768:  MOVF   x32,W
076A:  SUBWF  03,W
076C:  BNZ   0772
076E:  MOVF   x31,W
0770:  SUBWF  00,W
0772:  BNC   0782
0774:  MOVF   x31,W
0776:  SUBWF  00,F
0778:  BTFSS  FD8.0
077A:  DECF   03,F
077C:  MOVF   x32,W
077E:  SUBWF  03,F
0780:  BSF    FD8.0
0782:  RLCF   01,F
0784:  RLCF   02,F
0786:  DECFSZ x33,F
0788:  BRA    075E
078A:  MOVLB  0
078C:  GOTO   080E (RETURN)
*
0932:  DATA 43,6F
0934:  DATA 72,72
0936:  DATA 65,6E
0938:  DATA 74,65
093A:  DATA 3A,20
093C:  DATA 25,36
093E:  DATA 2E,30
0940:  DATA 66,20
0942:  DATA 54,65
0944:  DATA 6E,73
0946:  DATA 61,6F
0948:  DATA 3A,20
094A:  DATA 25,32
094C:  DATA 2E,32
094E:  DATA 66,20
0950:  DATA 0D,0A
0952:  DATA 00,00
*
097E:  MOVFF  19C,FEA
0982:  MOVFF  19B,FE9
0986:  MOVLB  7
0988:  MOVFF  718,FEF
098C:  INCF   FE9,F
098E:  BTFSC  FD8.2
0990:  INCF   FEA,F
0992:  CLRF   FEF
0994:  MOVLB  1
0996:  INCF   x9B,F
0998:  BTFSC  FD8.2
099A:  INCF   x9C,F
099C:  MOVLB  0
099E:  RETURN 0
09A0:  TBLRD*+
09A2:  MOVFF  FF6,716
09A6:  MOVFF  FF7,717
09AA:  MOVFF  FF5,718
09AE:  RCALL  097E
09B0:  MOVFF  716,FF6
09B4:  MOVFF  717,FF7
09B8:  MOVLB  7
09BA:  DECFSZ x15,F
09BC:  BRA    09C0
09BE:  BRA    09C4
09C0:  MOVLB  0
09C2:  BRA    09A0
09C4:  MOVLB  0
09C6:  RETURN 0
09C8:  MOVF   FEF,F
09CA:  BZ    09EA
09CC:  MOVFF  FEA,716
09D0:  MOVFF  FE9,715
09D4:  MOVFF  FEF,718
09D8:  RCALL  097E
09DA:  MOVFF  716,FEA
09DE:  MOVFF  715,FE9
09E2:  INCF   FE9,F
09E4:  BTFSC  FD8.2
09E6:  INCF   FEA,F
09E8:  BRA    09C8
09EA:  GOTO   0BC4 (RETURN)
09EE:  MOVF   FEF,F
09F0:  BZ    0A12
09F2:  MOVFF  FEA,725
09F6:  MOVFF  FE9,724
09FA:  MOVF   FEF,W
09FC:  BTFSS  F9E.4
09FE:  BRA    09FC
0A00:  MOVWF  FAD
0A02:  MOVFF  725,FEA
0A06:  MOVFF  724,FE9
0A0A:  INCF   FE9,F
0A0C:  BTFSC  FD8.2
0A0E:  INCF   FEA,F
0A10:  BRA    09EE
0A12:  GOTO   0ADA (RETURN)
*
0E14:  MOVLW  8E
0E16:  MOVWF  00
0E18:  MOVFF  69D,01
0E1C:  MOVFF  69C,02
0E20:  CLRF   03
0E22:  MOVF   01,F
0E24:  BNZ   0E38
0E26:  MOVFF  02,01
0E2A:  CLRF   02
0E2C:  MOVLW  08
0E2E:  SUBWF  00,F
0E30:  MOVF   01,F
0E32:  BNZ   0E38
0E34:  CLRF   00
0E36:  BRA    0E48
0E38:  BCF    FD8.0
0E3A:  BTFSC  01.7
0E3C:  BRA    0E46
0E3E:  RLCF   02,F
0E40:  RLCF   01,F
0E42:  DECF   00,F
0E44:  BRA    0E38
0E46:  BCF    01.7
0E48:  RETURN 0
0E4A:  MOVLB  6
0E4C:  MOVF   xBE,W
0E4E:  BTFSC  FD8.2
0E50:  BRA    0F34
0E52:  MOVWF  00
0E54:  MOVF   xC2,W
0E56:  BTFSC  FD8.2
0E58:  BRA    0F34
0E5A:  ADDWF  00,F
0E5C:  BNC   0E66
0E5E:  MOVLW  81
0E60:  ADDWF  00,F
0E62:  BC    0F34
0E64:  BRA    0E6E
0E66:  MOVLW  7F
0E68:  SUBWF  00,F
0E6A:  BNC   0F34
0E6C:  BZ    0F34
0E6E:  MOVFF  6BF,6C6
0E72:  MOVF   xC3,W
0E74:  XORWF  xC6,F
0E76:  BSF    xBF.7
0E78:  BSF    xC3.7
0E7A:  MOVF   xC1,W
0E7C:  MULWF  xC5
0E7E:  MOVFF  FF4,6C8
0E82:  MOVF   xC0,W
0E84:  MULWF  xC4
0E86:  MOVFF  FF4,03
0E8A:  MOVFF  FF3,6C7
0E8E:  MULWF  xC5
0E90:  MOVF   FF3,W
0E92:  ADDWF  xC8,F
0E94:  MOVF   FF4,W
0E96:  ADDWFC xC7,F
0E98:  MOVLW  00
0E9A:  ADDWFC 03,F
0E9C:  MOVF   xC1,W
0E9E:  MULWF  xC4
0EA0:  MOVF   FF3,W
0EA2:  ADDWF  xC8,F
0EA4:  MOVF   FF4,W
0EA6:  ADDWFC xC7,F
0EA8:  MOVLW  00
0EAA:  CLRF   02
0EAC:  ADDWFC 03,F
0EAE:  ADDWFC 02,F
0EB0:  MOVF   xBF,W
0EB2:  MULWF  xC5
0EB4:  MOVF   FF3,W
0EB6:  ADDWF  xC7,F
0EB8:  MOVF   FF4,W
0EBA:  ADDWFC 03,F
0EBC:  MOVLW  00
0EBE:  ADDWFC 02,F
0EC0:  MOVF   xBF,W
0EC2:  MULWF  xC4
0EC4:  MOVF   FF3,W
0EC6:  ADDWF  03,F
0EC8:  MOVF   FF4,W
0ECA:  ADDWFC 02,F
0ECC:  MOVLW  00
0ECE:  CLRF   01
0ED0:  ADDWFC 01,F
0ED2:  MOVF   xC1,W
0ED4:  MULWF  xC3
0ED6:  MOVF   FF3,W
0ED8:  ADDWF  xC7,F
0EDA:  MOVF   FF4,W
0EDC:  ADDWFC 03,F
0EDE:  MOVLW  00
0EE0:  ADDWFC 02,F
0EE2:  ADDWFC 01,F
0EE4:  MOVF   xC0,W
0EE6:  MULWF  xC3
0EE8:  MOVF   FF3,W
0EEA:  ADDWF  03,F
0EEC:  MOVF   FF4,W
0EEE:  ADDWFC 02,F
0EF0:  MOVLW  00
0EF2:  ADDWFC 01,F
0EF4:  MOVF   xBF,W
0EF6:  MULWF  xC3
0EF8:  MOVF   FF3,W
0EFA:  ADDWF  02,F
0EFC:  MOVF   FF4,W
0EFE:  ADDWFC 01,F
0F00:  INCF   00,F
0F02:  BTFSC  01.7
0F04:  BRA    0F10
0F06:  RLCF   xC7,F
0F08:  RLCF   03,F
0F0A:  RLCF   02,F
0F0C:  RLCF   01,F
0F0E:  DECF   00,F
0F10:  MOVLW  00
0F12:  BTFSS  xC7.7
0F14:  BRA    0F2A
0F16:  INCF   03,F
0F18:  ADDWFC 02,F
0F1A:  ADDWFC 01,F
0F1C:  MOVF   01,W
0F1E:  BNZ   0F2A
0F20:  MOVF   02,W
0F22:  BNZ   0F2A
0F24:  MOVF   03,W
0F26:  BNZ   0F2A
0F28:  INCF   00,F
0F2A:  BTFSC  xC6.7
0F2C:  BSF    01.7
0F2E:  BTFSS  xC6.7
0F30:  BCF    01.7
0F32:  BRA    0F3C
0F34:  CLRF   00
0F36:  CLRF   01
0F38:  CLRF   02
0F3A:  CLRF   03
0F3C:  MOVLB  0
0F3E:  RETURN 0
0F40:  MOVLW  80
0F42:  BTFSS  FD8.1
0F44:  BRA    0F4A
0F46:  MOVLB  6
0F48:  XORWF  xA1,F
0F4A:  MOVLB  6
0F4C:  CLRF   xA6
0F4E:  CLRF   xA7
0F50:  MOVFF  69D,6A5
0F54:  MOVF   xA1,W
0F56:  XORWF  xA5,F
0F58:  MOVF   x9C,W
0F5A:  BTFSC  FD8.2
0F5C:  BRA    111C
0F5E:  MOVWF  xA4
0F60:  MOVWF  00
0F62:  MOVF   xA0,W
0F64:  BTFSC  FD8.2
0F66:  BRA    112E
0F68:  SUBWF  xA4,F
0F6A:  BTFSC  FD8.2
0F6C:  BRA    1074
0F6E:  BNC   0FEC
0F70:  MOVFF  6A1,6AA
0F74:  BSF    xAA.7
0F76:  MOVFF  6A2,6A9
0F7A:  MOVFF  6A3,6A8
0F7E:  CLRF   xA7
0F80:  BCF    FD8.0
0F82:  RRCF   xAA,F
0F84:  RRCF   xA9,F
0F86:  RRCF   xA8,F
0F88:  RRCF   xA7,F
0F8A:  DECFSZ xA4,F
0F8C:  BRA    0F7E
0F8E:  BTFSS  xA5.7
0F90:  BRA    0F98
0F92:  BSF    xA6.0
0F94:  BRA    1156
0F96:  BCF    xA6.0
0F98:  BCF    xA4.0
0F9A:  BSF    xA6.4
0F9C:  MOVLW  06
0F9E:  MOVWF  FEA
0FA0:  MOVLW  9F
0FA2:  MOVWF  FE9
0FA4:  BRA    117C
0FA6:  BCF    xA6.4
0FA8:  BTFSC  xA5.7
0FAA:  BRA    0FC0
0FAC:  BTFSS  xA4.0
0FAE:  BRA    0FD6
0FB0:  RRCF   xAA,F
0FB2:  RRCF   xA9,F
0FB4:  RRCF   xA8,F
0FB6:  RRCF   xA7,F
0FB8:  INCF   00,F
0FBA:  BTFSC  FD8.2
0FBC:  BRA    114C
0FBE:  BRA    0FD6
0FC0:  BTFSC  xAA.7
0FC2:  BRA    0FDC
0FC4:  BCF    FD8.0
0FC6:  RLCF   xA7,F
0FC8:  RLCF   xA8,F
0FCA:  RLCF   xA9,F
0FCC:  RLCF   xAA,F
0FCE:  DECF   00,F
0FD0:  BTFSC  FD8.2
0FD2:  BRA    114C
0FD4:  BRA    0FC0
0FD6:  BSF    xA6.6
0FD8:  BRA    10B4
0FDA:  BCF    xA6.6
0FDC:  MOVFF  69D,6A5
0FE0:  BTFSS  x9D.7
0FE2:  BRA    0FE8
0FE4:  BSF    xAA.7
0FE6:  BRA    113E
0FE8:  BCF    xAA.7
0FEA:  BRA    113E
0FEC:  MOVFF  6A0,6A4
0FF0:  MOVFF  6A0,00
0FF4:  MOVF   x9C,W
0FF6:  SUBWF  xA4,F
0FF8:  MOVFF  69D,6AA
0FFC:  BSF    xAA.7
0FFE:  MOVFF  69E,6A9
1002:  MOVFF  69F,6A8
1006:  CLRF   xA7
1008:  BCF    FD8.0
100A:  RRCF   xAA,F
100C:  RRCF   xA9,F
100E:  RRCF   xA8,F
1010:  RRCF   xA7,F
1012:  DECFSZ xA4,F
1014:  BRA    1006
1016:  BTFSS  xA5.7
1018:  BRA    1020
101A:  BSF    xA6.1
101C:  BRA    1156
101E:  BCF    xA6.1
1020:  BCF    xA4.0
1022:  BSF    xA6.5
1024:  MOVLW  06
1026:  MOVWF  FEA
1028:  MOVLW  A3
102A:  MOVWF  FE9
102C:  BRA    117C
102E:  BCF    xA6.5
1030:  BTFSC  xA5.7
1032:  BRA    1048
1034:  BTFSS  xA4.0
1036:  BRA    105E
1038:  RRCF   xAA,F
103A:  RRCF   xA9,F
103C:  RRCF   xA8,F
103E:  RRCF   xA7,F
1040:  INCF   00,F
1042:  BTFSC  FD8.2
1044:  BRA    114C
1046:  BRA    105E
1048:  BTFSC  xAA.7
104A:  BRA    1064
104C:  BCF    FD8.0
104E:  RLCF   xA7,F
1050:  RLCF   xA8,F
1052:  RLCF   xA9,F
1054:  RLCF   xAA,F
1056:  DECF   00,F
1058:  BTFSC  FD8.2
105A:  BRA    114C
105C:  BRA    1048
105E:  BSF    xA6.7
1060:  BRA    10B4
1062:  BCF    xA6.7
1064:  MOVFF  6A1,6A5
1068:  BTFSS  xA1.7
106A:  BRA    1070
106C:  BSF    xAA.7
106E:  BRA    113E
1070:  BCF    xAA.7
1072:  BRA    113E
1074:  MOVFF  6A1,6AA
1078:  BSF    xAA.7
107A:  MOVFF  6A2,6A9
107E:  MOVFF  6A3,6A8
1082:  BTFSS  xA5.7
1084:  BRA    108E
1086:  BCF    xAA.7
1088:  BSF    xA6.2
108A:  BRA    1156
108C:  BCF    xA6.2
108E:  CLRF   xA7
1090:  BCF    xA4.0
1092:  MOVLW  06
1094:  MOVWF  FEA
1096:  MOVLW  9F
1098:  MOVWF  FE9
109A:  BRA    117C
109C:  BTFSC  xA5.7
109E:  BRA    10D8
10A0:  MOVFF  69D,6A5
10A4:  BTFSS  xA4.0
10A6:  BRA    10B4
10A8:  RRCF   xAA,F
10AA:  RRCF   xA9,F
10AC:  RRCF   xA8,F
10AE:  RRCF   xA7,F
10B0:  INCF   00,F
10B2:  BZ    114C
10B4:  BTFSS  xA7.7
10B6:  BRA    10CE
10B8:  INCF   xA8,F
10BA:  BNZ   10CE
10BC:  INCF   xA9,F
10BE:  BNZ   10CE
10C0:  INCF   xAA,F
10C2:  BNZ   10CE
10C4:  RRCF   xAA,F
10C6:  RRCF   xA9,F
10C8:  RRCF   xA8,F
10CA:  INCF   00,F
10CC:  BZ    114C
10CE:  BTFSC  xA6.6
10D0:  BRA    0FDA
10D2:  BTFSC  xA6.7
10D4:  BRA    1062
10D6:  BRA    1110
10D8:  MOVLW  80
10DA:  XORWF  xAA,F
10DC:  BTFSS  xAA.7
10DE:  BRA    10E8
10E0:  BRA    1156
10E2:  MOVFF  6A1,6A5
10E6:  BRA    10FC
10E8:  MOVFF  69D,6A5
10EC:  MOVF   xAA,F
10EE:  BNZ   10FC
10F0:  MOVF   xA9,F
10F2:  BNZ   10FC
10F4:  MOVF   xA8,F
10F6:  BNZ   10FC
10F8:  CLRF   00
10FA:  BRA    113E
10FC:  BTFSC  xAA.7
10FE:  BRA    1110
1100:  BCF    FD8.0
1102:  RLCF   xA7,F
1104:  RLCF   xA8,F
1106:  RLCF   xA9,F
1108:  RLCF   xAA,F
110A:  DECFSZ 00,F
110C:  BRA    10FC
110E:  BRA    114C
1110:  BTFSS  xA5.7
1112:  BRA    1118
1114:  BSF    xAA.7
1116:  BRA    113E
1118:  BCF    xAA.7
111A:  BRA    113E
111C:  MOVFF  6A0,00
1120:  MOVFF  6A1,6AA
1124:  MOVFF  6A2,6A9
1128:  MOVFF  6A3,6A8
112C:  BRA    113E
112E:  MOVFF  69C,00
1132:  MOVFF  69D,6AA
1136:  MOVFF  69E,6A9
113A:  MOVFF  69F,6A8
113E:  MOVFF  6AA,01
1142:  MOVFF  6A9,02
1146:  MOVFF  6A8,03
114A:  BRA    11B4
114C:  CLRF   00
114E:  CLRF   01
1150:  CLRF   02
1152:  CLRF   03
1154:  BRA    11B4
1156:  CLRF   xA7
1158:  COMF   xA8,F
115A:  COMF   xA9,F
115C:  COMF   xAA,F
115E:  COMF   xA7,F
1160:  INCF   xA7,F
1162:  BNZ   116E
1164:  INCF   xA8,F
1166:  BNZ   116E
1168:  INCF   xA9,F
116A:  BNZ   116E
116C:  INCF   xAA,F
116E:  BTFSC  xA6.0
1170:  BRA    0F96
1172:  BTFSC  xA6.1
1174:  BRA    101E
1176:  BTFSC  xA6.2
1178:  BRA    108C
117A:  BRA    10E2
117C:  MOVF   FEF,W
117E:  ADDWF  xA8,F
1180:  BNC   118C
1182:  INCF   xA9,F
1184:  BNZ   118C
1186:  INCF   xAA,F
1188:  BTFSC  FD8.2
118A:  BSF    xA4.0
118C:  MOVF   FED,F
118E:  MOVF   FEF,W
1190:  ADDWF  xA9,F
1192:  BNC   119A
1194:  INCF   xAA,F
1196:  BTFSC  FD8.2
1198:  BSF    xA4.0
119A:  MOVF   FED,F
119C:  MOVF   FEF,W
119E:  BTFSC  FEF.7
11A0:  BRA    11A4
11A2:  XORLW  80
11A4:  ADDWF  xAA,F
11A6:  BTFSC  FD8.0
11A8:  BSF    xA4.0
11AA:  BTFSC  xA6.4
11AC:  BRA    0FA6
11AE:  BTFSC  xA6.5
11B0:  BRA    102E
11B2:  BRA    109C
11B4:  MOVLB  0
11B6:  RETURN 0
11B8:  MOVFF  69D,6A4
11BC:  MOVLB  6
11BE:  MOVF   xA1,W
11C0:  XORWF  xA4,F
11C2:  BTFSS  xA4.7
11C4:  BRA    11D0
11C6:  BCF    FD8.2
11C8:  BCF    FD8.0
11CA:  BTFSC  x9D.7
11CC:  BSF    FD8.0
11CE:  BRA    122E
11D0:  MOVFF  69D,6A4
11D4:  MOVFF  6A0,6A5
11D8:  MOVF   x9C,W
11DA:  SUBWF  xA5,F
11DC:  BZ    11EA
11DE:  BTFSS  xA4.7
11E0:  BRA    122E
11E2:  MOVF   FD8,W
11E4:  XORLW  01
11E6:  MOVWF  FD8
11E8:  BRA    122E
11EA:  MOVFF  6A1,6A5
11EE:  MOVF   x9D,W
11F0:  SUBWF  xA5,F
11F2:  BZ    1200
11F4:  BTFSS  xA4.7
11F6:  BRA    122E
11F8:  MOVF   FD8,W
11FA:  XORLW  01
11FC:  MOVWF  FD8
11FE:  BRA    122E
1200:  MOVFF  6A2,6A5
1204:  MOVF   x9E,W
1206:  SUBWF  xA5,F
1208:  BZ    1216
120A:  BTFSS  xA4.7
120C:  BRA    122E
120E:  MOVF   FD8,W
1210:  XORLW  01
1212:  MOVWF  FD8
1214:  BRA    122E
1216:  MOVFF  6A3,6A5
121A:  MOVF   x9F,W
121C:  SUBWF  xA5,F
121E:  BZ    122C
1220:  BTFSS  xA4.7
1222:  BRA    122E
1224:  MOVF   FD8,W
1226:  XORLW  01
1228:  MOVWF  FD8
122A:  BRA    122E
122C:  BCF    FD8.0
122E:  MOVLB  0
1230:  RETURN 0
1232:  MOVLB  6
1234:  MOVF   xBE,W
1236:  SUBLW  B6
1238:  MOVWF  xBE
123A:  CLRF   03
123C:  MOVFF  6BF,6C2
1240:  BSF    xBF.7
1242:  BCF    FD8.0
1244:  RRCF   xBF,F
1246:  RRCF   xC0,F
1248:  RRCF   xC1,F
124A:  RRCF   03,F
124C:  RRCF   02,F
124E:  RRCF   01,F
1250:  RRCF   00,F
1252:  DECFSZ xBE,F
1254:  BRA    1242
1256:  BTFSS  xC2.7
1258:  BRA    1270
125A:  COMF   00,F
125C:  COMF   01,F
125E:  COMF   02,F
1260:  COMF   03,F
1262:  INCF   00,F
1264:  BTFSC  FD8.2
1266:  INCF   01,F
1268:  BTFSC  FD8.2
126A:  INCF   02,F
126C:  BTFSC  FD8.2
126E:  INCF   03,F
1270:  MOVLB  0
1272:  GOTO   1360 (RETURN)
1276:  BTFSC  FD8.1
1278:  BRA    1282
127A:  MOVLW  06
127C:  MOVWF  FEA
127E:  MOVLW  C6
1280:  MOVWF  FE9
1282:  CLRF   00
1284:  CLRF   01
1286:  CLRF   02
1288:  CLRF   03
128A:  MOVLB  6
128C:  CLRF   xC6
128E:  CLRF   xC7
1290:  CLRF   xC8
1292:  CLRF   xC9
1294:  MOVF   xC5,W
1296:  IORWF  xC4,W
1298:  IORWF  xC3,W
129A:  IORWF  xC2,W
129C:  BZ    12F6
129E:  MOVLW  20
12A0:  MOVWF  xCA
12A2:  BCF    FD8.0
12A4:  RLCF   xBE,F
12A6:  RLCF   xBF,F
12A8:  RLCF   xC0,F
12AA:  RLCF   xC1,F
12AC:  RLCF   xC6,F
12AE:  RLCF   xC7,F
12B0:  RLCF   xC8,F
12B2:  RLCF   xC9,F
12B4:  MOVF   xC5,W
12B6:  SUBWF  xC9,W
12B8:  BNZ   12CA
12BA:  MOVF   xC4,W
12BC:  SUBWF  xC8,W
12BE:  BNZ   12CA
12C0:  MOVF   xC3,W
12C2:  SUBWF  xC7,W
12C4:  BNZ   12CA
12C6:  MOVF   xC2,W
12C8:  SUBWF  xC6,W
12CA:  BNC   12EA
12CC:  MOVF   xC2,W
12CE:  SUBWF  xC6,F
12D0:  MOVF   xC3,W
12D2:  BTFSS  FD8.0
12D4:  INCFSZ xC3,W
12D6:  SUBWF  xC7,F
12D8:  MOVF   xC4,W
12DA:  BTFSS  FD8.0
12DC:  INCFSZ xC4,W
12DE:  SUBWF  xC8,F
12E0:  MOVF   xC5,W
12E2:  BTFSS  FD8.0
12E4:  INCFSZ xC5,W
12E6:  SUBWF  xC9,F
12E8:  BSF    FD8.0
12EA:  RLCF   00,F
12EC:  RLCF   01,F
12EE:  RLCF   02,F
12F0:  RLCF   03,F
12F2:  DECFSZ xCA,F
12F4:  BRA    12A2
12F6:  MOVFF  6C6,FEF
12FA:  MOVFF  6C7,FEC
12FE:  MOVFF  6C8,FEC
1302:  MOVFF  6C9,FEC
1306:  MOVLB  0
1308:  RETURN 0
130A:  MOVF   FE9,W
130C:  MOVLB  6
130E:  MOVWF  xB6
1310:  MOVF   xB5,W
1312:  MOVWF  xB8
1314:  BZ    134C
1316:  MOVFF  6B4,6C1
131A:  MOVFF  6B3,6C0
131E:  MOVFF  6B2,6BF
1322:  MOVFF  6B1,6BE
1326:  CLRF   xC5
1328:  CLRF   xC4
132A:  MOVLW  20
132C:  MOVWF  xC3
132E:  MOVLW  82
1330:  MOVWF  xC2
1332:  MOVLB  0
1334:  RCALL  0E4A
1336:  MOVFF  03,6B4
133A:  MOVFF  02,6B3
133E:  MOVFF  01,6B2
1342:  MOVFF  00,6B1
1346:  MOVLB  6
1348:  DECFSZ xB8,F
134A:  BRA    1316
134C:  MOVFF  6B4,6C1
1350:  MOVFF  6B3,6C0
1354:  MOVFF  6B2,6BF
1358:  MOVFF  6B1,6BE
135C:  MOVLB  0
135E:  BRA    1232
1360:  MOVFF  03,6B4
1364:  MOVFF  02,6B3
1368:  MOVFF  01,6B2
136C:  MOVFF  00,6B1
1370:  MOVLB  6
1372:  BTFSS  xB4.7
1374:  BRA    1390
1376:  DECF   xB6,F
1378:  BSF    xB6.5
137A:  COMF   xB1,F
137C:  COMF   xB2,F
137E:  COMF   xB3,F
1380:  COMF   xB4,F
1382:  INCF   xB1,F
1384:  BTFSC  FD8.2
1386:  INCF   xB2,F
1388:  BTFSC  FD8.2
138A:  INCF   xB3,F
138C:  BTFSC  FD8.2
138E:  INCF   xB4,F
1390:  MOVLW  3B
1392:  MOVWF  xBD
1394:  MOVLW  9A
1396:  MOVWF  xBC
1398:  MOVLW  CA
139A:  MOVWF  xBB
139C:  CLRF   xBA
139E:  MOVLW  0A
13A0:  MOVWF  xB8
13A2:  MOVF   xB5,W
13A4:  BTFSC  FD8.2
13A6:  INCF   xB6,F
13A8:  BSF    FD8.1
13AA:  MOVLW  06
13AC:  MOVWF  FEA
13AE:  MOVLW  B1
13B0:  MOVWF  FE9
13B2:  MOVFF  6B4,6C1
13B6:  MOVFF  6B3,6C0
13BA:  MOVFF  6B2,6BF
13BE:  MOVFF  6B1,6BE
13C2:  MOVFF  6BD,6C5
13C6:  MOVFF  6BC,6C4
13CA:  MOVFF  6BB,6C3
13CE:  MOVFF  6BA,6C2
13D2:  MOVLB  0
13D4:  RCALL  1276
13D6:  MOVF   01,W
13D8:  MOVF   00,F
13DA:  BNZ   1402
13DC:  MOVLB  6
13DE:  INCF   xB5,W
13E0:  SUBWF  xB8,W
13E2:  BTFSS  FD8.2
13E4:  BRA    13EA
13E6:  MOVLB  0
13E8:  BRA    1402
13EA:  MOVF   xB6,W
13EC:  BZ    1408
13EE:  ANDLW  0F
13F0:  SUBWF  xB8,W
13F2:  BZ    13F6
13F4:  BC    1484
13F6:  BTFSC  xB6.7
13F8:  BRA    1484
13FA:  BTFSC  xB6.6
13FC:  BRA    1408
13FE:  MOVLW  20
1400:  BRA    1476
1402:  MOVLW  20
1404:  MOVLB  6
1406:  ANDWF  xB6,F
1408:  BTFSS  xB6.5
140A:  BRA    142C
140C:  BCF    xB6.5
140E:  MOVF   xB5,W
1410:  BTFSS  FD8.2
1412:  DECF   xB6,F
1414:  MOVF   00,W
1416:  MOVWF  xB6
1418:  MOVLW  2D
141A:  MOVLB  7
141C:  MOVWF  x18
141E:  MOVLB  0
1420:  CALL   097E
1424:  MOVLB  6
1426:  MOVF   xB6,W
1428:  MOVWF  00
142A:  CLRF   xB6
142C:  MOVF   xB5,W
142E:  SUBWF  xB8,W
1430:  BNZ   144E
1432:  MOVF   00,W
1434:  MOVWF  xB6
1436:  MOVLW  2E
1438:  MOVLB  7
143A:  MOVWF  x18
143C:  MOVLB  0
143E:  CALL   097E
1442:  MOVLB  6
1444:  MOVF   xB6,W
1446:  MOVWF  00
1448:  MOVLW  20
144A:  ANDWF  xB6,F
144C:  MOVLW  00
144E:  MOVLW  30
1450:  BTFSS  xB6.5
1452:  BRA    1476
1454:  BCF    xB6.5
1456:  MOVF   xB5,W
1458:  BTFSS  FD8.2
145A:  DECF   xB6,F
145C:  MOVF   00,W
145E:  MOVWF  xB6
1460:  MOVLW  2D
1462:  MOVLB  7
1464:  MOVWF  x18
1466:  MOVLB  0
1468:  CALL   097E
146C:  MOVLB  6
146E:  MOVF   xB6,W
1470:  MOVWF  00
1472:  CLRF   xB6
1474:  MOVLW  30
1476:  ADDWF  00,F
1478:  MOVFF  00,718
147C:  MOVLB  0
147E:  CALL   097E
1482:  MOVLB  6
1484:  BCF    FD8.1
1486:  MOVFF  6BD,6C1
148A:  MOVFF  6BC,6C0
148E:  MOVFF  6BB,6BF
1492:  MOVFF  6BA,6BE
1496:  CLRF   xC5
1498:  CLRF   xC4
149A:  CLRF   xC3
149C:  MOVLW  0A
149E:  MOVWF  xC2
14A0:  MOVLB  0
14A2:  RCALL  1276
14A4:  MOVFF  03,6BD
14A8:  MOVFF  02,6BC
14AC:  MOVFF  01,6BB
14B0:  MOVFF  00,6BA
14B4:  MOVLB  6
14B6:  DECFSZ xB8,F
14B8:  BRA    13A8
14BA:  MOVLB  0
14BC:  RETURN 0
*
1506:  MOVF   FEF,F
1508:  BZ    1528
150A:  MOVFF  FEA,69D
150E:  MOVFF  FE9,69C
1512:  MOVFF  FEF,69E
1516:  BRA    14BE
1518:  MOVFF  69D,FEA
151C:  MOVFF  69C,FE9
1520:  INCF   FE9,F
1522:  BTFSC  FD8.2
1524:  INCF   FEA,F
1526:  BRA    1506
1528:  GOTO   1864 (RETURN)
*
1B44:  TSTFSZ 01
1B46:  BRA    1B4E
1B48:  TSTFSZ 02
1B4A:  BRA    1B50
1B4C:  BRA    1B5C
1B4E:  INCF   02,F
1B50:  MOVFF  00,FEE
1B54:  DECFSZ 01,F
1B56:  BRA    1B50
1B58:  DECFSZ 02,F
1B5A:  BRA    1B50
1B5C:  RETURN 0
*
20A6:  MOVLB  6
20A8:  CLRF   xCD
20AA:  CLRF   xCE
20AC:  MOVLW  01
20AE:  MOVWF  xCF
20B0:  CLRF   FDA
20B2:  CLRF   FD9
20B4:  MOVLW  06
20B6:  MOVWF  xD2
20B8:  MOVLW  C5
20BA:  MOVWF  xD1
20BC:  MOVLW  06
20BE:  MOVWF  FEA
20C0:  MOVLW  C9
20C2:  MOVWF  FE9
20C4:  MOVFF  6D2,FE2
20C8:  MOVFF  6D1,FE1
20CC:  MOVFF  6CF,6D0
20D0:  BCF    FD8.0
20D2:  MOVF   FE5,W
20D4:  MULWF  FEE
20D6:  MOVF   FF3,W
20D8:  ADDWFC xCD,F
20DA:  MOVF   FF4,W
20DC:  ADDWFC xCE,F
20DE:  DECFSZ xD0,F
20E0:  BRA    20D0
20E2:  MOVFF  6CD,FDE
20E6:  MOVFF  6CE,6CD
20EA:  CLRF   xCE
20EC:  BTFSC  FD8.0
20EE:  INCF   xCE,F
20F0:  INCF   xD1,F
20F2:  BTFSC  FD8.2
20F4:  INCF   xD2,F
20F6:  INCF   xCF,F
20F8:  MOVF   xCF,W
20FA:  SUBLW  05
20FC:  BNZ   20BC
20FE:  MOVLB  0
2100:  RETURN 0
*
21F4:  MOVF   FE9,W
21F6:  MOVLB  6
21F8:  MOVWF  xB5
21FA:  MOVLW  3B
21FC:  MOVWF  xBC
21FE:  MOVLW  9A
2200:  MOVWF  xBB
2202:  MOVLW  CA
2204:  MOVWF  xBA
2206:  CLRF   xB9
2208:  MOVLW  0A
220A:  MOVWF  xB7
220C:  BSF    FD8.1
220E:  MOVLW  06
2210:  MOVWF  FEA
2212:  MOVLW  B1
2214:  MOVWF  FE9
2216:  MOVFF  6B4,6C1
221A:  MOVFF  6B3,6C0
221E:  MOVFF  6B2,6BF
2222:  MOVFF  6B1,6BE
2226:  MOVFF  6BC,6C5
222A:  MOVFF  6BB,6C4
222E:  MOVFF  6BA,6C3
2232:  MOVFF  6B9,6C2
2236:  MOVLB  0
2238:  CALL   1276
223C:  MOVF   01,W
223E:  MOVF   00,F
2240:  BNZ   2268
2242:  MOVLB  6
2244:  MOVF   xB7,W
2246:  XORLW  01
2248:  BTFSS  FD8.2
224A:  BRA    2250
224C:  MOVLB  0
224E:  BRA    2268
2250:  MOVF   xB5,W
2252:  BZ    226C
2254:  ANDLW  0F
2256:  SUBWF  xB7,W
2258:  BZ    225C
225A:  BC    227C
225C:  BTFSC  xB5.7
225E:  BRA    227C
2260:  BTFSC  xB5.6
2262:  BRA    226C
2264:  MOVLW  20
2266:  BRA    226E
2268:  MOVLB  6
226A:  CLRF   xB5
226C:  MOVLW  30
226E:  ADDWF  00,F
2270:  MOVFF  00,718
2274:  MOVLB  0
2276:  CALL   097E
227A:  MOVLB  6
227C:  BCF    FD8.1
227E:  MOVFF  6BC,6C1
2282:  MOVFF  6BB,6C0
2286:  MOVFF  6BA,6BF
228A:  MOVFF  6B9,6BE
228E:  CLRF   xC5
2290:  CLRF   xC4
2292:  CLRF   xC3
2294:  MOVLW  0A
2296:  MOVWF  xC2
2298:  MOVLB  0
229A:  CALL   1276
229E:  MOVFF  03,6BC
22A2:  MOVFF  02,6BB
22A6:  MOVFF  01,6BA
22AA:  MOVFF  00,6B9
22AE:  MOVLB  6
22B0:  DECFSZ xB7,F
22B2:  BRA    220C
22B4:  MOVLB  0
22B6:  RETURN 0
*
2AC6:  MOVLW  B6
2AC8:  MOVWF  00
2ACA:  CLRF   03
2ACC:  CLRF   02
2ACE:  CLRF   01
2AD0:  MOVLB  6
2AD2:  MOVF   x97,W
2AD4:  IORWF  x98,W
2AD6:  IORWF  x99,W
2AD8:  IORWF  x9A,W
2ADA:  BNZ   2AE0
2ADC:  CLRF   00
2ADE:  BRA    2AFA
2AE0:  BCF    FD8.0
2AE2:  BTFSC  01.7
2AE4:  BRA    2AF8
2AE6:  RLCF   x97,F
2AE8:  RLCF   x98,F
2AEA:  RLCF   x99,F
2AEC:  RLCF   x9A,F
2AEE:  RLCF   03,F
2AF0:  RLCF   02,F
2AF2:  RLCF   01,F
2AF4:  DECFSZ 00,F
2AF6:  BRA    2AE0
2AF8:  BCF    01.7
2AFA:  MOVLB  0
2AFC:  GOTO   2B76 (RETURN)
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,NOPROTECT,NOLVP,MCLR,HSPLL,PLL4 
.................... #device PASS_STRINGS=IN_RAM,adc=10 
.................... #use delay(clock=16000000) 
*
0954:  MOVLW  07
0956:  MOVWF  FEA
0958:  MOVLW  24
095A:  MOVWF  FE9
095C:  MOVF   FEF,W
095E:  BZ    097C
0960:  MOVLW  05
0962:  MOVWF  01
0964:  CLRF   00
0966:  DECFSZ 00,F
0968:  BRA    0966
096A:  DECFSZ 01,F
096C:  BRA    0964
096E:  MOVLW  2E
0970:  MOVWF  00
0972:  DECFSZ 00,F
0974:  BRA    0972
0976:  BRA    0978
0978:  DECFSZ FEF,F
097A:  BRA    0960
097C:  RETURN 0
.................... #use rs232(uart1,baud=115200, xmit=PIN_C6, rcv=PIN_C7, stream = SIM800L_SERIAL, ERRORS) 
*
05C6:  BTFSS  F9E.5
05C8:  BRA    05C6
05CA:  MOVFF  FAB,16
05CE:  MOVFF  FAE,01
05D2:  BTFSS  16.1
05D4:  BRA    05DA
05D6:  BCF    FAB.4
05D8:  BSF    FAB.4
05DA:  RETURN 0
*
0AA4:  BTFSS  F9E.4
0AA6:  BRA    0AA4
0AA8:  MOVWF  FAD
0AAA:  GOTO   0B24 (RETURN)
.................... #use rs232(baud=9600, xmit=PIN_B2, rcv=PIN_B3, stream = MONITOR_SERIAL) 
*
14BE:  BCF    F93.2
14C0:  BCF    F8A.2
14C2:  MOVLW  08
14C4:  MOVWF  01
14C6:  BRA    14C8
14C8:  NOP   
14CA:  BSF    01.7
14CC:  BRA    14EE
14CE:  BCF    01.7
14D0:  MOVLB  6
14D2:  RRCF   x9E,F
14D4:  MOVLB  0
14D6:  BTFSC  FD8.0
14D8:  BSF    F8A.2
14DA:  BTFSS  FD8.0
14DC:  BCF    F8A.2
14DE:  BSF    01.6
14E0:  BRA    14EE
14E2:  BCF    01.6
14E4:  DECFSZ 01,F
14E6:  BRA    14D0
14E8:  BRA    14EA
14EA:  NOP   
14EC:  BSF    F8A.2
14EE:  MOVLW  84
14F0:  MOVWF  FE9
14F2:  DECFSZ FE9,F
14F4:  BRA    14F2
14F6:  BRA    14F8
14F8:  NOP   
14FA:  BTFSC  01.7
14FC:  BRA    14CE
14FE:  BTFSC  01.6
1500:  BRA    14E2
1502:  GOTO   1518 (RETURN)
.................... #use fast_io (ALL) 
.................... #priority ext,rda, rtcc, 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0A16:  MOVFF  727,03
0A1A:  MOVLB  7
0A1C:  MOVFF  726,FE9
0A20:  MOVFF  727,FEA
0A24:  MOVF   FEF,F
0A26:  BZ    0A9A
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0A28:  MOVFF  727,72B
0A2C:  MOVFF  726,72A
0A30:  MOVFF  729,72D
0A34:  MOVFF  728,72C
0A38:  MOVFF  72D,03
0A3C:  MOVFF  72C,FE9
0A40:  MOVFF  72D,FEA
0A44:  MOVF   FEF,F
0A46:  BZ    0A74
0A48:  MOVFF  72A,FE9
0A4C:  MOVFF  72B,FEA
0A50:  MOVFF  FEF,72E
0A54:  MOVFF  72D,03
0A58:  MOVFF  72C,FE9
0A5C:  MOVFF  72D,FEA
0A60:  MOVF   FEF,W
0A62:  SUBWF  x2E,W
0A64:  BNZ   0A74
0A66:  INCF   x2A,F
0A68:  BTFSC  FD8.2
0A6A:  INCF   x2B,F
0A6C:  INCF   x2C,F
0A6E:  BTFSC  FD8.2
0A70:  INCF   x2D,F
0A72:  BRA    0A38
....................  
....................       if (*t == '\0') 
0A74:  MOVFF  72D,03
0A78:  MOVFF  72C,FE9
0A7C:  MOVFF  03,FEA
0A80:  MOVF   FEF,F
0A82:  BNZ   0A8E
....................          return s1; 
0A84:  MOVFF  726,01
0A88:  MOVFF  727,02
0A8C:  BRA    0AA0
....................       ++s1; 
0A8E:  INCF   x26,F
0A90:  BTFSC  FD8.2
0A92:  INCF   x27,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0A94:  MOVLB  0
0A96:  BRA    0A16
0A98:  MOVLB  7
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
0A9A:  MOVLW  00
0A9C:  MOVWF  01
0A9E:  MOVWF  02
0AA0:  MOVLB  0
0AA2:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam); 
.................... void Calcula_SOC(); 
.................... void Obtem_SOH(); 
....................  
.................... #ENDIF 
....................  
.................... #include "SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
.................... #include"Serial.h" 
.................... #IFNDEF SERIAL_H 
.................... #DEFINE SERIAL_H 
....................  
.................... #define  SMS_COMMAND             1 
.................... #define  SMS_READ_COMMAND        2            
....................  
.................... void Executa_Comando(char comando); 
.................... char Get_Comando(); 
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao); 
.................... void get_numero(int nro_caracteres, int posicao, char *destino); 
.................... void clear_command(); 
....................  
.................... #include"Serial.c" 
.................... #include"SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
....................  
.................... #ENDIF 
....................  
.................... #include"TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam); 
.................... void Calcula_SOC(); 
.................... void Obtem_SOH(); 
....................  
.................... #ENDIF 
....................  
.................... #include"numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
.................... void obtem_numero(int8 pos_num, char *numero); 
....................  
.................... #include"numeros.c" 
.................... char numeros[50]; 
.................... extern int8 qtd_numeros; 
.................... char *posicao_numero; 
....................  
.................... int1 insere_numero(char *numero){ // >+5531995822739>+5531995822739>+5531995822739 
*
1A82:  MOVF   4F,W
1A84:  MULLW  0F
1A86:  MOVFF  FF3,6B3
1A8A:  MOVLB  6
1A8C:  CLRF   xB4
....................   
....................   int8 index = qtd_numeros*15; 
....................   int8 index_2 = 0; 
....................  
....................   if(qtd_numeros == 3){ 
1A8E:  MOVF   4F,W
1A90:  SUBLW  03
1A92:  BNZ   1A9A
....................  
....................     return 0; 
1A94:  MOVLW  00
1A96:  MOVWF  01
1A98:  BRA    1B3E
....................  
....................   } 
....................  
....................   posicao_numero = strstr(numeros,numero); 
1A9A:  MOVLB  7
1A9C:  CLRF   x27
1A9E:  MOVLW  1D
1AA0:  MOVWF  x26
1AA2:  MOVFF  6B2,729
1AA6:  MOVFF  6B1,728
1AAA:  MOVLB  0
1AAC:  CALL   0A16
1AB0:  MOVFF  02,51
1AB4:  MOVFF  01,50
....................    
....................   if(posicao_numero == 0){ 
1AB8:  MOVF   50,F
1ABA:  BNZ   1B38
1ABC:  MOVF   51,F
1ABE:  BNZ   1B38
....................  
....................     numeros[index] ='>'; 
1AC0:  CLRF   03
1AC2:  MOVLB  6
1AC4:  MOVF   xB3,W
1AC6:  ADDLW  1D
1AC8:  MOVWF  FE9
1ACA:  MOVLW  00
1ACC:  ADDWFC 03,W
1ACE:  MOVWF  FEA
1AD0:  MOVLW  3E
1AD2:  MOVWF  FEF
....................      
....................     for(index = index+1;numero[index_2]!='\0';index++){ 
1AD4:  MOVLW  01
1AD6:  ADDWF  xB3,F
1AD8:  CLRF   03
1ADA:  MOVF   xB4,W
1ADC:  ADDWF  xB1,W
1ADE:  MOVWF  FE9
1AE0:  MOVF   xB2,W
1AE2:  ADDWFC 03,W
1AE4:  MOVWF  FEA
1AE6:  MOVF   FEF,F
1AE8:  BZ    1B1E
....................       
....................       numeros[index] = numero[index_2]; 
1AEA:  CLRF   03
1AEC:  MOVF   xB3,W
1AEE:  ADDLW  1D
1AF0:  MOVWF  01
1AF2:  MOVLW  00
1AF4:  ADDWFC 03,F
1AF6:  MOVFF  03,6B6
1AFA:  CLRF   03
1AFC:  MOVF   xB4,W
1AFE:  ADDWF  xB1,W
1B00:  MOVWF  FE9
1B02:  MOVF   xB2,W
1B04:  ADDWFC 03,W
1B06:  MOVWF  FEA
1B08:  MOVFF  FEF,6B7
1B0C:  MOVFF  6B6,FEA
1B10:  MOVFF  01,FE9
1B14:  MOVFF  6B7,FEF
....................       index_2++; 
1B18:  INCF   xB4,F
1B1A:  INCF   xB3,F
1B1C:  BRA    1AD8
....................         
....................     } 
....................     numeros[index]='\0'; 
1B1E:  CLRF   03
1B20:  MOVF   xB3,W
1B22:  ADDLW  1D
1B24:  MOVWF  FE9
1B26:  MOVLW  00
1B28:  ADDWFC 03,W
1B2A:  MOVWF  FEA
1B2C:  CLRF   FEF
....................     qtd_numeros++; 
1B2E:  INCF   4F,F
....................     return 1; 
1B30:  MOVLW  01
1B32:  MOVWF  01
1B34:  BRA    1B3E
1B36:  MOVLB  0
....................    
....................   } 
....................   return 0; 
1B38:  MOVLW  00
1B3A:  MOVWF  01
1B3C:  MOVLB  6
1B3E:  MOVLB  0
1B40:  GOTO   23FA (RETURN)
.................... } 
....................  
.................... void obtem_numero(int8 pos_num, char *numero){ 
*
2B00:  MOVLB  6
2B02:  CLRF   x9A
2B04:  CLRF   x9B
....................  
....................   int8 index = 0; 
....................   int8 index_2 = 0; 
....................  
....................   if(pos_num>qtd_numeros) return; 
2B06:  MOVF   x97,W
2B08:  SUBWF  4F,W
2B0A:  BTFSS  FD8.0
2B0C:  BRA    2B58
....................  
....................   for(index = ((pos_num*15)+1); index<(pos_num+1)*15;index++){ 
2B0E:  MOVF   x97,W
2B10:  MULLW  0F
2B12:  MOVF   FF3,W
2B14:  ADDLW  01
2B16:  MOVWF  x9A
2B18:  MOVLW  01
2B1A:  ADDWF  x97,W
2B1C:  MULLW  0F
2B1E:  MOVF   FF3,W
2B20:  SUBWF  x9A,W
2B22:  BC    2B58
....................  
....................     numero[index_2] = numeros[index]; 
2B24:  CLRF   03
2B26:  MOVF   x9B,W
2B28:  ADDWF  x98,W
2B2A:  MOVWF  01
2B2C:  MOVF   x99,W
2B2E:  ADDWFC 03,F
2B30:  MOVFF  03,69D
2B34:  CLRF   03
2B36:  MOVF   x9A,W
2B38:  ADDLW  1D
2B3A:  MOVWF  FE9
2B3C:  MOVLW  00
2B3E:  ADDWFC 03,W
2B40:  MOVWF  FEA
2B42:  MOVFF  FEF,69E
2B46:  MOVFF  69D,FEA
2B4A:  MOVFF  01,FE9
2B4E:  MOVFF  69E,FEF
....................     index_2++; 
2B52:  INCF   x9B,F
2B54:  INCF   x9A,F
2B56:  BRA    2B18
....................   }   
....................    
....................   return; 
2B58:  MOVLB  0
2B5A:  GOTO   2C44 (RETURN)
....................  
.................... } 
....................  
.................... void limpa_numeros(){ 
....................  
....................   qtd_numeros = 0; 
*
1B5E:  CLRF   4F
....................   memset (numeros, 0x00, sizeof(numeros)); 
1B60:  CLRF   FEA
1B62:  MOVLW  1D
1B64:  MOVWF  FE9
1B66:  CLRF   00
1B68:  CLRF   02
1B6A:  MOVLW  32
1B6C:  MOVWF  01
1B6E:  RCALL  1B44
1B70:  GOTO   2482 (RETURN)
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define   UART_BUFFER_SIZE         150 
....................  
.................... char comando_recibido_UART[UART_BUFFER_SIZE]; 
.................... char comando_recibido_BUFF [UART_BUFFER_SIZE]; 
.................... int *posicao_valor_comando = 0; 
.................... int16 timeout_trama_UART = 100000; 
.................... extern int1 comando_disponivel_UART; 
.................... extern int32 corrente_limite; 
.................... extern int32 tempo_entre_alertas; 
.................... extern float aux_corrente; 
.................... extern float aux_tensao; 
.................... extern float zero_set; 
.................... extern float zero_set_aux; 
....................  
.................... #INT_RDA  
.................... void recepcao_UART() 
*
05DC:  MOVLW  01
05DE:  MOVLB  7
05E0:  MOVWF  x2F
.................... { 
....................  int i = 1; 
....................  int8 caracterRx; 
....................    if(kbhit(SIM800L_SERIAL) && comando_disponivel_UART == 0) { 
05E2:  BTFSS  F9E.5
05E4:  BRA    068C
05E6:  MOVLB  1
05E8:  BTFSS  x82.0
05EA:  BRA    05F0
05EC:  MOVLB  7
05EE:  BRA    068C
....................       caracterRx = getc(SIM800L_SERIAL); 
05F0:  MOVLB  0
05F2:  RCALL  05C6
05F4:  MOVFF  01,730
....................       if(caracterRx == '>'||caracterRx == '+' ||caracterRx =='\n'||caracterRx =='\r') { 
05F8:  MOVLB  7
05FA:  MOVF   x30,W
05FC:  SUBLW  3E
05FE:  BZ    0612
0600:  MOVF   x30,W
0602:  SUBLW  2B
0604:  BZ    0612
0606:  MOVF   x30,W
0608:  SUBLW  0A
060A:  BZ    0612
060C:  MOVF   x30,W
060E:  SUBLW  0D
0610:  BNZ   068C
....................         comando_recibido_UART[0] = caracterRx; 
0612:  MOVFF  730,52
....................         while(i < (UART_BUFFER_SIZE-2) && timeout_trama_UART > 0) { 
0616:  MOVF   x2F,W
0618:  SUBLW  93
061A:  BNC   066E
061C:  MOVLB  1
061E:  MOVF   x80,F
0620:  BNZ   062C
0622:  MOVF   x81,F
0624:  BTFSS  FD8.2
0626:  BRA    062C
0628:  MOVLB  7
062A:  BRA    066E
....................            if(kbhit(SIM800L_SERIAL)) { 
062C:  BTFSS  F9E.5
062E:  BRA    0662
....................              caracterRx = getc(SIM800L_SERIAL); 
0630:  MOVLB  0
0632:  RCALL  05C6
0634:  MOVFF  01,730
....................              comando_recibido_UART[i] = caracterRx; 
0638:  CLRF   03
063A:  MOVLB  7
063C:  MOVF   x2F,W
063E:  ADDLW  52
0640:  MOVWF  FE9
0642:  MOVLW  00
0644:  ADDWFC 03,W
0646:  MOVWF  FEA
0648:  MOVFF  730,FEF
....................              if(caracterRx == ';') {  
064C:  MOVF   x30,W
064E:  SUBLW  3B
0650:  BNZ   0656
....................                i++; 
0652:  INCF   x2F,F
....................                break; 
0654:  BRA    066E
....................              } 
....................              i++; 
0656:  INCF   x2F,F
....................              timeout_trama_UART = 100000; 
0658:  MOVLW  86
065A:  MOVLB  1
065C:  MOVWF  x81
065E:  MOVLW  A0
0660:  MOVWF  x80
....................            } 
....................            timeout_trama_UART--; 
0662:  MOVF   x80,W
0664:  BTFSC  FD8.2
0666:  DECF   x81,F
0668:  DECF   x80,F
066A:  MOVLB  7
066C:  BRA    0616
....................         } 
....................         comando_disponivel_UART = 1; 
066E:  MOVLB  1
0670:  BSF    x82.0
....................         timeout_trama_UART = 100000; 
0672:  MOVLW  86
0674:  MOVWF  x81
0676:  MOVLW  A0
0678:  MOVWF  x80
....................         comando_recibido_UART[i] = 0; 
067A:  CLRF   03
067C:  MOVLB  7
067E:  MOVF   x2F,W
0680:  ADDLW  52
0682:  MOVWF  FE9
0684:  MOVLW  00
0686:  ADDWFC 03,W
0688:  MOVWF  FEA
068A:  CLRF   FEF
....................       } 
....................    } 
....................   return; 
068C:  BCF    F9E.5
068E:  MOVLB  0
0690:  GOTO   006C
.................... } 
....................  
.................... char Get_Comando() 
.................... { 
....................   char CMD[15]; 
....................   strcpy (comando_recibido_BUFF, comando_recibido_UART);                            
*
18B4:  CLRF   FEA
18B6:  MOVLW  E8
18B8:  MOVWF  FE9
18BA:  CLRF   FE2
18BC:  MOVLW  52
18BE:  MOVWF  FE1
18C0:  MOVF   FE7,F
18C2:  MOVFF  FE6,FEE
18C6:  BNZ   18C0
....................   strcpy (CMD, "+CMTI"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_COMMAND); 
18C8:  MOVLW  06
18CA:  MOVWF  FEA
18CC:  MOVLW  69
18CE:  MOVWF  FE9
18D0:  MOVFF  FF2,678
18D4:  BCF    FF2.7
18D6:  MOVLW  00
18D8:  CALL   00AE
18DC:  TBLRD*-
18DE:  TBLRD*+
18E0:  MOVF   FF5,W
18E2:  MOVWF  FEE
18E4:  IORLW  00
18E6:  BNZ   18DE
18E8:  MOVLB  6
18EA:  BTFSC  x78.7
18EC:  BSF    FF2.7
18EE:  MOVLB  7
18F0:  CLRF   x27
18F2:  MOVLW  E8
18F4:  MOVWF  x26
18F6:  MOVLW  06
18F8:  MOVWF  x29
18FA:  MOVLW  69
18FC:  MOVWF  x28
18FE:  MOVLB  0
1900:  CALL   0A16
1904:  MOVFF  02,17F
1908:  MOVFF  01,17E
190C:  MOVLB  1
190E:  MOVF   x7E,F
1910:  BNZ   1916
1912:  MOVF   x7F,F
1914:  BZ    191C
1916:  MOVLW  01
1918:  MOVWF  01
191A:  BRA    1976
....................   strcpy (CMD, "+CMGL"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_READ_COMMAND); 
191C:  MOVLW  06
191E:  MOVWF  FEA
1920:  MOVLW  69
1922:  MOVWF  FE9
1924:  MOVFF  FF2,678
1928:  BCF    FF2.7
192A:  MOVLW  00
192C:  MOVLB  0
192E:  CALL   00CE
1932:  TBLRD*-
1934:  TBLRD*+
1936:  MOVF   FF5,W
1938:  MOVWF  FEE
193A:  IORLW  00
193C:  BNZ   1934
193E:  MOVLB  6
1940:  BTFSC  x78.7
1942:  BSF    FF2.7
1944:  MOVLB  7
1946:  CLRF   x27
1948:  MOVLW  E8
194A:  MOVWF  x26
194C:  MOVLW  06
194E:  MOVWF  x29
1950:  MOVLW  69
1952:  MOVWF  x28
1954:  MOVLB  0
1956:  CALL   0A16
195A:  MOVFF  02,17F
195E:  MOVFF  01,17E
1962:  MOVLB  1
1964:  MOVF   x7E,F
1966:  BNZ   196C
1968:  MOVF   x7F,F
196A:  BZ    1972
196C:  MOVLW  02
196E:  MOVWF  01
1970:  BRA    1976
....................  
....................   return(0); 
1972:  MOVLW  00
1974:  MOVWF  01
1976:  MOVLB  0
1978:  RETURN 0
.................... } 
....................  
....................  
.................... void Executa_Comando(char comando){ 
....................  
....................   char CMD[15]; 
....................   char numero[20]; 
....................  
....................   disable_interrupts(GLOBAL); 
*
22B8:  BCF    FF2.6
22BA:  BCF    FF2.7
22BC:  BTFSC  FF2.7
22BE:  BRA    22BA
....................    
....................   switch(comando){ 
22C0:  MOVLB  6
22C2:  MOVF   x69,W
22C4:  XORLW  01
22C6:  MOVLB  0
22C8:  BZ    22D0
22CA:  XORLW  03
22CC:  BZ    22D6
22CE:  BRA    29C0
....................       
....................     case SMS_COMMAND:       //+CMTI: "SM",10<CR><LF> 
....................       Read_SMS(); 
22D0:  GOTO   197A
....................     break; 
22D4:  BRA    29C0
....................  
....................     case SMS_READ_COMMAND:  //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/13,21:57:54-12"<CR><LF> 
....................  
....................       strcpy (CMD, "OITAI");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); 
22D6:  MOVLW  06
22D8:  MOVWF  FEA
22DA:  MOVLW  6A
22DC:  MOVWF  FE9
22DE:  MOVFF  FF2,6B1
22E2:  BCF    FF2.7
22E4:  MOVLW  00
22E6:  CALL   00EE
22EA:  TBLRD*-
22EC:  TBLRD*+
22EE:  MOVF   FF5,W
22F0:  MOVWF  FEE
22F2:  IORLW  00
22F4:  BNZ   22EC
22F6:  MOVLB  6
22F8:  BTFSC  xB1.7
22FA:  BSF    FF2.7
22FC:  MOVLB  7
22FE:  CLRF   x27
2300:  MOVLW  E8
2302:  MOVWF  x26
2304:  MOVLW  06
2306:  MOVWF  x29
2308:  MOVLW  6A
230A:  MOVWF  x28
230C:  MOVLB  0
230E:  CALL   0A16
2312:  MOVFF  02,17F
2316:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
231A:  MOVLB  1
231C:  MOVF   x7E,F
231E:  BNZ   2324
2320:  MOVF   x7F,F
2322:  BZ    2382
....................  
....................         get_numero(14,25,numero); 
2324:  MOVLW  0E
2326:  MOVLB  6
2328:  MOVWF  xB1
232A:  MOVLW  19
232C:  MOVWF  xB2
232E:  MOVLW  06
2330:  MOVWF  xB4
2332:  MOVLW  79
2334:  MOVWF  xB3
2336:  MOVLB  0
2338:  CALL   1A2E
....................         Send_SMS(numero,"HEARTBEAT()"); 
233C:  MOVLW  06
233E:  MOVWF  FEA
2340:  MOVLW  8D
2342:  MOVWF  FE9
2344:  MOVFF  FF2,6B1
2348:  BCF    FF2.7
234A:  MOVLW  0C
234C:  MOVWF  01
234E:  CLRF   FF7
2350:  MOVLW  00
2352:  CALL   010E
2356:  TBLRD*-
2358:  TBLRD*+
235A:  MOVFF  FF5,FEE
235E:  DECFSZ 01,F
2360:  BRA    2358
2362:  MOVLB  6
2364:  BTFSC  xB1.7
2366:  BSF    FF2.7
2368:  MOVLW  06
236A:  MOVWF  xD7
236C:  MOVLW  79
236E:  MOVWF  xD6
2370:  MOVLW  06
2372:  MOVWF  xD9
2374:  MOVLW  8D
2376:  MOVWF  xD8
2378:  MOVLB  0
237A:  CALL   0B9E
....................         break; 
237E:  BRA    29C0
2380:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMADD");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/14,00:28:46-12"nr+NUMADD+5531995422738<CR><LF> 
2382:  MOVLW  06
2384:  MOVWF  FEA
2386:  MOVLW  6A
2388:  MOVWF  FE9
238A:  MOVFF  FF2,6B1
238E:  BCF    FF2.7
2390:  MOVLW  00
2392:  MOVLB  0
2394:  CALL   0134
2398:  TBLRD*-
239A:  TBLRD*+
239C:  MOVF   FF5,W
239E:  MOVWF  FEE
23A0:  IORLW  00
23A2:  BNZ   239A
23A4:  MOVLB  6
23A6:  BTFSC  xB1.7
23A8:  BSF    FF2.7
23AA:  MOVLB  7
23AC:  CLRF   x27
23AE:  MOVLW  E8
23B0:  MOVWF  x26
23B2:  MOVLW  06
23B4:  MOVWF  x29
23B6:  MOVLW  6A
23B8:  MOVWF  x28
23BA:  MOVLB  0
23BC:  CALL   0A16
23C0:  MOVFF  02,17F
23C4:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
23C8:  MOVLB  1
23CA:  MOVF   x7E,F
23CC:  BNZ   23D2
23CE:  MOVF   x7F,F
23D0:  BZ    242C
....................          
....................         get_numero(14,75,numero); 
23D2:  MOVLW  0E
23D4:  MOVLB  6
23D6:  MOVWF  xB1
23D8:  MOVLW  4B
23DA:  MOVWF  xB2
23DC:  MOVLW  06
23DE:  MOVWF  xB4
23E0:  MOVLW  79
23E2:  MOVWF  xB3
23E4:  MOVLB  0
23E6:  CALL   1A2E
....................         insere_numero(numero); 
23EA:  MOVLW  06
23EC:  MOVLB  6
23EE:  MOVWF  xB2
23F0:  MOVLW  79
23F2:  MOVWF  xB1
23F4:  MOVLB  0
23F6:  GOTO   1A82
....................         get_numero(14,25,numero); 
23FA:  MOVLW  0E
23FC:  MOVLB  6
23FE:  MOVWF  xB1
2400:  MOVLW  19
2402:  MOVWF  xB2
2404:  MOVLW  06
2406:  MOVWF  xB4
2408:  MOVLW  79
240A:  MOVWF  xB3
240C:  MOVLB  0
240E:  CALL   1A2E
....................         Send_SMS(numero,numeros); 
2412:  MOVLW  06
2414:  MOVLB  6
2416:  MOVWF  xD7
2418:  MOVLW  79
241A:  MOVWF  xD6
241C:  CLRF   xD9
241E:  MOVLW  1D
2420:  MOVWF  xD8
2422:  MOVLB  0
2424:  CALL   0B9E
....................         break; 
2428:  BRA    29C0
242A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMDEL");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+NUMDEL 
242C:  MOVLW  06
242E:  MOVWF  FEA
2430:  MOVLW  6A
2432:  MOVWF  FE9
2434:  MOVFF  FF2,6B1
2438:  BCF    FF2.7
243A:  MOVLW  00
243C:  MOVLB  0
243E:  CALL   0156
2442:  TBLRD*-
2444:  TBLRD*+
2446:  MOVF   FF5,W
2448:  MOVWF  FEE
244A:  IORLW  00
244C:  BNZ   2444
244E:  MOVLB  6
2450:  BTFSC  xB1.7
2452:  BSF    FF2.7
2454:  MOVLB  7
2456:  CLRF   x27
2458:  MOVLW  E8
245A:  MOVWF  x26
245C:  MOVLW  06
245E:  MOVWF  x29
2460:  MOVLW  6A
2462:  MOVWF  x28
2464:  MOVLB  0
2466:  CALL   0A16
246A:  MOVFF  02,17F
246E:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2472:  MOVLB  1
2474:  MOVF   x7E,F
2476:  BNZ   247C
2478:  MOVF   x7F,F
247A:  BZ    24E0
....................           
....................         limpa_numeros();  
247C:  MOVLB  0
247E:  GOTO   1B5E
....................         get_numero(14,25,numero); 
2482:  MOVLW  0E
2484:  MOVLB  6
2486:  MOVWF  xB1
2488:  MOVLW  19
248A:  MOVWF  xB2
248C:  MOVLW  06
248E:  MOVWF  xB4
2490:  MOVLW  79
2492:  MOVWF  xB3
2494:  MOVLB  0
2496:  CALL   1A2E
....................         Send_SMS(numero,"OK CLEAR ALL"); 
249A:  MOVLW  06
249C:  MOVWF  FEA
249E:  MOVLW  99
24A0:  MOVWF  FE9
24A2:  MOVFF  FF2,6B1
24A6:  BCF    FF2.7
24A8:  MOVLW  0D
24AA:  MOVWF  01
24AC:  CLRF   FF7
24AE:  MOVLW  00
24B0:  CALL   0178
24B4:  TBLRD*-
24B6:  TBLRD*+
24B8:  MOVFF  FF5,FEE
24BC:  DECFSZ 01,F
24BE:  BRA    24B6
24C0:  MOVLB  6
24C2:  BTFSC  xB1.7
24C4:  BSF    FF2.7
24C6:  MOVLW  06
24C8:  MOVWF  xD7
24CA:  MOVLW  79
24CC:  MOVWF  xD6
24CE:  MOVLW  06
24D0:  MOVWF  xD9
24D2:  MOVLW  99
24D4:  MOVWF  xD8
24D6:  MOVLB  0
24D8:  CALL   0B9E
....................         break; 
24DC:  BRA    29C0
24DE:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+GSMLOCATE");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+GSMLOCATE 
24E0:  MOVLW  06
24E2:  MOVWF  FEA
24E4:  MOVLW  6A
24E6:  MOVWF  FE9
24E8:  MOVFF  FF2,6B1
24EC:  BCF    FF2.7
24EE:  MOVLW  00
24F0:  MOVLB  0
24F2:  CALL   01A0
24F6:  TBLRD*-
24F8:  TBLRD*+
24FA:  MOVF   FF5,W
24FC:  MOVWF  FEE
24FE:  IORLW  00
2500:  BNZ   24F8
2502:  MOVLB  6
2504:  BTFSC  xB1.7
2506:  BSF    FF2.7
2508:  MOVLB  7
250A:  CLRF   x27
250C:  MOVLW  E8
250E:  MOVWF  x26
2510:  MOVLW  06
2512:  MOVWF  x29
2514:  MOVLW  6A
2516:  MOVWF  x28
2518:  MOVLB  0
251A:  CALL   0A16
251E:  MOVFF  02,17F
2522:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
2526:  MOVLB  1
2528:  MOVF   x7E,F
252A:  BNZ   2530
252C:  MOVF   x7F,F
252E:  BZ    255C
....................           
....................         get_numero(14,25,numero);  
2530:  MOVLW  0E
2532:  MOVLB  6
2534:  MOVWF  xB1
2536:  MOVLW  19
2538:  MOVWF  xB2
253A:  MOVLW  06
253C:  MOVWF  xB4
253E:  MOVLW  79
2540:  MOVWF  xB3
2542:  MOVLB  0
2544:  CALL   1A2E
....................         Get_Locate(numero);  
2548:  MOVLW  06
254A:  MOVLB  6
254C:  MOVWF  xB2
254E:  MOVLW  79
2550:  MOVWF  xB1
2552:  MOVLB  0
2554:  GOTO   1CD6
....................         break; 
2558:  BRA    29C0
255A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CURLIM");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //rn+CMGL: 1,"REC UNREAD","+5531995822739","","18/11/10,18:12:21-08"rn+CURLIM000001rn 
255C:  MOVLW  06
255E:  MOVWF  FEA
2560:  MOVLW  6A
2562:  MOVWF  FE9
2564:  MOVFF  FF2,6B1
2568:  BCF    FF2.7
256A:  MOVLW  00
256C:  MOVLB  0
256E:  CALL   01C6
2572:  TBLRD*-
2574:  TBLRD*+
2576:  MOVF   FF5,W
2578:  MOVWF  FEE
257A:  IORLW  00
257C:  BNZ   2574
257E:  MOVLB  6
2580:  BTFSC  xB1.7
2582:  BSF    FF2.7
2584:  MOVLB  7
2586:  CLRF   x27
2588:  MOVLW  E8
258A:  MOVWF  x26
258C:  MOVLW  06
258E:  MOVWF  x29
2590:  MOVLW  6A
2592:  MOVWF  x28
2594:  MOVLB  0
2596:  CALL   0A16
259A:  MOVFF  02,17F
259E:  MOVFF  01,17E
....................  
....................       if(posicao_valor_comando!= 0){ 
25A2:  MOVLB  1
25A4:  MOVF   x7E,F
25A6:  BNZ   25AC
25A8:  MOVF   x7F,F
25AA:  BZ    265C
....................           
....................         get_numero(14,25,numero); 
25AC:  MOVLW  0E
25AE:  MOVLB  6
25B0:  MOVWF  xB1
25B2:  MOVLW  19
25B4:  MOVWF  xB2
25B6:  MOVLW  06
25B8:  MOVWF  xB4
25BA:  MOVLW  79
25BC:  MOVWF  xB3
25BE:  MOVLB  0
25C0:  CALL   1A2E
....................         corrente_limite = get_value(posicao_valor_comando,6,7); //+CURALM001<CR><LF> 
25C4:  MOVFF  17F,6B2
25C8:  MOVFF  17E,6B1
25CC:  MOVLW  06
25CE:  MOVLB  6
25D0:  MOVWF  xB3
25D2:  MOVLW  07
25D4:  MOVWF  xB4
25D6:  MOVLB  0
25D8:  RCALL  2102
25DA:  MOVFF  03,186
25DE:  MOVFF  02,185
25E2:  MOVFF  01,184
25E6:  MOVFF  00,183
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
25EA:  CLRF   FEA
25EC:  MOVLW  E8
25EE:  MOVWF  FE9
25F0:  CLRF   00
25F2:  CLRF   02
25F4:  MOVLW  96
25F6:  MOVWF  01
25F8:  CALL   1B44
....................         sprintf(comando_recibido_BUFF, "Corrente Limite = %Lu mA",corrente_limite); 
25FC:  MOVLB  1
25FE:  CLRF   x9C
2600:  MOVLW  E8
2602:  MOVWF  x9B
2604:  MOVLW  94
2606:  MOVWF  FF6
2608:  MOVLW  06
260A:  MOVWF  FF7
260C:  MOVLW  12
260E:  MOVLB  7
2610:  MOVWF  x15
2612:  MOVLB  0
2614:  CALL   09A0
2618:  MOVLW  41
261A:  MOVWF  FE9
261C:  MOVFF  186,6B4
2620:  MOVFF  185,6B3
2624:  MOVFF  184,6B2
2628:  MOVFF  183,6B1
262C:  RCALL  21F4
262E:  MOVLW  A9
2630:  MOVWF  FF6
2632:  MOVLW  06
2634:  MOVWF  FF7
2636:  MOVLW  03
2638:  MOVLB  7
263A:  MOVWF  x15
263C:  MOVLB  0
263E:  CALL   09A0
....................         Send_SMS(numero,comando_recibido_BUFF); 
2642:  MOVLW  06
2644:  MOVLB  6
2646:  MOVWF  xD7
2648:  MOVLW  79
264A:  MOVWF  xD6
264C:  CLRF   xD9
264E:  MOVLW  E8
2650:  MOVWF  xD8
2652:  MOVLB  0
2654:  CALL   0B9E
....................         break; 
2658:  BRA    29C0
265A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CURALM");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //rn+CMGL: 1,"REC UNREAD","+5531995822739","","18/11/10,18:09:52-08"rn+CURALM001rn 
265C:  MOVLW  06
265E:  MOVWF  FEA
2660:  MOVLW  6A
2662:  MOVWF  FE9
2664:  MOVFF  FF2,6B1
2668:  BCF    FF2.7
266A:  MOVLW  00
266C:  MOVLB  0
266E:  CALL   01E8
2672:  TBLRD*-
2674:  TBLRD*+
2676:  MOVF   FF5,W
2678:  MOVWF  FEE
267A:  IORLW  00
267C:  BNZ   2674
267E:  MOVLB  6
2680:  BTFSC  xB1.7
2682:  BSF    FF2.7
2684:  MOVLB  7
2686:  CLRF   x27
2688:  MOVLW  E8
268A:  MOVWF  x26
268C:  MOVLW  06
268E:  MOVWF  x29
2690:  MOVLW  6A
2692:  MOVWF  x28
2694:  MOVLB  0
2696:  CALL   0A16
269A:  MOVFF  02,17F
269E:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
26A2:  MOVLB  1
26A4:  MOVF   x7E,F
26A6:  BNZ   26AC
26A8:  MOVF   x7F,F
26AA:  BZ    275C
....................           
....................         get_numero(14,25,numero); 
26AC:  MOVLW  0E
26AE:  MOVLB  6
26B0:  MOVWF  xB1
26B2:  MOVLW  19
26B4:  MOVWF  xB2
26B6:  MOVLW  06
26B8:  MOVWF  xB4
26BA:  MOVLW  79
26BC:  MOVWF  xB3
26BE:  MOVLB  0
26C0:  CALL   1A2E
....................         tempo_entre_alertas = get_value(posicao_valor_comando,3,7); //+CURLIM000001<CR><LF> 
26C4:  MOVFF  17F,6B2
26C8:  MOVFF  17E,6B1
26CC:  MOVLW  03
26CE:  MOVLB  6
26D0:  MOVWF  xB3
26D2:  MOVLW  07
26D4:  MOVWF  xB4
26D6:  MOVLB  0
26D8:  RCALL  2102
26DA:  MOVFF  03,18A
26DE:  MOVFF  02,189
26E2:  MOVFF  01,188
26E6:  MOVFF  00,187
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
26EA:  CLRF   FEA
26EC:  MOVLW  E8
26EE:  MOVWF  FE9
26F0:  CLRF   00
26F2:  CLRF   02
26F4:  MOVLW  96
26F6:  MOVWF  01
26F8:  CALL   1B44
....................         sprintf(comando_recibido_BUFF, "Tempo Entre Alertas = %Lu min",tempo_entre_alertas); 
26FC:  MOVLB  1
26FE:  CLRF   x9C
2700:  MOVLW  E8
2702:  MOVWF  x9B
2704:  MOVLW  AE
2706:  MOVWF  FF6
2708:  MOVLW  06
270A:  MOVWF  FF7
270C:  MOVLW  16
270E:  MOVLB  7
2710:  MOVWF  x15
2712:  MOVLB  0
2714:  CALL   09A0
2718:  MOVLW  41
271A:  MOVWF  FE9
271C:  MOVFF  18A,6B4
2720:  MOVFF  189,6B3
2724:  MOVFF  188,6B2
2728:  MOVFF  187,6B1
272C:  RCALL  21F4
272E:  MOVLW  C7
2730:  MOVWF  FF6
2732:  MOVLW  06
2734:  MOVWF  FF7
2736:  MOVLW  04
2738:  MOVLB  7
273A:  MOVWF  x15
273C:  MOVLB  0
273E:  CALL   09A0
....................         Send_SMS(numero,comando_recibido_BUFF); 
2742:  MOVLW  06
2744:  MOVLB  6
2746:  MOVWF  xD7
2748:  MOVLW  79
274A:  MOVWF  xD6
274C:  CLRF   xD9
274E:  MOVLW  E8
2750:  MOVWF  xD8
2752:  MOVLB  0
2754:  CALL   0B9E
....................         break; 
2758:  BRA    29C0
275A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+CSTATS");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CSTATS 
275C:  MOVLW  06
275E:  MOVWF  FEA
2760:  MOVLW  6A
2762:  MOVWF  FE9
2764:  MOVFF  FF2,6B1
2768:  BCF    FF2.7
276A:  MOVLW  00
276C:  MOVLB  0
276E:  CALL   020A
2772:  TBLRD*-
2774:  TBLRD*+
2776:  MOVF   FF5,W
2778:  MOVWF  FEE
277A:  IORLW  00
277C:  BNZ   2774
277E:  MOVLB  6
2780:  BTFSC  xB1.7
2782:  BSF    FF2.7
2784:  MOVLB  7
2786:  CLRF   x27
2788:  MOVLW  E8
278A:  MOVWF  x26
278C:  MOVLW  06
278E:  MOVWF  x29
2790:  MOVLW  6A
2792:  MOVWF  x28
2794:  MOVLB  0
2796:  CALL   0A16
279A:  MOVFF  02,17F
279E:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
27A2:  MOVLB  1
27A4:  MOVF   x7E,F
27A6:  BNZ   27AE
27A8:  MOVF   x7F,F
27AA:  BTFSC  FD8.2
27AC:  BRA    28E6
....................           
....................         get_numero(14,25,numero); 
27AE:  MOVLW  0E
27B0:  MOVLB  6
27B2:  MOVWF  xB1
27B4:  MOVLW  19
27B6:  MOVWF  xB2
27B8:  MOVLW  06
27BA:  MOVWF  xB4
27BC:  MOVLW  79
27BE:  MOVWF  xB3
27C0:  MOVLB  0
27C2:  CALL   1A2E
....................         memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
27C6:  CLRF   FEA
27C8:  MOVLW  E8
27CA:  MOVWF  FE9
27CC:  CLRF   00
27CE:  CLRF   02
27D0:  MOVLW  96
27D2:  MOVWF  01
27D4:  CALL   1B44
....................         sprintf(comando_recibido_BUFF, "Tempo Entre Alertas = %Lu min / Corrente Limite = %Lu mA / Corrente Atual: %6.0f mA / Tensao Atual: %2.2f V",tempo_entre_alertas,corrente_limite,aux_corrente,aux_tensao); 
27D8:  MOVLB  1
27DA:  CLRF   x9C
27DC:  MOVLW  E8
27DE:  MOVWF  x9B
27E0:  MOVLW  CC
27E2:  MOVWF  FF6
27E4:  MOVLW  06
27E6:  MOVWF  FF7
27E8:  MOVLW  16
27EA:  MOVLB  7
27EC:  MOVWF  x15
27EE:  MOVLB  0
27F0:  CALL   09A0
27F4:  MOVLW  41
27F6:  MOVWF  FE9
27F8:  MOVFF  18A,6B4
27FC:  MOVFF  189,6B3
2800:  MOVFF  188,6B2
2804:  MOVFF  187,6B1
2808:  RCALL  21F4
280A:  MOVLW  E5
280C:  MOVWF  FF6
280E:  MOVLW  06
2810:  MOVWF  FF7
2812:  MOVLW  19
2814:  MOVLB  7
2816:  MOVWF  x15
2818:  MOVLB  0
281A:  CALL   09A0
281E:  MOVLW  41
2820:  MOVWF  FE9
2822:  MOVFF  186,6B4
2826:  MOVFF  185,6B3
282A:  MOVFF  184,6B2
282E:  MOVFF  183,6B1
2832:  RCALL  21F4
2834:  MOVLW  01
2836:  MOVWF  FF6
2838:  MOVLW  07
283A:  MOVWF  FF7
283C:  MOVLW  16
283E:  MOVLB  7
2840:  MOVWF  x15
2842:  MOVLB  0
2844:  CALL   09A0
2848:  MOVLW  05
284A:  MOVWF  FE9
284C:  MOVFF  18E,6B4
2850:  MOVFF  18D,6B3
2854:  MOVFF  18C,6B2
2858:  MOVFF  18B,6B1
285C:  MOVLB  6
285E:  CLRF   xB5
2860:  MOVLB  0
2862:  CALL   130A
2866:  MOVLW  1C
2868:  MOVWF  FF6
286A:  MOVLW  07
286C:  MOVWF  FF7
286E:  MOVLW  14
2870:  MOVLB  7
2872:  MOVWF  x15
2874:  MOVLB  0
2876:  CALL   09A0
287A:  MOVLW  89
287C:  MOVWF  FE9
287E:  MOVFF  192,6B4
2882:  MOVFF  191,6B3
2886:  MOVFF  190,6B2
288A:  MOVFF  18F,6B1
288E:  MOVLW  02
2890:  MOVLB  6
2892:  MOVWF  xB5
2894:  MOVLB  0
2896:  CALL   130A
289A:  MOVLW  20
289C:  MOVLB  7
289E:  MOVWF  x18
28A0:  MOVLB  0
28A2:  CALL   097E
28A6:  MOVLW  56
28A8:  MOVLB  7
28AA:  MOVWF  x18
28AC:  MOVLB  0
28AE:  CALL   097E
....................         Send_SMS(numero,comando_recibido_BUFF); 
28B2:  MOVLW  06
28B4:  MOVLB  6
28B6:  MOVWF  xD7
28B8:  MOVLW  79
28BA:  MOVWF  xD6
28BC:  CLRF   xD9
28BE:  MOVLW  E8
28C0:  MOVWF  xD8
28C2:  MOVLB  0
28C4:  CALL   0B9E
....................         if(qtd_numeros>0) Send_SMS(numero,numeros); 
28C8:  MOVF   4F,F
28CA:  BZ    28E2
28CC:  MOVLW  06
28CE:  MOVLB  6
28D0:  MOVWF  xD7
28D2:  MOVLW  79
28D4:  MOVWF  xD6
28D6:  CLRF   xD9
28D8:  MOVLW  1D
28DA:  MOVWF  xD8
28DC:  MOVLB  0
28DE:  CALL   0B9E
....................  
....................         break; 
28E2:  BRA    29C0
28E4:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+SETZERO");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+SETZERO 
28E6:  MOVLW  06
28E8:  MOVWF  FEA
28EA:  MOVLW  6A
28EC:  MOVWF  FE9
28EE:  MOVFF  FF2,6B1
28F2:  BCF    FF2.7
28F4:  MOVLW  00
28F6:  MOVLB  0
28F8:  CALL   022C
28FC:  TBLRD*-
28FE:  TBLRD*+
2900:  MOVF   FF5,W
2902:  MOVWF  FEE
2904:  IORLW  00
2906:  BNZ   28FE
2908:  MOVLB  6
290A:  BTFSC  xB1.7
290C:  BSF    FF2.7
290E:  MOVLB  7
2910:  CLRF   x27
2912:  MOVLW  E8
2914:  MOVWF  x26
2916:  MOVLW  06
2918:  MOVWF  x29
291A:  MOVLW  6A
291C:  MOVWF  x28
291E:  MOVLB  0
2920:  CALL   0A16
2924:  MOVFF  02,17F
2928:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
292C:  MOVLB  1
292E:  MOVF   x7E,F
2930:  BNZ   2936
2932:  MOVF   x7F,F
2934:  BZ    29BE
....................           
....................         get_numero(14,25,numero); 
2936:  MOVLW  0E
2938:  MOVLB  6
293A:  MOVWF  xB1
293C:  MOVLW  19
293E:  MOVWF  xB2
2940:  MOVLW  06
2942:  MOVWF  xB4
2944:  MOVLW  79
2946:  MOVWF  xB3
2948:  MOVLB  0
294A:  CALL   1A2E
....................         zero_set = zero_set_aux; 
294E:  MOVFF  19A,196
2952:  MOVFF  199,195
2956:  MOVFF  198,194
295A:  MOVFF  197,193
....................         Send_SMS(numero,"ZERO SETED"); 
295E:  MOVLW  06
2960:  MOVWF  FEA
2962:  MOVLW  A6
2964:  MOVWF  FE9
2966:  MOVFF  FF2,6B1
296A:  BCF    FF2.7
296C:  MOVLW  0B
296E:  MOVWF  01
2970:  CLRF   FF7
2972:  MOVLW  00
2974:  CALL   0250
2978:  TBLRD*-
297A:  TBLRD*+
297C:  MOVFF  FF5,FEE
2980:  DECFSZ 01,F
2982:  BRA    297A
2984:  MOVLB  6
2986:  BTFSC  xB1.7
2988:  BSF    FF2.7
298A:  MOVLW  06
298C:  MOVWF  xD7
298E:  MOVLW  79
2990:  MOVWF  xD6
2992:  MOVLW  06
2994:  MOVWF  xD9
2996:  MOVLW  A6
2998:  MOVWF  xD8
299A:  MOVLB  0
299C:  CALL   0B9E
....................         if(qtd_numeros>0) Send_SMS(numero,numeros); 
29A0:  MOVF   4F,F
29A2:  BZ    29BA
29A4:  MOVLW  06
29A6:  MOVLB  6
29A8:  MOVWF  xD7
29AA:  MOVLW  79
29AC:  MOVWF  xD6
29AE:  CLRF   xD9
29B0:  MOVLW  1D
29B2:  MOVWF  xD8
29B4:  MOVLB  0
29B6:  CALL   0B9E
....................  
....................         break; 
29BA:  BRA    29C0
29BC:  MOVLB  1
....................       } 
....................           
....................     break; 
29BE:  MOVLB  0
....................  
....................  
....................   } 
....................  
....................   return; 
29C0:  RETURN 0
....................  
.................... } 
....................  
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao) //get_value(posicao_valor_comando,3,6); 
*
2102:  MOVLB  6
2104:  CLRF   xB8
2106:  CLRF   xB7
2108:  CLRF   xB6
210A:  CLRF   xB5
210C:  CLRF   xB9
210E:  CLRF   xBD
2110:  CLRF   xBC
2112:  CLRF   xBB
2114:  MOVLW  01
2116:  MOVWF  xBA
2118:  CLRF   xBE
.................... { 
....................   int32 valor = 0; 
....................   int i = 0; 
....................   int32 aux = 1; 
....................   int potencia = 0; 
....................  
....................   while(nro_caracteres > 0) 
211A:  MOVF   xB3,F
211C:  BZ    21E0
....................   { 
....................     if( pointer_to_string[posicao+i] != '.' ) 
211E:  MOVF   xB9,W
2120:  ADDWF  xB4,W
2122:  CLRF   03
2124:  ADDWF  xB1,W
2126:  MOVWF  FE9
2128:  MOVF   xB2,W
212A:  ADDWFC 03,W
212C:  MOVWF  FEA
212E:  MOVF   FEF,W
2130:  SUBLW  2E
2132:  BZ    21DC
....................     { 
....................       nro_caracteres--; 
2134:  DECF   xB3,F
....................       potencia = nro_caracteres; 
2136:  MOVFF  6B3,6BE
....................       aux = 1; 
213A:  CLRF   xBD
213C:  CLRF   xBC
213E:  CLRF   xBB
2140:  MOVLW  01
2142:  MOVWF  xBA
....................       while(potencia > 0) 
2144:  MOVF   xBE,F
2146:  BZ    217C
....................       { 
....................         aux = aux * 10; 
2148:  MOVFF  6BD,6C8
214C:  MOVFF  6BC,6C7
2150:  MOVFF  6BB,6C6
2154:  MOVFF  6BA,6C5
2158:  CLRF   xCC
215A:  CLRF   xCB
215C:  CLRF   xCA
215E:  MOVLW  0A
2160:  MOVWF  xC9
2162:  MOVLB  0
2164:  RCALL  20A6
2166:  MOVFF  03,6BD
216A:  MOVFF  02,6BC
216E:  MOVFF  01,6BB
2172:  MOVFF  00,6BA
....................         potencia--; 
2176:  MOVLB  6
2178:  DECF   xBE,F
217A:  BRA    2144
....................       } 
....................       valor = valor + ((int32)(pointer_to_string[posicao+i]-48)*aux); 
217C:  MOVF   xB9,W
217E:  ADDWF  xB4,W
2180:  CLRF   03
2182:  ADDWF  xB1,W
2184:  MOVWF  FE9
2186:  MOVF   xB2,W
2188:  ADDWFC 03,W
218A:  MOVWF  FEA
218C:  MOVLW  30
218E:  SUBWF  FEF,W
2190:  CLRF   xC2
2192:  CLRF   xC1
2194:  CLRF   xC0
2196:  MOVWF  xBF
2198:  MOVFF  FEA,6C4
219C:  MOVFF  FE9,6C3
21A0:  MOVFF  6C2,6C8
21A4:  MOVFF  6C1,6C7
21A8:  MOVFF  6C0,6C6
21AC:  MOVWF  xC5
21AE:  MOVFF  6BD,6CC
21B2:  MOVFF  6BC,6CB
21B6:  MOVFF  6BB,6CA
21BA:  MOVFF  6BA,6C9
21BE:  MOVLB  0
21C0:  RCALL  20A6
21C2:  MOVFF  6C4,FEA
21C6:  MOVFF  6C3,FE9
21CA:  MOVF   00,W
21CC:  MOVLB  6
21CE:  ADDWF  xB5,F
21D0:  MOVF   01,W
21D2:  ADDWFC xB6,F
21D4:  MOVF   02,W
21D6:  ADDWFC xB7,F
21D8:  MOVF   03,W
21DA:  ADDWFC xB8,F
....................     } 
....................     i++; 
21DC:  INCF   xB9,F
21DE:  BRA    211A
....................   } 
....................  
....................   return(valor); 
21E0:  MOVFF  6B5,00
21E4:  MOVFF  6B6,01
21E8:  MOVFF  6B7,02
21EC:  MOVFF  6B8,03
21F0:  MOVLB  0
21F2:  RETURN 0
.................... } 
....................  
.................... void get_numero(int nro_caracteres, int posicao, char *destino){ 
*
1A2E:  MOVLB  6
1A30:  CLRF   xB5
....................  
....................   int8 index = 0; 
....................  
....................   for(index = 0;index< nro_caracteres;index++){ 
1A32:  CLRF   xB5
1A34:  MOVF   xB1,W
1A36:  SUBWF  xB5,W
1A38:  BC    1A6E
....................  
....................     destino[index] = comando_recibido_BUFF[index+posicao]; 
1A3A:  CLRF   03
1A3C:  MOVF   xB5,W
1A3E:  ADDWF  xB3,W
1A40:  MOVWF  01
1A42:  MOVF   xB4,W
1A44:  ADDWFC 03,F
1A46:  MOVFF  03,6B7
1A4A:  MOVF   xB2,W
1A4C:  ADDWF  xB5,W
1A4E:  CLRF   03
1A50:  ADDLW  E8
1A52:  MOVWF  FE9
1A54:  MOVLW  00
1A56:  ADDWFC 03,W
1A58:  MOVWF  FEA
1A5A:  MOVFF  FEF,6B8
1A5E:  MOVFF  6B7,FEA
1A62:  MOVFF  01,FE9
1A66:  MOVFF  6B8,FEF
1A6A:  INCF   xB5,F
1A6C:  BRA    1A34
....................  
....................   } 
....................  
....................   destino[index] = '\0'; 
1A6E:  CLRF   03
1A70:  MOVF   xB5,W
1A72:  ADDWF  xB3,W
1A74:  MOVWF  FE9
1A76:  MOVF   xB4,W
1A78:  ADDWFC 03,W
1A7A:  MOVWF  FEA
1A7C:  CLRF   FEF
....................  
....................   return; 
1A7E:  MOVLB  0
1A80:  RETURN 0
.................... } 
....................  
.................... void clear_command(){ 
....................  
....................   delay_ms(200); 
*
29C2:  MOVLW  C8
29C4:  MOVLB  7
29C6:  MOVWF  x24
29C8:  MOVLB  0
29CA:  CALL   0954
....................   memset (comando_recibido_UART, 0x00, sizeof(comando_recibido_UART)); 
29CE:  CLRF   FEA
29D0:  MOVLW  52
29D2:  MOVWF  FE9
29D4:  CLRF   00
29D6:  CLRF   02
29D8:  MOVLW  96
29DA:  MOVWF  01
29DC:  CALL   1B44
....................   memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
29E0:  CLRF   FEA
29E2:  MOVLW  E8
29E4:  MOVWF  FE9
29E6:  CLRF   00
29E8:  CLRF   02
29EA:  MOVLW  96
29EC:  MOVWF  01
29EE:  CALL   1B44
....................  
....................   comando_disponivel_UART = FALSE; 
29F2:  MOVLB  1
29F4:  BCF    x82.0
....................   enable_interrupts(GLOBAL); 
29F6:  MOVLW  C0
29F8:  IORWF  FF2,F
....................   enable_interrupts(INT_RTCC); 
29FA:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
29FC:  BSF    F9D.5
....................    
....................   return; 
29FE:  MOVLB  0
2A00:  GOTO   2ABE (RETURN)
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... extern int1 resposta_SIM; 
.................... extern comando_disponivel_UART; 
.................... int32 timeout = 7000000; 
.................... char coordenada[40]; 
....................  
.................... int1 envia_SIM800L(char *send, char *recive){ 
*
0AAE:  MOVLW  02
0AB0:  MOVLB  7
0AB2:  MOVWF  x1D
....................  
....................   int8 tentativas = 2; 
....................  
....................   disable_interrupts(INT_RTCC);  
0AB4:  BCF    FF2.5
....................   enable_interrupts(INT_RDA);                                               
0AB6:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
0AB8:  MOVLW  C0
0ABA:  IORWF  FF2,F
....................    
....................   do{ 
....................     timeout = 7000000;   
0ABC:  MOVLB  1
0ABE:  CLRF   xA0
0AC0:  MOVLW  6A
0AC2:  MOVWF  x9F
0AC4:  MOVLW  CF
0AC6:  MOVWF  x9E
0AC8:  MOVLW  C0
0ACA:  MOVWF  x9D
....................     comando_disponivel_UART = 0; 
0ACC:  BCF    x82.0
....................  
....................     fprintf(SIM800L_SERIAL,send);                                             // Envia comando para o SIM800L  
0ACE:  MOVFF  71A,FEA
0AD2:  MOVFF  719,FE9
0AD6:  MOVLB  0
0AD8:  BRA    09EE
....................     if(strstr(recive,"+CMGS")!=0){ 
0ADA:  MOVLW  2B
0ADC:  MOVLB  7
0ADE:  MOVWF  x1E
0AE0:  MOVLW  43
0AE2:  MOVWF  x1F
0AE4:  MOVLW  4D
0AE6:  MOVWF  x20
0AE8:  MOVLW  47
0AEA:  MOVWF  x21
0AEC:  MOVLW  53
0AEE:  MOVWF  x22
0AF0:  CLRF   x23
0AF2:  MOVFF  71C,727
0AF6:  MOVFF  71B,726
0AFA:  MOVLW  07
0AFC:  MOVWF  x29
0AFE:  MOVLW  1E
0B00:  MOVWF  x28
0B02:  MOVLB  0
0B04:  RCALL  0A16
0B06:  MOVFF  02,727
0B0A:  MOVFF  01,726
0B0E:  MOVLB  7
0B10:  MOVF   x26,F
0B12:  BNZ   0B18
0B14:  MOVF   x27,F
0B16:  BZ    0B26
....................       delay_ms(150); 
0B18:  MOVLW  96
0B1A:  MOVWF  x24
0B1C:  MOVLB  0
0B1E:  RCALL  0954
....................       fputc(0x1A,SIM800L_SERIAL); 
0B20:  MOVLW  1A
0B22:  BRA    0AA4
0B24:  MOVLB  7
....................     }                                                                                         
....................     while(!comando_disponivel_UART && --timeout > 0);                         // Aguarda o SIM800L responder por ~23 segundos caso nao responda retorna 0 
0B26:  MOVLB  1
0B28:  BTFSC  x82.0
0B2A:  BRA    0B4C
0B2C:  MOVLW  FF
0B2E:  ADDWF  x9D,F
0B30:  BTFSS  FD8.0
0B32:  ADDWF  x9E,F
0B34:  BTFSS  FD8.0
0B36:  ADDWF  x9F,F
0B38:  BTFSS  FD8.0
0B3A:  ADDWF  xA0,F
0B3C:  MOVF   x9D,F
0B3E:  BNZ   0B28
0B40:  MOVF   x9E,F
0B42:  BNZ   0B28
0B44:  MOVF   x9F,F
0B46:  BNZ   0B28
0B48:  MOVF   xA0,F
0B4A:  BNZ   0B28
....................                           
....................     if(comando_disponivel_UART){                                              // Caso receba a resposta  
0B4C:  BTFSS  x82.0
0B4E:  BRA    0B86
....................       comando_disponivel_UART = 0;                   
0B50:  BCF    x82.0
....................       posicao_valor_comando = strstr(comando_recibido_UART,recive);           // Procura a palavra recive da funcao na resposta recebida 
0B52:  MOVLB  7
0B54:  CLRF   x27
0B56:  MOVLW  52
0B58:  MOVWF  x26
0B5A:  MOVFF  71C,729
0B5E:  MOVFF  71B,728
0B62:  MOVLB  0
0B64:  RCALL  0A16
0B66:  MOVFF  02,17F
0B6A:  MOVFF  01,17E
....................                  
....................       if(posicao_valor_comando!= 0){                                          // Caso encontre a resposta esperada 
0B6E:  MOVLB  1
0B70:  MOVF   x7E,F
0B72:  BNZ   0B78
0B74:  MOVF   x7F,F
0B76:  BZ    0B86
....................         enable_interrupts(INT_RDA); 
0B78:  BSF    F9D.5
....................         enable_interrupts(INT_RTCC); 
0B7A:  BSF    FF2.5
....................         enable_interrupts(GLOBAL); 
0B7C:  MOVLW  C0
0B7E:  IORWF  FF2,F
....................         return 1; 
0B80:  MOVLW  01
0B82:  MOVWF  01
0B84:  BRA    0B9A
....................       } 
....................     } 
....................   }while(--tentativas>0);                 
0B86:  MOVLB  7
0B88:  DECFSZ x1D,F
0B8A:  BRA    0ABC
....................    
....................   enable_interrupts(GLOBAL); 
0B8C:  MOVLW  C0
0B8E:  IORWF  FF2,F
....................   enable_interrupts(INT_RDA); 
0B90:  BSF    F9D.5
....................   enable_interrupts(INT_RTCC); 
0B92:  BSF    FF2.5
....................  
....................   return 0; 
0B94:  MOVLW  00
0B96:  MOVWF  01
0B98:  MOVLB  1
0B9A:  MOVLB  0
0B9C:  RETURN 0
.................... } 
....................  
.................... int1 Send_SMS(char *numero,char *mensagem){ 
....................    
....................   char numero_envio[35]; 
....................  
....................   sprintf(numero_envio,"AT+CMGS=\"%s\"\r\n",numero); 
0B9E:  MOVLW  06
0BA0:  MOVLB  1
0BA2:  MOVWF  x9C
0BA4:  MOVLW  DA
0BA6:  MOVWF  x9B
0BA8:  MOVLW  38
0BAA:  MOVWF  FF6
0BAC:  MOVLW  07
0BAE:  MOVWF  FF7
0BB0:  MOVLW  09
0BB2:  MOVLB  7
0BB4:  MOVWF  x15
0BB6:  MOVLB  0
0BB8:  RCALL  09A0
0BBA:  MOVFF  6D7,FEA
0BBE:  MOVFF  6D6,FE9
0BC2:  BRA    09C8
0BC4:  MOVLW  43
0BC6:  MOVWF  FF6
0BC8:  MOVLW  07
0BCA:  MOVWF  FF7
0BCC:  MOVLW  03
0BCE:  MOVLB  7
0BD0:  MOVWF  x15
0BD2:  MOVLB  0
0BD4:  RCALL  09A0
....................  
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
0BD6:  MOVLW  06
0BD8:  MOVWF  FEA
0BDA:  MOVLW  FD
0BDC:  MOVWF  FE9
0BDE:  MOVFF  FF2,715
0BE2:  BCF    FF2.7
0BE4:  MOVLW  0C
0BE6:  MOVWF  01
0BE8:  CLRF   FF7
0BEA:  MOVLW  00
0BEC:  CALL   0276
0BF0:  TBLRD*-
0BF2:  TBLRD*+
0BF4:  MOVFF  FF5,FEE
0BF8:  DECFSZ 01,F
0BFA:  BRA    0BF2
0BFC:  MOVLB  7
0BFE:  BTFSC  x15.7
0C00:  BSF    FF2.7
0C02:  MOVLW  4F
0C04:  MOVWF  x09
0C06:  MOVLW  4B
0C08:  MOVWF  x0A
0C0A:  CLRF   x0B
0C0C:  MOVLW  06
0C0E:  MOVWF  x1A
0C10:  MOVLW  FD
0C12:  MOVWF  x19
0C14:  MOVLW  07
0C16:  MOVWF  x1C
0C18:  MOVLW  09
0C1A:  MOVWF  x1B
0C1C:  MOVLB  0
0C1E:  RCALL  0AAE
0C20:  MOVF   01,F
0C22:  BZ    0CDE
....................     if(envia_SIM800L("AT+CSMP=17,255,0,0\r\n","OK")) 
0C24:  MOVLW  06
0C26:  MOVWF  FEA
0C28:  MOVLW  FD
0C2A:  MOVWF  FE9
0C2C:  MOVFF  FF2,715
0C30:  BCF    FF2.7
0C32:  MOVLW  15
0C34:  MOVWF  01
0C36:  CLRF   FF7
0C38:  MOVLW  00
0C3A:  CALL   029C
0C3E:  TBLRD*-
0C40:  TBLRD*+
0C42:  MOVFF  FF5,FEE
0C46:  DECFSZ 01,F
0C48:  BRA    0C40
0C4A:  MOVLB  7
0C4C:  BTFSC  x15.7
0C4E:  BSF    FF2.7
0C50:  MOVLW  4F
0C52:  MOVWF  x12
0C54:  MOVLW  4B
0C56:  MOVWF  x13
0C58:  CLRF   x14
0C5A:  MOVLW  06
0C5C:  MOVWF  x1A
0C5E:  MOVLW  FD
0C60:  MOVWF  x19
0C62:  MOVLW  07
0C64:  MOVWF  x1C
0C66:  MOVLW  12
0C68:  MOVWF  x1B
0C6A:  MOVLB  0
0C6C:  RCALL  0AAE
0C6E:  MOVF   01,F
0C70:  BZ    0CDE
....................       if(envia_SIM800L(numero_envio, ">")) 
0C72:  MOVLW  3E
0C74:  MOVLB  6
0C76:  MOVWF  xFD
0C78:  CLRF   xFE
0C7A:  MOVLW  06
0C7C:  MOVLB  7
0C7E:  MOVWF  x1A
0C80:  MOVLW  DA
0C82:  MOVWF  x19
0C84:  MOVLW  06
0C86:  MOVWF  x1C
0C88:  MOVLW  FD
0C8A:  MOVWF  x1B
0C8C:  MOVLB  0
0C8E:  RCALL  0AAE
0C90:  MOVF   01,F
0C92:  BZ    0CDE
....................         if(envia_SIM800L(mensagem, "+CMGS:")) 
0C94:  MOVLW  06
0C96:  MOVWF  FEA
0C98:  MOVLW  FD
0C9A:  MOVWF  FE9
0C9C:  MOVFF  FF2,715
0CA0:  BCF    FF2.7
0CA2:  MOVLW  07
0CA4:  MOVWF  01
0CA6:  CLRF   FF7
0CA8:  MOVLW  00
0CAA:  CALL   02CC
0CAE:  TBLRD*-
0CB0:  TBLRD*+
0CB2:  MOVFF  FF5,FEE
0CB6:  DECFSZ 01,F
0CB8:  BRA    0CB0
0CBA:  MOVLB  7
0CBC:  BTFSC  x15.7
0CBE:  BSF    FF2.7
0CC0:  MOVFF  6D9,71A
0CC4:  MOVFF  6D8,719
0CC8:  MOVLW  06
0CCA:  MOVWF  x1C
0CCC:  MOVLW  FD
0CCE:  MOVWF  x1B
0CD0:  MOVLB  0
0CD2:  RCALL  0AAE
0CD4:  MOVF   01,F
0CD6:  BZ    0CDE
....................           return 1; 
0CD8:  MOVLW  01
0CDA:  MOVWF  01
0CDC:  BRA    0CE2
....................   return 0; 
0CDE:  MOVLW  00
0CE0:  MOVWF  01
0CE2:  RETURN 0
.................... } 
....................  
.................... int1 Read_SMS(){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")){ 
*
197A:  MOVLW  06
197C:  MOVWF  FEA
197E:  MOVLW  B1
1980:  MOVWF  FE9
1982:  MOVFF  FF2,6C9
1986:  BCF    FF2.7
1988:  MOVLW  0C
198A:  MOVWF  01
198C:  CLRF   FF7
198E:  MOVLW  00
1990:  CALL   0276
1994:  TBLRD*-
1996:  TBLRD*+
1998:  MOVFF  FF5,FEE
199C:  DECFSZ 01,F
199E:  BRA    1996
19A0:  MOVLB  6
19A2:  BTFSC  xC9.7
19A4:  BSF    FF2.7
19A6:  MOVLW  4F
19A8:  MOVWF  xBD
19AA:  MOVLW  4B
19AC:  MOVWF  xBE
19AE:  CLRF   xBF
19B0:  MOVLW  06
19B2:  MOVLB  7
19B4:  MOVWF  x1A
19B6:  MOVLW  B1
19B8:  MOVWF  x19
19BA:  MOVLW  06
19BC:  MOVWF  x1C
19BE:  MOVLW  BD
19C0:  MOVWF  x1B
19C2:  MOVLB  0
19C4:  CALL   0AAE
19C8:  MOVF   01,F
19CA:  BZ    1A22
....................     if(envia_SIM800L("AT+CMGL=\"REC UNREAD\"\r\n", "")){ 
19CC:  MOVLW  06
19CE:  MOVWF  FEA
19D0:  MOVLW  B1
19D2:  MOVWF  FE9
19D4:  MOVFF  FF2,6C9
19D8:  BCF    FF2.7
19DA:  MOVLW  17
19DC:  MOVWF  01
19DE:  CLRF   FF7
19E0:  MOVLW  00
19E2:  CALL   02EE
19E6:  TBLRD*-
19E8:  TBLRD*+
19EA:  MOVFF  FF5,FEE
19EE:  DECFSZ 01,F
19F0:  BRA    19E8
19F2:  MOVLB  6
19F4:  BTFSC  xC9.7
19F6:  BSF    FF2.7
19F8:  CLRF   xC8
19FA:  MOVLW  06
19FC:  MOVLB  7
19FE:  MOVWF  x1A
1A00:  MOVLW  B1
1A02:  MOVWF  x19
1A04:  MOVLW  06
1A06:  MOVWF  x1C
1A08:  MOVLW  C8
1A0A:  MOVWF  x1B
1A0C:  MOVLB  0
1A0E:  CALL   0AAE
1A12:  MOVF   01,F
1A14:  BZ    1A22
....................       resposta_SIM = true; 
1A16:  MOVLB  1
1A18:  BSF    x82.1
....................       return 1;     
1A1A:  MOVLW  01
1A1C:  MOVWF  01
1A1E:  BRA    1A28
1A20:  MOVLB  0
....................     }   
....................   } 
....................   return 0; 
1A22:  MOVLW  00
1A24:  MOVWF  01
1A26:  MOVLB  1
1A28:  MOVLB  0
1A2A:  GOTO   29C0 (RETURN)
.................... } 
....................  
.................... int1 Get_Locate(char *numero){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
*
1CD6:  MOVLW  06
1CD8:  MOVWF  FEA
1CDA:  MOVLW  B3
1CDC:  MOVWF  FE9
1CDE:  MOVFF  FF2,6D6
1CE2:  BCF    FF2.7
1CE4:  MOVLW  0C
1CE6:  MOVWF  01
1CE8:  CLRF   FF7
1CEA:  MOVLW  00
1CEC:  CALL   0276
1CF0:  TBLRD*-
1CF2:  TBLRD*+
1CF4:  MOVFF  FF5,FEE
1CF8:  DECFSZ 01,F
1CFA:  BRA    1CF2
1CFC:  MOVLB  6
1CFE:  BTFSC  xD6.7
1D00:  BSF    FF2.7
1D02:  MOVLW  4F
1D04:  MOVWF  xBF
1D06:  MOVLW  4B
1D08:  MOVWF  xC0
1D0A:  CLRF   xC1
1D0C:  MOVLW  06
1D0E:  MOVLB  7
1D10:  MOVWF  x1A
1D12:  MOVLW  B3
1D14:  MOVWF  x19
1D16:  MOVLW  06
1D18:  MOVWF  x1C
1D1A:  MOVLW  BF
1D1C:  MOVWF  x1B
1D1E:  MOVLB  0
1D20:  CALL   0AAE
1D24:  MOVF   01,F
1D26:  BTFSC  FD8.2
1D28:  BRA    2050
....................     if(envia_SIM800L("AT+CGATT=1\r\n","OK")) 
1D2A:  MOVLW  06
1D2C:  MOVWF  FEA
1D2E:  MOVLW  B3
1D30:  MOVWF  FE9
1D32:  MOVFF  FF2,6D6
1D36:  BCF    FF2.7
1D38:  MOVLW  0D
1D3A:  MOVWF  01
1D3C:  CLRF   FF7
1D3E:  MOVLW  00
1D40:  CALL   0320
1D44:  TBLRD*-
1D46:  TBLRD*+
1D48:  MOVFF  FF5,FEE
1D4C:  DECFSZ 01,F
1D4E:  BRA    1D46
1D50:  MOVLB  6
1D52:  BTFSC  xD6.7
1D54:  BSF    FF2.7
1D56:  MOVLW  4F
1D58:  MOVWF  xC0
1D5A:  MOVLW  4B
1D5C:  MOVWF  xC1
1D5E:  CLRF   xC2
1D60:  MOVLW  06
1D62:  MOVLB  7
1D64:  MOVWF  x1A
1D66:  MOVLW  B3
1D68:  MOVWF  x19
1D6A:  MOVLW  06
1D6C:  MOVWF  x1C
1D6E:  MOVLW  C0
1D70:  MOVWF  x1B
1D72:  MOVLB  0
1D74:  CALL   0AAE
1D78:  MOVF   01,F
1D7A:  BTFSC  FD8.2
1D7C:  BRA    2050
....................       if(envia_SIM800L("AT+SAPBR=3,1,\"CONTYPE\",\"GPRS\"\r\n","OK")) 
1D7E:  MOVLW  06
1D80:  MOVWF  FEA
1D82:  MOVLW  B3
1D84:  MOVWF  FE9
1D86:  MOVFF  FF2,6D6
1D8A:  BCF    FF2.7
1D8C:  MOVLW  20
1D8E:  MOVWF  01
1D90:  CLRF   FF7
1D92:  MOVLW  00
1D94:  CALL   0348
1D98:  TBLRD*-
1D9A:  TBLRD*+
1D9C:  MOVFF  FF5,FEE
1DA0:  DECFSZ 01,F
1DA2:  BRA    1D9A
1DA4:  MOVLB  6
1DA6:  BTFSC  xD6.7
1DA8:  BSF    FF2.7
1DAA:  MOVLW  4F
1DAC:  MOVWF  xD3
1DAE:  MOVLW  4B
1DB0:  MOVWF  xD4
1DB2:  CLRF   xD5
1DB4:  MOVLW  06
1DB6:  MOVLB  7
1DB8:  MOVWF  x1A
1DBA:  MOVLW  B3
1DBC:  MOVWF  x19
1DBE:  MOVLW  06
1DC0:  MOVWF  x1C
1DC2:  MOVLW  D3
1DC4:  MOVWF  x1B
1DC6:  MOVLB  0
1DC8:  CALL   0AAE
1DCC:  MOVF   01,F
1DCE:  BTFSC  FD8.2
1DD0:  BRA    2050
....................         if(envia_SIM800L("AT+SAPBR=3,1,\"APN\",\"CMNET\"\r\n","OK")) 
1DD2:  MOVLW  06
1DD4:  MOVWF  FEA
1DD6:  MOVLW  B3
1DD8:  MOVWF  FE9
1DDA:  MOVFF  FF2,6D6
1DDE:  BCF    FF2.7
1DE0:  MOVLW  1D
1DE2:  MOVWF  01
1DE4:  CLRF   FF7
1DE6:  MOVLW  00
1DE8:  CALL   0382
1DEC:  TBLRD*-
1DEE:  TBLRD*+
1DF0:  MOVFF  FF5,FEE
1DF4:  DECFSZ 01,F
1DF6:  BRA    1DEE
1DF8:  MOVLB  6
1DFA:  BTFSC  xD6.7
1DFC:  BSF    FF2.7
1DFE:  MOVLW  4F
1E00:  MOVWF  xD0
1E02:  MOVLW  4B
1E04:  MOVWF  xD1
1E06:  CLRF   xD2
1E08:  MOVLW  06
1E0A:  MOVLB  7
1E0C:  MOVWF  x1A
1E0E:  MOVLW  B3
1E10:  MOVWF  x19
1E12:  MOVLW  06
1E14:  MOVWF  x1C
1E16:  MOVLW  D0
1E18:  MOVWF  x1B
1E1A:  MOVLB  0
1E1C:  CALL   0AAE
1E20:  MOVF   01,F
1E22:  BTFSC  FD8.2
1E24:  BRA    2050
....................           if(envia_SIM800L("AT+SAPBR=1,1\r\n","OK")) 
1E26:  MOVLW  06
1E28:  MOVWF  FEA
1E2A:  MOVLW  B3
1E2C:  MOVWF  FE9
1E2E:  MOVFF  FF2,6D6
1E32:  BCF    FF2.7
1E34:  MOVLW  0F
1E36:  MOVWF  01
1E38:  CLRF   FF7
1E3A:  MOVLW  00
1E3C:  CALL   03BA
1E40:  TBLRD*-
1E42:  TBLRD*+
1E44:  MOVFF  FF5,FEE
1E48:  DECFSZ 01,F
1E4A:  BRA    1E42
1E4C:  MOVLB  6
1E4E:  BTFSC  xD6.7
1E50:  BSF    FF2.7
1E52:  MOVLW  4F
1E54:  MOVWF  xC2
1E56:  MOVLW  4B
1E58:  MOVWF  xC3
1E5A:  CLRF   xC4
1E5C:  MOVLW  06
1E5E:  MOVLB  7
1E60:  MOVWF  x1A
1E62:  MOVLW  B3
1E64:  MOVWF  x19
1E66:  MOVLW  06
1E68:  MOVWF  x1C
1E6A:  MOVLW  C2
1E6C:  MOVWF  x1B
1E6E:  MOVLB  0
1E70:  CALL   0AAE
1E74:  MOVF   01,F
1E76:  BTFSC  FD8.2
1E78:  BRA    2050
....................             if(envia_SIM800L("AT+SAPBR=2,1\r\n","+SAPBR:")) 
1E7A:  MOVLW  06
1E7C:  MOVWF  FEA
1E7E:  MOVLW  B3
1E80:  MOVWF  FE9
1E82:  MOVFF  FF2,6D6
1E86:  BCF    FF2.7
1E88:  MOVLW  0F
1E8A:  MOVWF  01
1E8C:  CLRF   FF7
1E8E:  MOVLW  00
1E90:  CALL   03E4
1E94:  TBLRD*-
1E96:  TBLRD*+
1E98:  MOVFF  FF5,FEE
1E9C:  DECFSZ 01,F
1E9E:  BRA    1E96
1EA0:  MOVLB  6
1EA2:  BTFSC  xD6.7
1EA4:  BSF    FF2.7
1EA6:  MOVLW  06
1EA8:  MOVWF  FEA
1EAA:  MOVLW  C2
1EAC:  MOVWF  FE9
1EAE:  MOVFF  FF2,6D8
1EB2:  BCF    FF2.7
1EB4:  MOVLW  08
1EB6:  MOVWF  01
1EB8:  CLRF   FF7
1EBA:  MOVLW  00
1EBC:  MOVLB  0
1EBE:  CALL   040E
1EC2:  TBLRD*-
1EC4:  TBLRD*+
1EC6:  MOVFF  FF5,FEE
1ECA:  DECFSZ 01,F
1ECC:  BRA    1EC4
1ECE:  MOVLB  6
1ED0:  BTFSC  xD8.7
1ED2:  BSF    FF2.7
1ED4:  MOVLW  06
1ED6:  MOVLB  7
1ED8:  MOVWF  x1A
1EDA:  MOVLW  B3
1EDC:  MOVWF  x19
1EDE:  MOVLW  06
1EE0:  MOVWF  x1C
1EE2:  MOVLW  C2
1EE4:  MOVWF  x1B
1EE6:  MOVLB  0
1EE8:  CALL   0AAE
1EEC:  MOVF   01,F
1EEE:  BTFSC  FD8.2
1EF0:  BRA    2050
....................               if(envia_SIM800L("AT+CLBSCFG=0,1\r\n","+CLBSCFG:")){                 
1EF2:  MOVLW  06
1EF4:  MOVWF  FEA
1EF6:  MOVLW  B3
1EF8:  MOVWF  FE9
1EFA:  MOVFF  FF2,6D6
1EFE:  BCF    FF2.7
1F00:  MOVLW  11
1F02:  MOVWF  01
1F04:  CLRF   FF7
1F06:  MOVLW  00
1F08:  CALL   0430
1F0C:  TBLRD*-
1F0E:  TBLRD*+
1F10:  MOVFF  FF5,FEE
1F14:  DECFSZ 01,F
1F16:  BRA    1F0E
1F18:  MOVLB  6
1F1A:  BTFSC  xD6.7
1F1C:  BSF    FF2.7
1F1E:  MOVLW  06
1F20:  MOVWF  FEA
1F22:  MOVLW  C4
1F24:  MOVWF  FE9
1F26:  MOVFF  FF2,6D8
1F2A:  BCF    FF2.7
1F2C:  MOVLW  0A
1F2E:  MOVWF  01
1F30:  CLRF   FF7
1F32:  MOVLW  00
1F34:  MOVLB  0
1F36:  CALL   045C
1F3A:  TBLRD*-
1F3C:  TBLRD*+
1F3E:  MOVFF  FF5,FEE
1F42:  DECFSZ 01,F
1F44:  BRA    1F3C
1F46:  MOVLB  6
1F48:  BTFSC  xD8.7
1F4A:  BSF    FF2.7
1F4C:  MOVLW  06
1F4E:  MOVLB  7
1F50:  MOVWF  x1A
1F52:  MOVLW  B3
1F54:  MOVWF  x19
1F56:  MOVLW  06
1F58:  MOVWF  x1C
1F5A:  MOVLW  C4
1F5C:  MOVWF  x1B
1F5E:  MOVLB  0
1F60:  CALL   0AAE
1F64:  MOVF   01,F
1F66:  BZ    2050
....................                 if(envia_SIM800L("AT+CLBS=1,1\r\n","+CLBS:")){ 
1F68:  MOVLW  06
1F6A:  MOVWF  FEA
1F6C:  MOVLW  B3
1F6E:  MOVWF  FE9
1F70:  MOVFF  FF2,6D6
1F74:  BCF    FF2.7
1F76:  MOVLW  0E
1F78:  MOVWF  01
1F7A:  CLRF   FF7
1F7C:  MOVLW  00
1F7E:  CALL   0480
1F82:  TBLRD*-
1F84:  TBLRD*+
1F86:  MOVFF  FF5,FEE
1F8A:  DECFSZ 01,F
1F8C:  BRA    1F84
1F8E:  MOVLB  6
1F90:  BTFSC  xD6.7
1F92:  BSF    FF2.7
1F94:  MOVLW  06
1F96:  MOVWF  FEA
1F98:  MOVLW  C1
1F9A:  MOVWF  FE9
1F9C:  MOVFF  FF2,6D8
1FA0:  BCF    FF2.7
1FA2:  MOVLW  07
1FA4:  MOVWF  01
1FA6:  CLRF   FF7
1FA8:  MOVLW  00
1FAA:  MOVLB  0
1FAC:  CALL   04A8
1FB0:  TBLRD*-
1FB2:  TBLRD*+
1FB4:  MOVFF  FF5,FEE
1FB8:  DECFSZ 01,F
1FBA:  BRA    1FB2
1FBC:  MOVLB  6
1FBE:  BTFSC  xD8.7
1FC0:  BSF    FF2.7
1FC2:  MOVLW  06
1FC4:  MOVLB  7
1FC6:  MOVWF  x1A
1FC8:  MOVLW  B3
1FCA:  MOVWF  x19
1FCC:  MOVLW  06
1FCE:  MOVWF  x1C
1FD0:  MOVLW  C1
1FD2:  MOVWF  x1B
1FD4:  MOVLB  0
1FD6:  CALL   0AAE
1FDA:  MOVF   01,F
1FDC:  BZ    2050
....................                   Get_Coordenadas(); 
1FDE:  BRA    1B74
....................                   Send_SMS(numero,coordenada);  
1FE0:  MOVFF  6B2,6D7
1FE4:  MOVFF  6B1,6D6
1FE8:  MOVLW  01
1FEA:  MOVLB  6
1FEC:  MOVWF  xD9
1FEE:  MOVLW  A1
1FF0:  MOVWF  xD8
1FF2:  MOVLB  0
1FF4:  CALL   0B9E
....................                   if(envia_SIM800L("AT+SAPBR=0,1\r\n","OK")) 
1FF8:  MOVLW  06
1FFA:  MOVWF  FEA
1FFC:  MOVLW  B3
1FFE:  MOVWF  FE9
2000:  MOVFF  FF2,6D6
2004:  BCF    FF2.7
2006:  MOVLW  0F
2008:  MOVWF  01
200A:  CLRF   FF7
200C:  MOVLW  00
200E:  CALL   04CA
2012:  TBLRD*-
2014:  TBLRD*+
2016:  MOVFF  FF5,FEE
201A:  DECFSZ 01,F
201C:  BRA    2014
201E:  MOVLB  6
2020:  BTFSC  xD6.7
2022:  BSF    FF2.7
2024:  MOVLW  4F
2026:  MOVWF  xC2
2028:  MOVLW  4B
202A:  MOVWF  xC3
202C:  CLRF   xC4
202E:  MOVLW  06
2030:  MOVLB  7
2032:  MOVWF  x1A
2034:  MOVLW  B3
2036:  MOVWF  x19
2038:  MOVLW  06
203A:  MOVWF  x1C
203C:  MOVLW  C2
203E:  MOVWF  x1B
2040:  MOVLB  0
2042:  CALL   0AAE
2046:  MOVF   01,F
2048:  BZ    2050
....................                     return 1;  
204A:  MOVLW  01
204C:  MOVWF  01
204E:  BRA    20A2
....................                 } 
....................               } 
....................   
....................   envia_SIM800L("AT+SAPBR=0,1\r\n","OK"); 
2050:  MOVLW  06
2052:  MOVWF  FEA
2054:  MOVLW  B3
2056:  MOVWF  FE9
2058:  MOVFF  FF2,6D6
205C:  BCF    FF2.7
205E:  MOVLW  0F
2060:  MOVWF  01
2062:  CLRF   FF7
2064:  MOVLW  00
2066:  CALL   04CA
206A:  TBLRD*-
206C:  TBLRD*+
206E:  MOVFF  FF5,FEE
2072:  DECFSZ 01,F
2074:  BRA    206C
2076:  MOVLB  6
2078:  BTFSC  xD6.7
207A:  BSF    FF2.7
207C:  MOVLW  4F
207E:  MOVWF  xC2
2080:  MOVLW  4B
2082:  MOVWF  xC3
2084:  CLRF   xC4
2086:  MOVLW  06
2088:  MOVLB  7
208A:  MOVWF  x1A
208C:  MOVLW  B3
208E:  MOVWF  x19
2090:  MOVLW  06
2092:  MOVWF  x1C
2094:  MOVLW  C2
2096:  MOVWF  x1B
2098:  MOVLB  0
209A:  CALL   0AAE
....................   return 0;    
209E:  MOVLW  00
20A0:  MOVWF  01
20A2:  GOTO   29C0 (RETURN)
.................... } 
....................  
.................... void Get_Coordenadas(){ 
*
1B74:  MOVLB  6
1B76:  CLRF   xD6
1B78:  CLRF   xD7
....................   
....................  int8 index=0; 
....................  int8 index2=0; 
....................  
....................   memset (coordenada, 0x00, sizeof(coordenada)); 
1B7A:  MOVLW  01
1B7C:  MOVWF  FEA
1B7E:  MOVLW  A1
1B80:  MOVWF  FE9
1B82:  CLRF   00
1B84:  CLRF   02
1B86:  MOVLW  28
1B88:  MOVWF  01
1B8A:  MOVLB  0
1B8C:  RCALL  1B44
....................    
....................   coordenada[0] ='L'; 
1B8E:  MOVLW  4C
1B90:  MOVLB  1
1B92:  MOVWF  xA1
....................   coordenada[1] ='O'; 
1B94:  MOVLW  4F
1B96:  MOVWF  xA2
....................   coordenada[2] ='C'; 
1B98:  MOVLW  43
1B9A:  MOVWF  xA3
....................   coordenada[3] ='A'; 
1B9C:  MOVLW  41
1B9E:  MOVWF  xA4
....................   coordenada[4] ='T'; 
1BA0:  MOVLW  54
1BA2:  MOVWF  xA5
....................   coordenada[5] ='E'; 
1BA4:  MOVLW  45
1BA6:  MOVWF  xA6
....................   coordenada[6] =':'; 
1BA8:  MOVLW  3A
1BAA:  MOVWF  xA7
....................   coordenada[7] =' '; 
1BAC:  MOVLW  20
1BAE:  MOVWF  xA8
....................   
....................   index2 = 8; 
1BB0:  MOVLW  08
1BB2:  MOVLB  6
1BB4:  MOVWF  xD7
....................   for(index=22;index<33;index++){ //Latitude 
1BB6:  MOVLW  16
1BB8:  MOVWF  xD6
1BBA:  MOVF   xD6,W
1BBC:  SUBLW  20
1BBE:  BNC   1BF4
....................    coordenada[index2] = comando_recibido_UART[index]; 
1BC0:  CLRF   03
1BC2:  MOVF   xD7,W
1BC4:  ADDLW  A1
1BC6:  MOVWF  01
1BC8:  MOVLW  01
1BCA:  ADDWFC 03,F
1BCC:  MOVFF  03,6D9
1BD0:  CLRF   03
1BD2:  MOVF   xD6,W
1BD4:  ADDLW  52
1BD6:  MOVWF  FE9
1BD8:  MOVLW  00
1BDA:  ADDWFC 03,W
1BDC:  MOVWF  FEA
1BDE:  MOVFF  FEF,6DA
1BE2:  MOVFF  6D9,FEA
1BE6:  MOVFF  01,FE9
1BEA:  MOVFF  6DA,FEF
....................    index2++;    
1BEE:  INCF   xD7,F
1BF0:  INCF   xD6,F
1BF2:  BRA    1BBA
....................   } 
....................  
....................   for(index=11;index<22;index++){ //Longitude 
1BF4:  MOVLW  0B
1BF6:  MOVWF  xD6
1BF8:  MOVF   xD6,W
1BFA:  SUBLW  15
1BFC:  BNC   1C32
....................    coordenada[index2] = comando_recibido_UART[index]; 
1BFE:  CLRF   03
1C00:  MOVF   xD7,W
1C02:  ADDLW  A1
1C04:  MOVWF  01
1C06:  MOVLW  01
1C08:  ADDWFC 03,F
1C0A:  MOVFF  03,6D9
1C0E:  CLRF   03
1C10:  MOVF   xD6,W
1C12:  ADDLW  52
1C14:  MOVWF  FE9
1C16:  MOVLW  00
1C18:  ADDWFC 03,W
1C1A:  MOVWF  FEA
1C1C:  MOVFF  FEF,6DA
1C20:  MOVFF  6D9,FEA
1C24:  MOVFF  01,FE9
1C28:  MOVFF  6DA,FEF
....................    index2++;    
1C2C:  INCF   xD7,F
1C2E:  INCF   xD6,F
1C30:  BRA    1BF8
....................   } 
....................    
....................   coordenada[index2++] =' '; 
1C32:  MOVF   xD7,W
1C34:  INCF   xD7,F
1C36:  CLRF   03
1C38:  ADDLW  A1
1C3A:  MOVWF  FE9
1C3C:  MOVLW  01
1C3E:  ADDWFC 03,W
1C40:  MOVWF  FEA
1C42:  MOVLW  20
1C44:  MOVWF  FEF
....................   coordenada[index2++] ='R'; 
1C46:  MOVF   xD7,W
1C48:  INCF   xD7,F
1C4A:  CLRF   03
1C4C:  ADDLW  A1
1C4E:  MOVWF  FE9
1C50:  MOVLW  01
1C52:  ADDWFC 03,W
1C54:  MOVWF  FEA
1C56:  MOVLW  52
1C58:  MOVWF  FEF
....................   coordenada[index2++] ='='; 
1C5A:  MOVF   xD7,W
1C5C:  INCF   xD7,F
1C5E:  CLRF   03
1C60:  ADDLW  A1
1C62:  MOVWF  FE9
1C64:  MOVLW  01
1C66:  ADDWFC 03,W
1C68:  MOVWF  FEA
1C6A:  MOVLW  3D
1C6C:  MOVWF  FEF
....................  
....................   for(index=33;index<36;index++){ //Preciso 
1C6E:  MOVLW  21
1C70:  MOVWF  xD6
1C72:  MOVF   xD6,W
1C74:  SUBLW  23
1C76:  BNC   1CAC
....................    coordenada[index2] = comando_recibido_UART[index]; 
1C78:  CLRF   03
1C7A:  MOVF   xD7,W
1C7C:  ADDLW  A1
1C7E:  MOVWF  01
1C80:  MOVLW  01
1C82:  ADDWFC 03,F
1C84:  MOVFF  03,6D9
1C88:  CLRF   03
1C8A:  MOVF   xD6,W
1C8C:  ADDLW  52
1C8E:  MOVWF  FE9
1C90:  MOVLW  00
1C92:  ADDWFC 03,W
1C94:  MOVWF  FEA
1C96:  MOVFF  FEF,6DA
1C9A:  MOVFF  6D9,FEA
1C9E:  MOVFF  01,FE9
1CA2:  MOVFF  6DA,FEF
....................    index2++;    
1CA6:  INCF   xD7,F
1CA8:  INCF   xD6,F
1CAA:  BRA    1C72
....................   } 
....................    
....................   coordenada[index2++] ='m'; 
1CAC:  MOVF   xD7,W
1CAE:  INCF   xD7,F
1CB0:  CLRF   03
1CB2:  ADDLW  A1
1CB4:  MOVWF  FE9
1CB6:  MOVLW  01
1CB8:  ADDWFC 03,W
1CBA:  MOVWF  FEA
1CBC:  MOVLW  6D
1CBE:  MOVWF  FEF
....................   coordenada[index2] = 0; 
1CC0:  CLRF   03
1CC2:  MOVF   xD7,W
1CC4:  ADDLW  A1
1CC6:  MOVWF  FE9
1CC8:  MOVLW  01
1CCA:  ADDWFC 03,W
1CCC:  MOVWF  FEA
1CCE:  CLRF   FEF
1CD0:  MOVLB  0
1CD2:  GOTO   1FE0 (RETURN)
....................  
.................... } 
....................  
....................  
.................... #ENDIF 
....................  
....................  
.................... // Declaração de Variáveis 
....................  
.................... int1 comando_disponivel_UART = FALSE; 
.................... int1 One_Second = FALSE; 
.................... int1 One_Minute = FALSE; 
.................... int16 Miliseconds = 0; 
.................... int16 seconds = 0; 
.................... char comando = 0; 
.................... int1 resposta_SIM = false; 
.................... int8 leitura_tensao_partida[400]; 
.................... int1 partida_iniciada = FALSE; 
.................... int1 aquisicao_tensao_partida = FALSE; 
.................... int1 veiculo_ligado = FALSE; 
.................... int16 index = 0; 
.................... unsigned int8 index_1 = 0; 
.................... unsigned int8 index_2 = 0; 
.................... int8 V1 = 255; 
.................... int8 V2 = 255; 
.................... int1 sel_ad = FALSE; 
.................... unsigned int16 leitura_corrente[100]; 
.................... unsigned int16 offset_current_ref[100]; 
.................... unsigned int8 leitura_tensao[100]; 
.................... unsigned int16 aux_leitura[100]; 
.................... float aux_offset_current_ref = 0; 
.................... float aux_corrente = 0; 
.................... float aux_tensao = 0; 
.................... float zero_set = 0; 
.................... float zero_set_aux = 0; 
.................... int32 corrente_limite = 3000; 
.................... int8 qtd_numeros=0; 
.................... int8 tempo_corrente_verif = 0;  
.................... int8 index_envio = 0; 
.................... int32 tempo_entre_alertas = 1; 
.................... int32 tempo_ultimo_alerta = 1; 
.................... char numero[20]; 
.................... //Fim declaração de variáveis 
....................  
.................... #INT_RTCC 
.................... void Timer_0(){ 
....................  
....................   set_timer0(6);   
*
0790:  CLRF   FD7
0792:  MOVLW  06
0794:  MOVWF  FD6
....................    
....................   if(partida_iniciada){ 
0796:  MOVLB  1
0798:  BTFSS  x82.4
079A:  BRA    07F4
....................      
....................     if(index<400){  
079C:  MOVLB  3
079E:  MOVF   x5F,W
07A0:  SUBLW  01
07A2:  BNC   07E0
07A4:  BNZ   07AC
07A6:  MOVF   x5E,W
07A8:  SUBLW  8F
07AA:  BNC   07E0
....................  
....................       leitura_tensao_partida[index] = (read_adc()>>2); 
07AC:  MOVLW  CE
07AE:  ADDWF  x5E,W
07B0:  MOVWF  FE9
07B2:  MOVLW  01
07B4:  ADDWFC x5F,W
07B6:  MOVWF  FEA
07B8:  BSF    FC2.1
07BA:  BTFSC  FC2.1
07BC:  BRA    07BA
07BE:  MOVLB  7
07C0:  RRCF   FC4,W
07C2:  MOVWF  03
07C4:  RRCF   FC3,W
07C6:  MOVWF  02
07C8:  RRCF   03,F
07CA:  RRCF   02,F
07CC:  MOVLW  3F
07CE:  ANDWF  03,F
07D0:  MOVFF  02,FEF
....................       output_toggle(PIN_A0); 
07D4:  BTG    F89.0
....................       index++; 
07D6:  MOVLB  3
07D8:  INCF   x5E,F
07DA:  BTFSC  FD8.2
07DC:  INCF   x5F,F
....................     }  
07DE:  BRA    07F0
....................     else{ 
....................       index = 0; 
07E0:  CLRF   x5F
07E2:  CLRF   x5E
....................       partida_iniciada = FALSE; 
07E4:  MOVLB  1
07E6:  BCF    x82.4
....................       aquisicao_tensao_partida = TRUE; 
07E8:  BSF    x82.5
....................       enable_interrupts(INT_RDA); 
07EA:  BSF    F9D.5
....................       enable_interrupts(INT_EXT); 
07EC:  BSF    FF2.4
07EE:  MOVLB  3
....................     } 
....................   } 
07F0:  BRA    0904
07F2:  MOVLB  1
....................   else{ 
....................     Miliseconds++; 
07F4:  INCF   xC9,F
07F6:  BTFSC  FD8.2
07F8:  INCF   xCA,F
....................  
....................     if(Miliseconds % 5 == 0){ 
07FA:  MOVFF  1CA,730
07FE:  MOVFF  1C9,72F
0802:  MOVLB  7
0804:  CLRF   x32
0806:  MOVLW  05
0808:  MOVWF  x31
080A:  MOVLB  0
080C:  BRA    0748
080E:  MOVFF  00,72F
0812:  MOVLB  7
0814:  MOVFF  03,730
0818:  MOVF   x2F,F
081A:  BNZ   08CE
081C:  MOVF   x30,F
081E:  BNZ   08CE
....................       sel_ad = !sel_ad; 
0820:  MOVLB  1
0822:  BTG    x82.7
....................     
....................       if(sel_ad){ 
0824:  BTFSS  x82.7
0826:  BRA    0890
....................         leitura_corrente[index_1] = read_adc(); 
0828:  BCF    FD8.0
082A:  MOVLB  3
082C:  RLCF   x60,W
082E:  CLRF   03
0830:  ADDLW  64
0832:  MOVWF  FE9
0834:  MOVLW  03
0836:  ADDWFC 03,W
0838:  MOVWF  FEA
083A:  BSF    FC2.1
083C:  BTFSC  FC2.1
083E:  BRA    083C
0840:  MOVFF  FC3,FEF
0844:  MOVFF  FC4,FEC
....................         set_adc_channel(3); 
0848:  MOVLW  0C
084A:  MOVWF  01
084C:  MOVF   FC2,W
084E:  ANDLW  C3
0850:  IORWF  01,W
0852:  MOVWF  FC2
....................         delay_us(10); 
0854:  MOVLW  0C
0856:  MOVWF  00
0858:  DECFSZ 00,F
085A:  BRA    0858
085C:  BRA    085E
085E:  NOP   
....................         offset_current_ref[index_1] = read_adc(); 
0860:  BCF    FD8.0
0862:  RLCF   x60,W
0864:  CLRF   03
0866:  ADDLW  2C
0868:  MOVWF  FE9
086A:  MOVLW  04
086C:  ADDWFC 03,W
086E:  MOVWF  FEA
0870:  BSF    FC2.1
0872:  BTFSC  FC2.1
0874:  BRA    0872
0876:  MOVFF  FC3,FEF
087A:  MOVFF  FC4,FEC
....................         set_adc_channel(1); 
087E:  MOVLW  04
0880:  MOVWF  01
0882:  MOVF   FC2,W
0884:  ANDLW  C3
0886:  IORWF  01,W
0888:  MOVWF  FC2
....................         index_1++; 
088A:  INCF   x60,F
....................       } 
088C:  BRA    08CC
088E:  MOVLB  1
....................       else{ 
....................         leitura_tensao[index_2] = (read_adc()>>2); 
0890:  CLRF   03
0892:  MOVLB  3
0894:  MOVF   x61,W
0896:  ADDLW  F4
0898:  MOVWF  FE9
089A:  MOVLW  04
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  BSF    FC2.1
08A2:  BTFSC  FC2.1
08A4:  BRA    08A2
08A6:  MOVLB  7
08A8:  RRCF   FC4,W
08AA:  MOVWF  03
08AC:  RRCF   FC3,W
08AE:  MOVWF  02
08B0:  RRCF   03,F
08B2:  RRCF   02,F
08B4:  MOVLW  3F
08B6:  ANDWF  03,F
08B8:  MOVFF  02,FEF
....................         set_adc_channel(2); 
08BC:  MOVLW  08
08BE:  MOVWF  01
08C0:  MOVF   FC2,W
08C2:  ANDLW  C3
08C4:  IORWF  01,W
08C6:  MOVWF  FC2
....................         index_2++; 
08C8:  MOVLB  3
08CA:  INCF   x61,F
08CC:  MOVLB  7
....................       }  
....................     } 
....................  
....................     if(Miliseconds == 1000){ 
08CE:  MOVLB  1
08D0:  MOVF   xC9,W
08D2:  SUBLW  E8
08D4:  BNZ   0902
08D6:  MOVF   xCA,W
08D8:  SUBLW  03
08DA:  BNZ   0902
....................       seconds++; 
08DC:  INCF   xCB,F
08DE:  BTFSC  FD8.2
08E0:  INCF   xCC,F
....................       Miliseconds = 0; 
08E2:  CLRF   xCA
08E4:  CLRF   xC9
....................       One_Second = TRUE; 
08E6:  BSF    x82.2
....................       index_1 = 0; 
08E8:  MOVLB  3
08EA:  CLRF   x60
....................       index_2 = 0; 
08EC:  CLRF   x61
....................       output_toggle(PIN_A0); 
08EE:  BTG    F89.0
....................       if(seconds==60){ 
08F0:  MOVLB  1
08F2:  MOVF   xCB,W
08F4:  SUBLW  3C
08F6:  BNZ   0902
08F8:  MOVF   xCC,F
08FA:  BNZ   0902
....................         seconds = 0; 
08FC:  CLRF   xCC
08FE:  CLRF   xCB
....................         One_Minute = TRUE; 
0900:  BSF    x82.3
0902:  MOVLB  3
....................       } 
....................     } 
....................   } 
....................   return; 
.................... } 
....................  
0904:  BCF    FF2.2
0906:  MOVLB  0
0908:  GOTO   006C
.................... #INT_EXT 
.................... void Interrupcao_Externa(){ 
....................    
....................   set_adc_channel(1); 
090C:  MOVLW  04
090E:  MOVWF  01
0910:  MOVF   FC2,W
0912:  ANDLW  C3
0914:  IORWF  01,W
0916:  MOVWF  FC2
....................   disable_interrupts(INT_RDA); 
0918:  BCF    F9D.5
....................   disable_interrupts(INT_EXT); 
091A:  BCF    FF2.4
....................   partida_iniciada = TRUE; 
091C:  MOVLB  1
091E:  BSF    x82.4
....................   veiculo_ligado = TRUE; 
0920:  BSF    x82.6
....................   aquisicao_tensao_partida = FALSE; 
0922:  BCF    x82.5
....................   index = 0; 
0924:  MOVLB  3
0926:  CLRF   x5F
0928:  CLRF   x5E
....................  
....................   return; 
092A:  BCF    FF2.1
092C:  MOVLB  0
092E:  GOTO   006C
.................... } 
....................  
.................... void main() 
*
2C94:  CLRF   FF8
2C96:  BCF    FD0.7
2C98:  BSF    07.7
2C9A:  CLRF   16
2C9C:  BSF    FB8.3
2C9E:  MOVLW  22
2CA0:  MOVWF  FAF
2CA2:  MOVLW  00
2CA4:  MOVWF  FB0
2CA6:  MOVLW  A6
2CA8:  MOVWF  FAC
2CAA:  MOVLW  90
2CAC:  MOVWF  FAB
2CAE:  BCF    F93.2
2CB0:  BSF    F8A.2
2CB2:  MOVLB  1
2CB4:  CLRF   x7F
2CB6:  CLRF   x7E
2CB8:  MOVLW  86
2CBA:  MOVWF  x81
2CBC:  MOVLW  A0
2CBE:  MOVWF  x80
2CC0:  CLRF   x9C
2CC2:  CLRF   x9B
2CC4:  CLRF   xA0
2CC6:  MOVLW  6A
2CC8:  MOVWF  x9F
2CCA:  MOVLW  CF
2CCC:  MOVWF  x9E
2CCE:  MOVLW  C0
2CD0:  MOVWF  x9D
2CD2:  BCF    x82.0
2CD4:  BCF    x82.2
2CD6:  BCF    x82.3
2CD8:  CLRF   xCA
2CDA:  CLRF   xC9
2CDC:  CLRF   xCC
2CDE:  CLRF   xCB
2CE0:  CLRF   xCD
2CE2:  BCF    x82.1
2CE4:  BCF    x82.4
2CE6:  BCF    x82.5
2CE8:  BCF    x82.6
2CEA:  MOVLB  3
2CEC:  CLRF   x5F
2CEE:  CLRF   x5E
2CF0:  CLRF   x60
2CF2:  CLRF   x61
2CF4:  SETF   x62
2CF6:  SETF   x63
2CF8:  MOVLB  1
2CFA:  BCF    x82.7
2CFC:  MOVLB  6
2CFE:  CLRF   x23
2D00:  CLRF   x22
2D02:  CLRF   x21
2D04:  CLRF   x20
2D06:  MOVLB  1
2D08:  CLRF   x8E
2D0A:  CLRF   x8D
2D0C:  CLRF   x8C
2D0E:  CLRF   x8B
2D10:  CLRF   x92
2D12:  CLRF   x91
2D14:  CLRF   x90
2D16:  CLRF   x8F
2D18:  CLRF   x96
2D1A:  CLRF   x95
2D1C:  CLRF   x94
2D1E:  CLRF   x93
2D20:  CLRF   x9A
2D22:  CLRF   x99
2D24:  CLRF   x98
2D26:  CLRF   x97
2D28:  CLRF   x86
2D2A:  CLRF   x85
2D2C:  MOVLW  0B
2D2E:  MOVWF  x84
2D30:  MOVLW  B8
2D32:  MOVWF  x83
2D34:  CLRF   4F
2D36:  MOVLB  6
2D38:  CLRF   x24
2D3A:  CLRF   x25
2D3C:  MOVLB  1
2D3E:  CLRF   x8A
2D40:  CLRF   x89
2D42:  CLRF   x88
2D44:  MOVLW  01
2D46:  MOVWF  x87
2D48:  MOVLB  6
2D4A:  CLRF   x29
2D4C:  CLRF   x28
2D4E:  CLRF   x27
2D50:  MOVWF  x26
2D52:  MOVF   FC1,W
2D54:  ANDLW  C0
2D56:  IORLW  0F
2D58:  MOVWF  FC1
2D5A:  MOVLW  07
2D5C:  MOVWF  FB4
2D5E:  CLRF   17
2D60:  CLRF   18
.................... { 
....................   set_tris_a (0b00001110);                                                     //Ra7-Ra6-Ra5-Ra4-Ra3-Ra2-Ra1-Ra0 
2D62:  MOVLW  0E
2D64:  MOVWF  F92
....................   set_tris_b (0b00001001);                                                     //Rb7-Rb6-Rb5-Rb4-Rb3-Rb2-Rb1-Rb0 
2D66:  MOVLW  09
2D68:  MOVWF  F93
....................   set_tris_c (0b10000000);                                                     //Rc7-Rc6-Rc5-Rc4-Rc3-Rc2-Rc1-Rc0 
2D6A:  MOVLW  80
2D6C:  MOVWF  F94
....................   set_tris_d (0b00000000);  
2D6E:  MOVLW  00
2D70:  MOVWF  F95
....................    
....................   setup_adc_ports(AN0_TO_AN3); 
2D72:  MOVF   FC1,W
2D74:  ANDLW  C0
2D76:  IORLW  0B
2D78:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_2); 
2D7A:  MOVF   FC0,W
2D7C:  ANDLW  C0
2D7E:  MOVWF  FC0
2D80:  BSF    FC0.7
2D82:  BSF    FC2.0
....................   set_adc_channel(1); 
2D84:  MOVLW  04
2D86:  MOVWF  01
2D88:  MOVF   FC2,W
2D8A:  ANDLW  C3
2D8C:  IORWF  01,W
2D8E:  MOVWF  FC2
....................   setup_wdt(WDT_OFF); 
2D90:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 | RTCC_8_BIT); 
2D92:  MOVLW  C3
2D94:  MOVWF  FD5
....................   set_timer0(6); 
2D96:  CLRF   FD7
2D98:  MOVLW  06
2D9A:  MOVWF  FD6
....................   ext_int_edge(H_TO_L); 
2D9C:  BCF    FF1.6
....................    
....................   enable_interrupts(INT_RTCC); 
2D9E:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
2DA0:  BSF    F9D.5
....................   enable_interrupts(GLOBAL);  
2DA2:  MOVLW  C0
2DA4:  IORWF  FF2,F
....................   output_low(PIN_D2); 
2DA6:  BCF    F8C.2
....................   delay_ms(2000); 
2DA8:  MOVLW  08
2DAA:  MOVWF  x58
2DAC:  MOVLW  FA
2DAE:  MOVLB  7
2DB0:  MOVWF  x24
2DB2:  MOVLB  0
2DB4:  CALL   0954
2DB8:  MOVLB  6
2DBA:  DECFSZ x58,F
2DBC:  BRA    2DAC
....................   output_high(PIN_D2); 
2DBE:  BSF    F8C.2
....................   delay_ms(15000); 
2DC0:  MOVLW  3C
2DC2:  MOVWF  x58
2DC4:  MOVLW  FA
2DC6:  MOVLB  7
2DC8:  MOVWF  x24
2DCA:  MOVLB  0
2DCC:  CALL   0954
2DD0:  MOVLB  6
2DD2:  DECFSZ x58,F
2DD4:  BRA    2DC4
....................   Send_SMS("031995822739","INICIANDO..."); 
2DD6:  MOVLW  06
2DD8:  MOVWF  FEA
2DDA:  MOVLW  3E
2DDC:  MOVWF  FE9
2DDE:  MOVFF  FF2,658
2DE2:  BCF    FF2.7
2DE4:  MOVLW  0D
2DE6:  MOVWF  01
2DE8:  CLRF   FF7
2DEA:  MOVLW  00
2DEC:  MOVLB  0
2DEE:  CALL   04F4
2DF2:  TBLRD*-
2DF4:  TBLRD*+
2DF6:  MOVFF  FF5,FEE
2DFA:  DECFSZ 01,F
2DFC:  BRA    2DF4
2DFE:  MOVLB  6
2E00:  BTFSC  x58.7
2E02:  BSF    FF2.7
2E04:  MOVLW  06
2E06:  MOVWF  FEA
2E08:  MOVLW  4B
2E0A:  MOVWF  FE9
2E0C:  MOVFF  FF2,65A
2E10:  BCF    FF2.7
2E12:  MOVLW  0D
2E14:  MOVWF  01
2E16:  CLRF   FF7
2E18:  MOVLW  00
2E1A:  MOVLB  0
2E1C:  CALL   051C
2E20:  TBLRD*-
2E22:  TBLRD*+
2E24:  MOVFF  FF5,FEE
2E28:  DECFSZ 01,F
2E2A:  BRA    2E22
2E2C:  MOVLB  6
2E2E:  BTFSC  x5A.7
2E30:  BSF    FF2.7
2E32:  MOVLW  06
2E34:  MOVWF  xD7
2E36:  MOVLW  3E
2E38:  MOVWF  xD6
2E3A:  MOVLW  06
2E3C:  MOVWF  xD9
2E3E:  MOVLW  4B
2E40:  MOVWF  xD8
2E42:  MOVLB  0
2E44:  CALL   0B9E
....................   enable_interrupts(INT_EXT_H2L); 
2E48:  BSF    FF2.4
2E4A:  BCF    FF1.6
....................   clear_interrupt(INT_EXT); 
2E4C:  BCF    FF2.1
....................  
....................   while(TRUE){ 
....................  
....................     if(One_Second){ 
2E4E:  MOVLB  1
2E50:  BTFSS  x82.2
2E52:  BRA    2E5C
....................  
....................       One_Second = FALSE; 
2E54:  BCF    x82.2
....................       Executar_Cada_Segundo(); 
2E56:  MOVLB  0
2E58:  BRA    2A04
2E5A:  MOVLB  1
....................  
....................     } 
....................  
....................     if(One_Minute){ 
2E5C:  BTFSS  x82.3
2E5E:  BRA    2E68
....................  
....................       One_Minute = FALSE; 
2E60:  BCF    x82.3
....................       Executar_Cada_Minuto(); 
2E62:  MOVLB  0
2E64:  BRA    2B5E
2E66:  MOVLB  1
....................  
....................     } 
2E68:  BRA    2E50
....................  
....................   } 
....................  
.................... } 
....................  
2E6A:  SLEEP 
.................... void Executar_Cada_Segundo(){ 
....................    
....................   Calcula_SOC(); 
*
2A04:  GOTO   152C
....................    
....................   if(aquisicao_tensao_partida){ 
2A08:  MOVLB  1
2A0A:  BTFSS  x82.5
2A0C:  BRA    2A18
....................  
....................     aquisicao_tensao_partida = FALSE; 
2A0E:  BCF    x82.5
....................     Obtem_SOH(); 
2A10:  MOVLB  0
2A12:  GOTO   186C
2A16:  MOVLB  1
....................  
....................   } 
....................   if(comando_disponivel_UART){ 
2A18:  BTFSS  x82.0
2A1A:  BRA    2AC0
....................    
....................     disable_interrupts(GLOBAL); 
2A1C:  BCF    FF2.6
2A1E:  BCF    FF2.7
2A20:  BTFSC  FF2.7
2A22:  BRA    2A1E
....................     comando = Get_Comando(); 
2A24:  MOVLB  0
2A26:  CALL   18B4
2A2A:  MOVFF  01,1CD
....................      
....................     if(comando != 0){ 
2A2E:  MOVLB  1
2A30:  MOVF   xCD,F
2A32:  BZ    2A3E
....................  
....................       Executa_Comando(comando); 
2A34:  MOVFF  1CD,669
2A38:  MOVLB  0
2A3A:  RCALL  22B8
2A3C:  MOVLB  1
....................        
....................     } 
....................     if(resposta_SIM == 1){ 
2A3E:  BTFSS  x82.1
2A40:  BRA    2AB8
....................       disable_interrupts(GLOBAL); 
2A42:  BCF    FF2.6
2A44:  BCF    FF2.7
2A46:  BTFSC  FF2.7
2A48:  BRA    2A44
....................       resposta_SIM = 0; 
2A4A:  BCF    x82.1
....................       comando = Get_Comando(); 
2A4C:  MOVLB  0
2A4E:  CALL   18B4
2A52:  MOVFF  01,1CD
....................       Executa_Comando(comando); 
2A56:  MOVFF  1CD,669
2A5A:  RCALL  22B8
....................       delay_ms(100); 
2A5C:  MOVLW  64
2A5E:  MOVLB  7
2A60:  MOVWF  x24
2A62:  MOVLB  0
2A64:  CALL   0954
....................       envia_SIM800L("AT+CMGD=1,1\r\n", "OK"); 
2A68:  MOVLW  06
2A6A:  MOVWF  FEA
2A6C:  MOVLW  58
2A6E:  MOVWF  FE9
2A70:  MOVFF  FF2,669
2A74:  BCF    FF2.7
2A76:  MOVLW  0E
2A78:  MOVWF  01
2A7A:  CLRF   FF7
2A7C:  MOVLW  00
2A7E:  CALL   0544
2A82:  TBLRD*-
2A84:  TBLRD*+
2A86:  MOVFF  FF5,FEE
2A8A:  DECFSZ 01,F
2A8C:  BRA    2A84
2A8E:  MOVLB  6
2A90:  BTFSC  x69.7
2A92:  BSF    FF2.7
2A94:  MOVLW  4F
2A96:  MOVWF  x66
2A98:  MOVLW  4B
2A9A:  MOVWF  x67
2A9C:  CLRF   x68
2A9E:  MOVLW  06
2AA0:  MOVLB  7
2AA2:  MOVWF  x1A
2AA4:  MOVLW  58
2AA6:  MOVWF  x19
2AA8:  MOVLW  06
2AAA:  MOVWF  x1C
2AAC:  MOVLW  66
2AAE:  MOVWF  x1B
2AB0:  MOVLB  0
2AB2:  CALL   0AAE
2AB6:  MOVLB  1
....................     } 
....................     comando = 0; 
2AB8:  CLRF   xCD
....................     clear_command(); 
2ABA:  MOVLB  0
2ABC:  BRA    29C2
2ABE:  MOVLB  1
....................   } 
....................    
....................   return; 
2AC0:  MOVLB  0
2AC2:  GOTO   2E5A (RETURN)
.................... } 
....................  
.................... void Executar_Cada_Minuto(){ 
....................    
....................   index_envio = 0; 
*
2B5E:  MOVLB  6
2B60:  CLRF   x25
....................   if(aux_corrente > corrente_limite){ 
2B62:  MOVFF  186,69A
2B66:  MOVFF  185,699
2B6A:  MOVFF  184,698
2B6E:  MOVFF  183,697
2B72:  MOVLB  0
2B74:  BRA    2AC6
2B76:  MOVFF  03,69F
2B7A:  MOVFF  02,69E
2B7E:  MOVFF  01,69D
2B82:  MOVFF  00,69C
2B86:  MOVFF  18E,6A3
2B8A:  MOVFF  18D,6A2
2B8E:  MOVFF  18C,6A1
2B92:  MOVFF  18B,6A0
2B96:  CALL   11B8
2B9A:  BTFSS  FD8.0
2B9C:  BRA    2C8E
....................     ++tempo_corrente_verif; 
2B9E:  MOVLB  6
2BA0:  INCF   x24,F
....................     if(tempo_corrente_verif>1 && qtd_numeros>0 && tempo_entre_alertas>0){ 
2BA2:  MOVF   x24,W
2BA4:  SUBLW  01
2BA6:  BTFSC  FD8.0
2BA8:  BRA    2C8E
2BAA:  MOVF   4F,F
2BAC:  BTFSC  FD8.2
2BAE:  BRA    2C8E
2BB0:  MOVLB  1
2BB2:  MOVF   x87,F
2BB4:  BNZ   2BC8
2BB6:  MOVF   x88,F
2BB8:  BNZ   2BC8
2BBA:  MOVF   x89,F
2BBC:  BNZ   2BC8
2BBE:  MOVF   x8A,F
2BC0:  BTFSS  FD8.2
2BC2:  BRA    2BC8
2BC4:  MOVLB  6
2BC6:  BRA    2C8E
....................       tempo_ultimo_alerta++; 
2BC8:  MOVLW  01
2BCA:  MOVLB  6
2BCC:  ADDWF  x26,F
2BCE:  BTFSC  FD8.0
2BD0:  INCF   x27,F
2BD2:  BTFSC  FD8.2
2BD4:  INCF   x28,F
2BD6:  BTFSC  FD8.2
2BD8:  INCF   x29,F
....................  
....................       disable_interrupts(INT_EXT);  
2BDA:  BCF    FF2.4
....................        
....................       if(tempo_ultimo_alerta >= tempo_entre_alertas){    
2BDC:  MOVLB  1
2BDE:  MOVF   x8A,W
2BE0:  MOVLB  6
2BE2:  SUBWF  x29,W
2BE4:  BNC   2C8C
2BE6:  BNZ   2C0A
2BE8:  MOVLB  1
2BEA:  MOVF   x89,W
2BEC:  MOVLB  6
2BEE:  SUBWF  x28,W
2BF0:  BNC   2C8C
2BF2:  BNZ   2C0A
2BF4:  MOVLB  1
2BF6:  MOVF   x88,W
2BF8:  MOVLB  6
2BFA:  SUBWF  x27,W
2BFC:  BNC   2C8C
2BFE:  BNZ   2C0A
2C00:  MOVLB  1
2C02:  MOVF   x87,W
2C04:  MOVLB  6
2C06:  SUBWF  x26,W
2C08:  BNC   2C8C
....................         tempo_ultimo_alerta = 0; 
2C0A:  CLRF   x29
2C0C:  CLRF   x28
2C0E:  CLRF   x27
2C10:  CLRF   x26
....................         tempo_corrente_verif = 0;   
2C12:  CLRF   x24
....................          
....................         for(index_envio = 0; index_envio < qtd_numeros; index_envio++){ 
2C14:  CLRF   x25
2C16:  MOVF   4F,W
2C18:  SUBWF  x25,W
2C1A:  BC    2C8C
....................           memset (numero, 0x00, sizeof(numero)); 
2C1C:  MOVLW  06
2C1E:  MOVWF  FEA
2C20:  MOVLW  2A
2C22:  MOVWF  FE9
2C24:  CLRF   00
2C26:  CLRF   02
2C28:  MOVLW  14
2C2A:  MOVWF  01
2C2C:  MOVLB  0
2C2E:  CALL   1B44
....................           obtem_numero(index_envio,numero); 
2C32:  MOVFF  625,697
2C36:  MOVLW  06
2C38:  MOVLB  6
2C3A:  MOVWF  x99
2C3C:  MOVLW  2A
2C3E:  MOVWF  x98
2C40:  MOVLB  0
2C42:  BRA    2B00
....................           Send_SMS(numero,"!!!ALERTA: Bateria em descarga rapida VERIFIQUE SEU VEICULO!!!"); 
2C44:  MOVLW  06
2C46:  MOVWF  FEA
2C48:  MOVLW  58
2C4A:  MOVWF  FE9
2C4C:  MOVFF  FF2,697
2C50:  BCF    FF2.7
2C52:  MOVLW  3F
2C54:  MOVWF  01
2C56:  CLRF   FF7
2C58:  MOVLW  00
2C5A:  CALL   056C
2C5E:  TBLRD*-
2C60:  TBLRD*+
2C62:  MOVFF  FF5,FEE
2C66:  DECFSZ 01,F
2C68:  BRA    2C60
2C6A:  MOVLB  6
2C6C:  BTFSC  x97.7
2C6E:  BSF    FF2.7
2C70:  MOVLW  06
2C72:  MOVWF  xD7
2C74:  MOVLW  2A
2C76:  MOVWF  xD6
2C78:  MOVLW  06
2C7A:  MOVWF  xD9
2C7C:  MOVLW  58
2C7E:  MOVWF  xD8
2C80:  MOVLB  0
2C82:  CALL   0B9E
2C86:  MOVLB  6
2C88:  INCF   x25,F
2C8A:  BRA    2C16
....................    
....................         } 
....................       } 
....................       enable_interrupts(INT_EXT); 
2C8C:  BSF    FF2.4
2C8E:  MOVLB  0
....................     } 
....................        
....................   }   
....................   return; 
2C90:  GOTO   2E66 (RETURN)
.................... } 
....................  
.................... void Obtem_SOH(){ 
....................   
....................   V1 = 255; 
*
186C:  MOVLB  3
186E:  SETF   x62
....................   V2 = 255; 
1870:  SETF   x63
....................   index = 0; 
1872:  CLRF   x5F
1874:  CLRF   x5E
....................  
....................   for(index=0;index<15;index++){ 
1876:  CLRF   x5F
1878:  CLRF   x5E
187A:  MOVF   x5F,F
187C:  BNZ   18AE
187E:  MOVF   x5E,W
1880:  SUBLW  0E
1882:  BNC   18AE
....................      
....................     if(leitura_tensao_partida[index]<V1) 
1884:  MOVLW  CE
1886:  ADDWF  x5E,W
1888:  MOVWF  FE9
188A:  MOVLW  01
188C:  ADDWFC x5F,W
188E:  MOVWF  FEA
1890:  MOVF   x62,W
1892:  SUBWF  FEF,W
1894:  BC    18A6
....................       V1 = leitura_tensao[index]; 
1896:  MOVLW  F4
1898:  ADDWF  x5E,W
189A:  MOVWF  FE9
189C:  MOVLW  04
189E:  ADDWFC x5F,W
18A0:  MOVWF  FEA
18A2:  MOVFF  FEF,362
18A6:  INCF   x5E,F
18A8:  BTFSC  FD8.2
18AA:  INCF   x5F,F
18AC:  BRA    187A
....................     
....................   } 
....................    
....................  
....................   return; 
18AE:  MOVLB  0
18B0:  GOTO   2A16 (RETURN)
.................... } 
....................  
.................... void Calcula_SOC(){ 
*
152C:  MOVLB  6
152E:  CLRF   x69
....................    
....................   int8 i=0; 
....................   char exibe[50]; 
....................  
....................   for(i=0; i<100;i++) 
1530:  CLRF   x69
1532:  MOVF   x69,W
1534:  SUBLW  63
1536:  BNC   1582
....................     aux_leitura[i] = leitura_corrente[i]; 
1538:  BCF    FD8.0
153A:  RLCF   x69,W
153C:  CLRF   03
153E:  ADDLW  58
1540:  MOVWF  01
1542:  MOVLW  05
1544:  ADDWFC 03,F
1546:  MOVFF  01,69C
154A:  MOVFF  03,69D
154E:  BCF    FD8.0
1550:  RLCF   x69,W
1552:  CLRF   03
1554:  ADDLW  64
1556:  MOVWF  FE9
1558:  MOVLW  03
155A:  ADDWFC 03,W
155C:  MOVWF  FEA
155E:  MOVFF  FEC,03
1562:  MOVF   FED,F
1564:  MOVFF  FEF,69E
1568:  MOVFF  03,69F
156C:  MOVFF  69D,FEA
1570:  MOVFF  01,FE9
1574:  MOVFF  03,FEC
1578:  MOVF   FED,F
157A:  MOVFF  69E,FEF
157E:  INCF   x69,F
1580:  BRA    1532
....................   aux_corrente = obtem_mediana(aux_leitura,100); 
1582:  MOVLW  05
1584:  MOVWF  x9D
1586:  MOVLW  58
1588:  MOVWF  x9C
158A:  MOVLW  64
158C:  MOVWF  x9E
158E:  MOVLB  0
1590:  CALL   0CE4
1594:  MOVFF  02,69D
1598:  MOVFF  01,69C
159C:  RCALL  0E14
159E:  MOVFF  03,18E
15A2:  MOVFF  02,18D
15A6:  MOVFF  01,18C
15AA:  MOVFF  00,18B
....................    
....................   for(i=0; i<100;i++) 
15AE:  MOVLB  6
15B0:  CLRF   x69
15B2:  MOVF   x69,W
15B4:  SUBLW  63
15B6:  BNC   1602
....................     aux_leitura[i] = offset_current_ref[i]; 
15B8:  BCF    FD8.0
15BA:  RLCF   x69,W
15BC:  CLRF   03
15BE:  ADDLW  58
15C0:  MOVWF  01
15C2:  MOVLW  05
15C4:  ADDWFC 03,F
15C6:  MOVFF  01,69C
15CA:  MOVFF  03,69D
15CE:  BCF    FD8.0
15D0:  RLCF   x69,W
15D2:  CLRF   03
15D4:  ADDLW  2C
15D6:  MOVWF  FE9
15D8:  MOVLW  04
15DA:  ADDWFC 03,W
15DC:  MOVWF  FEA
15DE:  MOVFF  FEC,03
15E2:  MOVF   FED,F
15E4:  MOVFF  FEF,69E
15E8:  MOVFF  03,69F
15EC:  MOVFF  69D,FEA
15F0:  MOVFF  01,FE9
15F4:  MOVFF  03,FEC
15F8:  MOVF   FED,F
15FA:  MOVFF  69E,FEF
15FE:  INCF   x69,F
1600:  BRA    15B2
....................   aux_offset_current_ref = obtem_mediana(aux_leitura,100); 
1602:  MOVLW  05
1604:  MOVWF  x9D
1606:  MOVLW  58
1608:  MOVWF  x9C
160A:  MOVLW  64
160C:  MOVWF  x9E
160E:  MOVLB  0
1610:  CALL   0CE4
1614:  MOVFF  02,69D
1618:  MOVFF  01,69C
161C:  CALL   0E14
1620:  MOVFF  03,623
1624:  MOVFF  02,622
1628:  MOVFF  01,621
162C:  MOVFF  00,620
....................  
....................   for(i=0; i<100;i++) 
1630:  MOVLB  6
1632:  CLRF   x69
1634:  MOVF   x69,W
1636:  SUBLW  63
1638:  BNC   1676
....................     aux_leitura[i] = leitura_tensao[i]; 
163A:  BCF    FD8.0
163C:  RLCF   x69,W
163E:  CLRF   03
1640:  ADDLW  58
1642:  MOVWF  01
1644:  MOVLW  05
1646:  ADDWFC 03,F
1648:  MOVFF  01,69C
164C:  MOVFF  03,69D
1650:  CLRF   03
1652:  MOVF   x69,W
1654:  ADDLW  F4
1656:  MOVWF  FE9
1658:  MOVLW  04
165A:  ADDWFC 03,W
165C:  MOVWF  FEA
165E:  MOVFF  FEF,69E
1662:  MOVFF  69D,FEA
1666:  MOVFF  01,FE9
166A:  CLRF   FEC
166C:  MOVF   FED,F
166E:  MOVFF  69E,FEF
1672:  INCF   x69,F
1674:  BRA    1634
....................   aux_tensao = obtem_mediana(aux_leitura,100); 
1676:  MOVLW  05
1678:  MOVWF  x9D
167A:  MOVLW  58
167C:  MOVWF  x9C
167E:  MOVLW  64
1680:  MOVWF  x9E
1682:  MOVLB  0
1684:  CALL   0CE4
1688:  MOVFF  02,69D
168C:  MOVFF  01,69C
1690:  CALL   0E14
1694:  MOVFF  03,192
1698:  MOVFF  02,191
169C:  MOVFF  01,190
16A0:  MOVFF  00,18F
....................    
....................   aux_tensao = aux_tensao*(15.0/255.0); 
16A4:  MOVFF  192,6C1
16A8:  MOVFF  191,6C0
16AC:  MOVFF  190,6BF
16B0:  MOVFF  18F,6BE
16B4:  MOVLW  F1
16B6:  MOVLB  6
16B8:  MOVWF  xC5
16BA:  MOVLW  F0
16BC:  MOVWF  xC4
16BE:  MOVLW  70
16C0:  MOVWF  xC3
16C2:  MOVLW  7A
16C4:  MOVWF  xC2
16C6:  MOVLB  0
16C8:  CALL   0E4A
16CC:  MOVFF  03,192
16D0:  MOVFF  02,191
16D4:  MOVFF  01,190
16D8:  MOVFF  00,18F
....................   zero_set_aux = (aux_corrente-(aux_offset_current_ref)); 
16DC:  BSF    FD8.1
16DE:  MOVFF  18E,69F
16E2:  MOVFF  18D,69E
16E6:  MOVFF  18C,69D
16EA:  MOVFF  18B,69C
16EE:  MOVFF  623,6A3
16F2:  MOVFF  622,6A2
16F6:  MOVFF  621,6A1
16FA:  MOVFF  620,6A0
16FE:  RCALL  0F40
1700:  MOVFF  03,19A
1704:  MOVFF  02,199
1708:  MOVFF  01,198
170C:  MOVFF  00,197
....................   aux_corrente = (zero_set_aux-zero_set)*355; 
1710:  BSF    FD8.1
1712:  MOVFF  19A,69F
1716:  MOVFF  199,69E
171A:  MOVFF  198,69D
171E:  MOVFF  197,69C
1722:  MOVFF  196,6A3
1726:  MOVFF  195,6A2
172A:  MOVFF  194,6A1
172E:  MOVFF  193,6A0
1732:  RCALL  0F40
1734:  MOVFF  03,69F
1738:  MOVFF  02,69E
173C:  MOVFF  01,69D
1740:  MOVFF  00,69C
1744:  MOVFF  03,6C1
1748:  MOVFF  02,6C0
174C:  MOVFF  01,6BF
1750:  MOVFF  00,6BE
1754:  MOVLB  6
1756:  CLRF   xC5
1758:  MOVLW  80
175A:  MOVWF  xC4
175C:  MOVLW  31
175E:  MOVWF  xC3
1760:  MOVLW  87
1762:  MOVWF  xC2
1764:  MOVLB  0
1766:  CALL   0E4A
176A:  MOVFF  03,18E
176E:  MOVFF  02,18D
1772:  MOVFF  01,18C
1776:  MOVFF  00,18B
....................   if(aux_corrente > -750 && aux_corrente < 750) aux_corrente = 0; 
177A:  MOVLB  6
177C:  CLRF   x9F
177E:  MOVLW  80
1780:  MOVWF  x9E
1782:  MOVLW  BB
1784:  MOVWF  x9D
1786:  MOVLW  88
1788:  MOVWF  x9C
178A:  MOVFF  18E,6A3
178E:  MOVFF  18D,6A2
1792:  MOVFF  18C,6A1
1796:  MOVFF  18B,6A0
179A:  MOVLB  0
179C:  RCALL  11B8
179E:  BNC   17D2
17A0:  MOVFF  18E,69F
17A4:  MOVFF  18D,69E
17A8:  MOVFF  18C,69D
17AC:  MOVFF  18B,69C
17B0:  MOVLB  6
17B2:  CLRF   xA3
17B4:  MOVLW  80
17B6:  MOVWF  xA2
17B8:  MOVLW  3B
17BA:  MOVWF  xA1
17BC:  MOVLW  88
17BE:  MOVWF  xA0
17C0:  MOVLB  0
17C2:  RCALL  11B8
17C4:  BNC   17D2
17C6:  MOVLB  1
17C8:  CLRF   x8E
17CA:  CLRF   x8D
17CC:  CLRF   x8C
17CE:  CLRF   x8B
17D0:  MOVLB  0
....................  
....................   disable_interrupts(GLOBAL); 
17D2:  BCF    FF2.6
17D4:  BCF    FF2.7
17D6:  BTFSC  FF2.7
17D8:  BRA    17D4
....................   sprintf(exibe,"Corrente: %6.0f Tensao: %2.2f \r\n",aux_corrente,aux_tensao); 
17DA:  MOVLW  06
17DC:  MOVLB  1
17DE:  MOVWF  x9C
17E0:  MOVLW  6A
17E2:  MOVWF  x9B
17E4:  MOVLW  32
17E6:  MOVWF  FF6
17E8:  MOVLW  09
17EA:  MOVWF  FF7
17EC:  MOVLW  0A
17EE:  MOVLB  7
17F0:  MOVWF  x15
17F2:  MOVLB  0
17F4:  CALL   09A0
17F8:  MOVLW  05
17FA:  MOVWF  FE9
17FC:  MOVFF  18E,6B4
1800:  MOVFF  18D,6B3
1804:  MOVFF  18C,6B2
1808:  MOVFF  18B,6B1
180C:  MOVLB  6
180E:  CLRF   xB5
1810:  MOVLB  0
1812:  RCALL  130A
1814:  MOVLW  41
1816:  MOVWF  FF6
1818:  MOVLW  09
181A:  MOVWF  FF7
181C:  MOVLW  09
181E:  MOVLB  7
1820:  MOVWF  x15
1822:  MOVLB  0
1824:  CALL   09A0
1828:  MOVLW  89
182A:  MOVWF  FE9
182C:  MOVFF  192,6B4
1830:  MOVFF  191,6B3
1834:  MOVFF  190,6B2
1838:  MOVFF  18F,6B1
183C:  MOVLW  02
183E:  MOVLB  6
1840:  MOVWF  xB5
1842:  MOVLB  0
1844:  RCALL  130A
1846:  MOVLW  4F
1848:  MOVWF  FF6
184A:  MOVLW  09
184C:  MOVWF  FF7
184E:  MOVLW  03
1850:  MOVLB  7
1852:  MOVWF  x15
1854:  MOVLB  0
1856:  CALL   09A0
....................   fprintf(MONITOR_SERIAL,exibe); 
185A:  MOVLW  06
185C:  MOVWF  FEA
185E:  MOVLW  6A
1860:  MOVWF  FE9
1862:  BRA    1506
....................   enable_interrupts(GLOBAL); 
1864:  MOVLW  C0
1866:  IORWF  FF2,F
1868:  GOTO   2A08 (RETURN)
....................  
.................... } 
....................  
.................... unsigned int16 obtem_mediana(unsigned int16 *num, int8 tam){   
....................  
....................   int16 aux;  
....................   int16 i, j; 
....................  
....................   for (i = 0; i < (tam-1); i++){ 
*
0CE4:  MOVLB  6
0CE6:  CLRF   xA2
0CE8:  CLRF   xA1
0CEA:  MOVLW  01
0CEC:  SUBWF  x9E,W
0CEE:  MOVF   xA2,F
0CF0:  BTFSS  FD8.2
0CF2:  BRA    0DF8
0CF4:  SUBWF  xA1,W
0CF6:  BTFSC  FD8.0
0CF8:  BRA    0DF8
....................     for (j = i+1; j < tam; j++){ 
0CFA:  MOVLW  01
0CFC:  ADDWF  xA1,W
0CFE:  MOVWF  xA3
0D00:  MOVLW  00
0D02:  ADDWFC xA2,W
0D04:  MOVWF  xA4
0D06:  MOVF   xA4,F
0D08:  BNZ   0DF0
0D0A:  MOVF   x9E,W
0D0C:  SUBWF  xA3,W
0D0E:  BC    0DF0
....................       if (num[i] < num[j]) 
0D10:  BCF    FD8.0
0D12:  RLCF   xA1,W
0D14:  MOVWF  02
0D16:  RLCF   xA2,W
0D18:  MOVWF  03
0D1A:  MOVF   02,W
0D1C:  ADDWF  x9C,W
0D1E:  MOVWF  FE9
0D20:  MOVF   x9D,W
0D22:  ADDWFC 03,W
0D24:  MOVWF  FEA
0D26:  MOVFF  FEC,6A6
0D2A:  MOVF   FED,F
0D2C:  MOVFF  FEF,6A5
0D30:  BCF    FD8.0
0D32:  RLCF   xA3,W
0D34:  MOVWF  02
0D36:  RLCF   xA4,W
0D38:  MOVWF  03
0D3A:  MOVF   02,W
0D3C:  ADDWF  x9C,W
0D3E:  MOVWF  FE9
0D40:  MOVF   x9D,W
0D42:  ADDWFC 03,W
0D44:  MOVWF  FEA
0D46:  MOVFF  FEC,03
0D4A:  MOVF   FED,F
0D4C:  MOVFF  FEF,01
0D50:  MOVF   xA6,W
0D52:  SUBWF  03,W
0D54:  BNC   0DE8
0D56:  BNZ   0D5E
0D58:  MOVF   01,W
0D5A:  SUBWF  xA5,W
0D5C:  BC    0DE8
....................       { 
....................         aux = num[i]; 
0D5E:  BCF    FD8.0
0D60:  RLCF   xA1,W
0D62:  MOVWF  02
0D64:  RLCF   xA2,W
0D66:  MOVWF  03
0D68:  MOVF   02,W
0D6A:  ADDWF  x9C,W
0D6C:  MOVWF  FE9
0D6E:  MOVF   x9D,W
0D70:  ADDWFC 03,W
0D72:  MOVWF  FEA
0D74:  MOVFF  FEC,6A0
0D78:  MOVF   FED,F
0D7A:  MOVFF  FEF,69F
....................         num[i] = num[j]; 
0D7E:  BCF    FD8.0
0D80:  RLCF   xA1,W
0D82:  MOVWF  02
0D84:  RLCF   xA2,W
0D86:  MOVWF  03
0D88:  MOVF   02,W
0D8A:  ADDWF  x9C,W
0D8C:  MOVWF  01
0D8E:  MOVF   x9D,W
0D90:  ADDWFC 03,F
0D92:  MOVFF  03,6A6
0D96:  BCF    FD8.0
0D98:  RLCF   xA3,W
0D9A:  MOVWF  02
0D9C:  RLCF   xA4,W
0D9E:  MOVWF  03
0DA0:  MOVF   02,W
0DA2:  ADDWF  x9C,W
0DA4:  MOVWF  FE9
0DA6:  MOVF   x9D,W
0DA8:  ADDWFC 03,W
0DAA:  MOVWF  FEA
0DAC:  MOVFF  FEC,03
0DB0:  MOVF   FED,F
0DB2:  MOVFF  FEF,6A7
0DB6:  MOVFF  6A6,FEA
0DBA:  MOVFF  01,FE9
0DBE:  MOVFF  03,FEC
0DC2:  MOVF   FED,F
0DC4:  MOVFF  6A7,FEF
....................         num[j] = aux; 
0DC8:  BCF    FD8.0
0DCA:  RLCF   xA3,W
0DCC:  MOVWF  02
0DCE:  RLCF   xA4,W
0DD0:  MOVWF  03
0DD2:  MOVF   02,W
0DD4:  ADDWF  x9C,W
0DD6:  MOVWF  FE9
0DD8:  MOVF   x9D,W
0DDA:  ADDWFC 03,W
0DDC:  MOVWF  FEA
0DDE:  MOVFF  6A0,FEC
0DE2:  MOVF   FED,F
0DE4:  MOVFF  69F,FEF
....................       } 
0DE8:  INCF   xA3,F
0DEA:  BTFSC  FD8.2
0DEC:  INCF   xA4,F
0DEE:  BRA    0D06
....................     } 
0DF0:  INCF   xA1,F
0DF2:  BTFSC  FD8.2
0DF4:  INCF   xA2,F
0DF6:  BRA    0CEA
....................   } 
....................   return num[50];  
0DF8:  MOVLW  64
0DFA:  ADDWF  x9C,W
0DFC:  MOVWF  FE9
0DFE:  MOVLW  00
0E00:  ADDWFC x9D,W
0E02:  MOVWF  FEA
0E04:  MOVFF  FEF,01
0E08:  INCF   FE9,F
0E0A:  MOVF   FEF,W
0E0C:  DECF   FE9,F
0E0E:  MOVWF  02
0E10:  MOVLB  0
0E12:  RETURN 0
.................... } 

Configuration Fuses:
   Word  1: CE3B   PLL4 CPUDIV4 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
