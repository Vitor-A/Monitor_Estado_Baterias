CCS PCH C Compiler, Version 5.015, 5967               04-nov-18 22:38

               Filename:   C:\Users\Vitor\Desktop\Monitor_Estado_Baterias\TAI_Bateria.lst

               ROM used:   5928 bytes (18%)
                           Largest free fragment is 26840
               RAM used:   1148 (56%) at main() level
                           1376 (67%) worst case
               Stack used: 8 locations (6 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   15AA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.4
004A:  GOTO   0054
004E:  BTFSC  FF2.1
0050:  GOTO   0634
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   04D2
0060:  BTFSS  FF2.5
0062:  GOTO   006C
0066:  BTFSC  FF2.2
0068:  GOTO   059A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... // Projeto Monitor do Estado de Baterias - TAI  
.................... // Data: Setembro de 2018 
....................  
....................  
.................... //******************* InterrupÃ§Ã£o do Timer 0 / RTCC ************************** 
.................... //   
.................... //  Cristal externo = 16 MHz - Uso de PLL*4 -> Frequencia de trabalho = 16MHz  
.................... //  Prescaler = 1:16 
.................... //  Tout =(4*prescaler* (256-TMR0))/fclk   
.................... //  Para interrupção a cada 1 ms 
.................... //  TMR0 = 6  
.................... //  
.................... //**************************************************************************** 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00AE:  MOVFF  FF2,0D
00B2:  BCF    FF2.7
00B4:  CLRF   FF7
00B6:  ADDLW  C8
00B8:  MOVWF  FF6
00BA:  MOVLW  00
00BC:  ADDWFC FF7,F
00BE:  TBLRD*+
00C0:  MOVF   FF5,W
00C2:  BTFSC  0D.7
00C4:  BSF    FF2.7
00C6:  RETURN 0
00C8:  DATA 2B,43
00CA:  DATA 4D,54
00CC:  DATA 49,00
00CE:  MOVFF  FF2,0D
00D2:  BCF    FF2.7
00D4:  CLRF   FF7
00D6:  ADDLW  E8
00D8:  MOVWF  FF6
00DA:  MOVLW  00
00DC:  ADDWFC FF7,F
00DE:  TBLRD*+
00E0:  MOVF   FF5,W
00E2:  BTFSC  0D.7
00E4:  BSF    FF2.7
00E6:  RETURN 0
00E8:  DATA 2B,43
00EA:  DATA 4D,47
00EC:  DATA 4C,00
00EE:  MOVFF  FF2,0D
00F2:  BCF    FF2.7
00F4:  CLRF   FF7
00F6:  ADDLW  08
00F8:  MOVWF  FF6
00FA:  MOVLW  01
00FC:  ADDWFC FF7,F
00FE:  TBLRD*+
0100:  MOVF   FF5,W
0102:  BTFSC  0D.7
0104:  BSF    FF2.7
0106:  RETURN 0
0108:  DATA 4F,49
010A:  DATA 54,41
010C:  DATA 49,00
010E:  MOVFF  FF2,0D
0112:  BCF    FF2.7
0114:  CLRF   FF7
0116:  ADDLW  28
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  BTFSC  0D.7
0124:  BSF    FF2.7
0126:  RETURN 0
0128:  DATA 48,45
012A:  DATA 41,52
012C:  DATA 54,42
012E:  DATA 45,41
0130:  DATA 54,28
0132:  DATA 29,00
0134:  MOVFF  FF2,0D
0138:  BCF    FF2.7
013A:  CLRF   FF7
013C:  ADDLW  4E
013E:  MOVWF  FF6
0140:  MOVLW  01
0142:  ADDWFC FF7,F
0144:  TBLRD*+
0146:  MOVF   FF5,W
0148:  BTFSC  0D.7
014A:  BSF    FF2.7
014C:  RETURN 0
014E:  DATA 2B,4E
0150:  DATA 55,4D
0152:  DATA 41,44
0154:  DATA 44,00
0156:  MOVFF  FF2,0D
015A:  BCF    FF2.7
015C:  CLRF   FF7
015E:  ADDLW  70
0160:  MOVWF  FF6
0162:  MOVLW  01
0164:  ADDWFC FF7,F
0166:  TBLRD*+
0168:  MOVF   FF5,W
016A:  BTFSC  0D.7
016C:  BSF    FF2.7
016E:  RETURN 0
0170:  DATA 2B,4E
0172:  DATA 55,4D
0174:  DATA 44,45
0176:  DATA 4C,00
0178:  MOVFF  FF2,0D
017C:  BCF    FF2.7
017E:  CLRF   FF7
0180:  ADDLW  92
0182:  MOVWF  FF6
0184:  MOVLW  01
0186:  ADDWFC FF7,F
0188:  TBLRD*+
018A:  MOVF   FF5,W
018C:  BTFSC  0D.7
018E:  BSF    FF2.7
0190:  RETURN 0
0192:  DATA 4F,4B
0194:  DATA 20,43
0196:  DATA 4C,45
0198:  DATA 41,52
019A:  DATA 20,41
019C:  DATA 4C,4C
019E:  DATA 00,00
01A0:  MOVFF  FF2,0D
01A4:  BCF    FF2.7
01A6:  CLRF   FF7
01A8:  ADDLW  BA
01AA:  MOVWF  FF6
01AC:  MOVLW  01
01AE:  ADDWFC FF7,F
01B0:  TBLRD*+
01B2:  MOVF   FF5,W
01B4:  BTFSC  0D.7
01B6:  BSF    FF2.7
01B8:  RETURN 0
01BA:  DATA 2B,47
01BC:  DATA 53,4D
01BE:  DATA 4C,4F
01C0:  DATA 43,41
01C2:  DATA 54,45
01C4:  DATA 00,00
01C6:  MOVFF  FF2,0D
01CA:  BCF    FF2.7
01CC:  CLRF   FF7
01CE:  ADDLW  E0
01D0:  MOVWF  FF6
01D2:  MOVLW  01
01D4:  ADDWFC FF7,F
01D6:  TBLRD*+
01D8:  MOVF   FF5,W
01DA:  BTFSC  0D.7
01DC:  BSF    FF2.7
01DE:  RETURN 0
01E0:  DATA 41,54
01E2:  DATA 2B,43
01E4:  DATA 4D,47
01E6:  DATA 46,3D
01E8:  DATA 31,0D
01EA:  DATA 0A,00
01EC:  MOVFF  FF2,0D
01F0:  BCF    FF2.7
01F2:  CLRF   FF7
01F4:  ADDLW  06
01F6:  MOVWF  FF6
01F8:  MOVLW  02
01FA:  ADDWFC FF7,F
01FC:  TBLRD*+
01FE:  MOVF   FF5,W
0200:  BTFSC  0D.7
0202:  BSF    FF2.7
0204:  RETURN 0
0206:  DATA 41,54
0208:  DATA 2B,43
020A:  DATA 53,4D
020C:  DATA 50,3D
020E:  DATA 31,37
0210:  DATA 2C,32
0212:  DATA 35,35
0214:  DATA 2C,30
0216:  DATA 2C,30
0218:  DATA 0D,0A
021A:  DATA 00,00
021C:  MOVFF  FF2,0D
0220:  BCF    FF2.7
0222:  CLRF   FF7
0224:  ADDLW  36
0226:  MOVWF  FF6
0228:  MOVLW  02
022A:  ADDWFC FF7,F
022C:  TBLRD*+
022E:  MOVF   FF5,W
0230:  BTFSC  0D.7
0232:  BSF    FF2.7
0234:  RETURN 0
0236:  DATA 2B,43
0238:  DATA 4D,47
023A:  DATA 53,3A
023C:  DATA 00,00
023E:  MOVFF  FF2,0D
0242:  BCF    FF2.7
0244:  CLRF   FF7
0246:  ADDLW  58
0248:  MOVWF  FF6
024A:  MOVLW  02
024C:  ADDWFC FF7,F
024E:  TBLRD*+
0250:  MOVF   FF5,W
0252:  BTFSC  0D.7
0254:  BSF    FF2.7
0256:  RETURN 0
0258:  DATA 41,54
025A:  DATA 2B,43
025C:  DATA 4D,47
025E:  DATA 4C,3D
0260:  DATA 22,52
0262:  DATA 45,43
0264:  DATA 20,55
0266:  DATA 4E,52
0268:  DATA 45,41
026A:  DATA 44,22
026C:  DATA 0D,0A
026E:  DATA 00,00
0270:  MOVFF  FF2,0D
0274:  BCF    FF2.7
0276:  CLRF   FF7
0278:  ADDLW  8A
027A:  MOVWF  FF6
027C:  MOVLW  02
027E:  ADDWFC FF7,F
0280:  TBLRD*+
0282:  MOVF   FF5,W
0284:  BTFSC  0D.7
0286:  BSF    FF2.7
0288:  RETURN 0
028A:  DATA 41,54
028C:  DATA 2B,43
028E:  DATA 47,41
0290:  DATA 54,54
0292:  DATA 3D,31
0294:  DATA 0D,0A
0296:  DATA 00,00
0298:  MOVFF  FF2,0D
029C:  BCF    FF2.7
029E:  CLRF   FF7
02A0:  ADDLW  B2
02A2:  MOVWF  FF6
02A4:  MOVLW  02
02A6:  ADDWFC FF7,F
02A8:  TBLRD*+
02AA:  MOVF   FF5,W
02AC:  BTFSC  0D.7
02AE:  BSF    FF2.7
02B0:  RETURN 0
02B2:  DATA 41,54
02B4:  DATA 2B,53
02B6:  DATA 41,50
02B8:  DATA 42,52
02BA:  DATA 3D,33
02BC:  DATA 2C,31
02BE:  DATA 2C,22
02C0:  DATA 43,4F
02C2:  DATA 4E,54
02C4:  DATA 59,50
02C6:  DATA 45,22
02C8:  DATA 2C,22
02CA:  DATA 47,50
02CC:  DATA 52,53
02CE:  DATA 22,0D
02D0:  DATA 0A,00
02D2:  MOVFF  FF2,0D
02D6:  BCF    FF2.7
02D8:  CLRF   FF7
02DA:  ADDLW  EC
02DC:  MOVWF  FF6
02DE:  MOVLW  02
02E0:  ADDWFC FF7,F
02E2:  TBLRD*+
02E4:  MOVF   FF5,W
02E6:  BTFSC  0D.7
02E8:  BSF    FF2.7
02EA:  RETURN 0
02EC:  DATA 41,54
02EE:  DATA 2B,53
02F0:  DATA 41,50
02F2:  DATA 42,52
02F4:  DATA 3D,33
02F6:  DATA 2C,31
02F8:  DATA 2C,22
02FA:  DATA 41,50
02FC:  DATA 4E,22
02FE:  DATA 2C,22
0300:  DATA 43,4D
0302:  DATA 4E,45
0304:  DATA 54,22
0306:  DATA 0D,0A
0308:  DATA 00,00
030A:  MOVFF  FF2,0D
030E:  BCF    FF2.7
0310:  CLRF   FF7
0312:  ADDLW  24
0314:  MOVWF  FF6
0316:  MOVLW  03
0318:  ADDWFC FF7,F
031A:  TBLRD*+
031C:  MOVF   FF5,W
031E:  BTFSC  0D.7
0320:  BSF    FF2.7
0322:  RETURN 0
0324:  DATA 41,54
0326:  DATA 2B,53
0328:  DATA 41,50
032A:  DATA 42,52
032C:  DATA 3D,31
032E:  DATA 2C,31
0330:  DATA 0D,0A
0332:  DATA 00,00
0334:  MOVFF  FF2,0D
0338:  BCF    FF2.7
033A:  CLRF   FF7
033C:  ADDLW  4E
033E:  MOVWF  FF6
0340:  MOVLW  03
0342:  ADDWFC FF7,F
0344:  TBLRD*+
0346:  MOVF   FF5,W
0348:  BTFSC  0D.7
034A:  BSF    FF2.7
034C:  RETURN 0
034E:  DATA 41,54
0350:  DATA 2B,53
0352:  DATA 41,50
0354:  DATA 42,52
0356:  DATA 3D,32
0358:  DATA 2C,31
035A:  DATA 0D,0A
035C:  DATA 00,00
035E:  MOVFF  FF2,0D
0362:  BCF    FF2.7
0364:  CLRF   FF7
0366:  ADDLW  78
0368:  MOVWF  FF6
036A:  MOVLW  03
036C:  ADDWFC FF7,F
036E:  TBLRD*+
0370:  MOVF   FF5,W
0372:  BTFSC  0D.7
0374:  BSF    FF2.7
0376:  RETURN 0
0378:  DATA 2B,53
037A:  DATA 41,50
037C:  DATA 42,52
037E:  DATA 3A,00
0380:  MOVFF  FF2,0D
0384:  BCF    FF2.7
0386:  CLRF   FF7
0388:  ADDLW  9A
038A:  MOVWF  FF6
038C:  MOVLW  03
038E:  ADDWFC FF7,F
0390:  TBLRD*+
0392:  MOVF   FF5,W
0394:  BTFSC  0D.7
0396:  BSF    FF2.7
0398:  RETURN 0
039A:  DATA 41,54
039C:  DATA 2B,43
039E:  DATA 4C,42
03A0:  DATA 53,43
03A2:  DATA 46,47
03A4:  DATA 3D,30
03A6:  DATA 2C,31
03A8:  DATA 0D,0A
03AA:  DATA 00,00
03AC:  MOVFF  FF2,0D
03B0:  BCF    FF2.7
03B2:  CLRF   FF7
03B4:  ADDLW  C6
03B6:  MOVWF  FF6
03B8:  MOVLW  03
03BA:  ADDWFC FF7,F
03BC:  TBLRD*+
03BE:  MOVF   FF5,W
03C0:  BTFSC  0D.7
03C2:  BSF    FF2.7
03C4:  RETURN 0
03C6:  DATA 2B,43
03C8:  DATA 4C,42
03CA:  DATA 53,43
03CC:  DATA 46,47
03CE:  DATA 3A,00
03D0:  MOVFF  FF2,0D
03D4:  BCF    FF2.7
03D6:  CLRF   FF7
03D8:  ADDLW  EA
03DA:  MOVWF  FF6
03DC:  MOVLW  03
03DE:  ADDWFC FF7,F
03E0:  TBLRD*+
03E2:  MOVF   FF5,W
03E4:  BTFSC  0D.7
03E6:  BSF    FF2.7
03E8:  RETURN 0
03EA:  DATA 41,54
03EC:  DATA 2B,43
03EE:  DATA 4C,42
03F0:  DATA 53,3D
03F2:  DATA 31,2C
03F4:  DATA 31,0D
03F6:  DATA 0A,00
03F8:  MOVFF  FF2,0D
03FC:  BCF    FF2.7
03FE:  CLRF   FF7
0400:  ADDLW  12
0402:  MOVWF  FF6
0404:  MOVLW  04
0406:  ADDWFC FF7,F
0408:  TBLRD*+
040A:  MOVF   FF5,W
040C:  BTFSC  0D.7
040E:  BSF    FF2.7
0410:  RETURN 0
0412:  DATA 2B,43
0414:  DATA 4C,42
0416:  DATA 53,3A
0418:  DATA 00,00
041A:  MOVFF  FF2,0D
041E:  BCF    FF2.7
0420:  CLRF   FF7
0422:  ADDLW  34
0424:  MOVWF  FF6
0426:  MOVLW  04
0428:  ADDWFC FF7,F
042A:  TBLRD*+
042C:  MOVF   FF5,W
042E:  BTFSC  0D.7
0430:  BSF    FF2.7
0432:  RETURN 0
0434:  DATA 41,54
0436:  DATA 2B,53
0438:  DATA 41,50
043A:  DATA 42,52
043C:  DATA 3D,30
043E:  DATA 2C,31
0440:  DATA 0D,0A
0442:  DATA 00,00
0444:  MOVFF  FF2,0D
0448:  BCF    FF2.7
044A:  CLRF   FF7
044C:  ADDLW  5E
044E:  MOVWF  FF6
0450:  MOVLW  04
0452:  ADDWFC FF7,F
0454:  TBLRD*+
0456:  MOVF   FF5,W
0458:  BTFSC  0D.7
045A:  BSF    FF2.7
045C:  RETURN 0
045E:  DATA 30,33
0460:  DATA 31,39
0462:  DATA 39,35
0464:  DATA 38,32
0466:  DATA 32,37
0468:  DATA 33,39
046A:  DATA 00,00
046C:  MOVFF  FF2,0D
0470:  BCF    FF2.7
0472:  CLRF   FF7
0474:  ADDLW  86
0476:  MOVWF  FF6
0478:  MOVLW  04
047A:  ADDWFC FF7,F
047C:  TBLRD*+
047E:  MOVF   FF5,W
0480:  BTFSC  0D.7
0482:  BSF    FF2.7
0484:  RETURN 0
0486:  DATA 49,4E
0488:  DATA 49,43
048A:  DATA 49,41
048C:  DATA 4E,44
048E:  DATA 4F,2E
0490:  DATA 2E,2E
0492:  DATA 00,00
0494:  MOVFF  FF2,0D
0498:  BCF    FF2.7
049A:  CLRF   FF7
049C:  ADDLW  AE
049E:  MOVWF  FF6
04A0:  MOVLW  04
04A2:  ADDWFC FF7,F
04A4:  TBLRD*+
04A6:  MOVF   FF5,W
04A8:  BTFSC  0D.7
04AA:  BSF    FF2.7
04AC:  RETURN 0
04AE:  DATA 41,54
04B0:  DATA 2B,43
04B2:  DATA 4D,47
04B4:  DATA 44,3D
04B6:  DATA 31,2C
04B8:  DATA 31,0D
04BA:  DATA 0A,00
*
058A:  DATA 41,54
058C:  DATA 2B,43
058E:  DATA 4D,47
0590:  DATA 53,3D
0592:  DATA 22,25
0594:  DATA 73,22
0596:  DATA 0D,0A
0598:  DATA 00,00
*
0684:  MOVFF  1B0,FEA
0688:  MOVFF  1AF,FE9
068C:  MOVLB  5
068E:  MOVFF  545,FEF
0692:  INCF   FE9,F
0694:  BTFSC  FD8.2
0696:  INCF   FEA,F
0698:  CLRF   FEF
069A:  MOVLB  1
069C:  INCF   xAF,F
069E:  BTFSC  FD8.2
06A0:  INCF   xB0,F
06A2:  MOVLB  0
06A4:  RETURN 0
06A6:  TBLRD*+
06A8:  MOVFF  FF6,543
06AC:  MOVFF  FF7,544
06B0:  MOVFF  FF5,545
06B4:  RCALL  0684
06B6:  MOVFF  543,FF6
06BA:  MOVFF  544,FF7
06BE:  MOVLB  5
06C0:  DECFSZ x42,F
06C2:  BRA    06C6
06C4:  BRA    06CA
06C6:  MOVLB  0
06C8:  BRA    06A6
06CA:  MOVLB  0
06CC:  RETURN 0
06CE:  MOVF   FEF,F
06D0:  BZ    06F0
06D2:  MOVFF  FEA,543
06D6:  MOVFF  FE9,542
06DA:  MOVFF  FEF,545
06DE:  RCALL  0684
06E0:  MOVFF  543,FEA
06E4:  MOVFF  542,FE9
06E8:  INCF   FE9,F
06EA:  BTFSC  FD8.2
06EC:  INCF   FEA,F
06EE:  BRA    06CE
06F0:  GOTO   08CA (RETURN)
06F4:  MOVF   FEF,F
06F6:  BZ    0718
06F8:  MOVFF  FEA,552
06FC:  MOVFF  FE9,551
0700:  MOVF   FEF,W
0702:  BTFSS  F9E.4
0704:  BRA    0702
0706:  MOVWF  FAD
0708:  MOVFF  552,FEA
070C:  MOVFF  551,FE9
0710:  INCF   FE9,F
0712:  BTFSC  FD8.2
0714:  INCF   FEA,F
0716:  BRA    06F4
0718:  GOTO   07E0 (RETURN)
*
0CB0:  TSTFSZ 01
0CB2:  BRA    0CBA
0CB4:  TSTFSZ 02
0CB6:  BRA    0CBC
0CB8:  BRA    0CC8
0CBA:  INCF   02,F
0CBC:  MOVFF  00,FEE
0CC0:  DECFSZ 01,F
0CC2:  BRA    0CBC
0CC4:  DECFSZ 02,F
0CC6:  BRA    0CBC
0CC8:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,NOPROTECT,NOLVP,MCLR,HSPLL,PLL4 
.................... #device PASS_STRINGS=IN_RAM,adc=10 
.................... #use delay(clock=16000000) 
*
065A:  MOVLW  05
065C:  MOVWF  FEA
065E:  MOVLW  51
0660:  MOVWF  FE9
0662:  MOVF   FEF,W
0664:  BZ    0682
0666:  MOVLW  05
0668:  MOVWF  01
066A:  CLRF   00
066C:  DECFSZ 00,F
066E:  BRA    066C
0670:  DECFSZ 01,F
0672:  BRA    066A
0674:  MOVLW  2E
0676:  MOVWF  00
0678:  DECFSZ 00,F
067A:  BRA    0678
067C:  BRA    067E
067E:  DECFSZ FEF,F
0680:  BRA    0666
0682:  RETURN 0
.................... #use rs232(uart1,baud=115200, xmit=PIN_C6, rcv=PIN_C7, stream = SIM800L_SERIAL, ERRORS) 
*
04BC:  BTFSS  F9E.5
04BE:  BRA    04BC
04C0:  MOVFF  FAB,16
04C4:  MOVFF  FAE,01
04C8:  BTFSS  16.1
04CA:  BRA    04D0
04CC:  BCF    FAB.4
04CE:  BSF    FAB.4
04D0:  RETURN 0
*
07AA:  BTFSS  F9E.4
07AC:  BRA    07AA
07AE:  MOVWF  FAD
07B0:  GOTO   082A (RETURN)
.................... #use rs232(baud=9600, xmit=PIN_B2, rcv=PIN_B3, stream = MONITOR_SERIAL) 
.................... #use fast_io (ALL) 
.................... #priority ext,rda, rtcc, 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
071C:  MOVFF  554,03
0720:  MOVLB  5
0722:  MOVFF  553,FE9
0726:  MOVFF  554,FEA
072A:  MOVF   FEF,F
072C:  BZ    07A0
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
072E:  MOVFF  554,558
0732:  MOVFF  553,557
0736:  MOVFF  556,55A
073A:  MOVFF  555,559
073E:  MOVFF  55A,03
0742:  MOVFF  559,FE9
0746:  MOVFF  55A,FEA
074A:  MOVF   FEF,F
074C:  BZ    077A
074E:  MOVFF  557,FE9
0752:  MOVFF  558,FEA
0756:  MOVFF  FEF,55B
075A:  MOVFF  55A,03
075E:  MOVFF  559,FE9
0762:  MOVFF  55A,FEA
0766:  MOVF   FEF,W
0768:  SUBWF  x5B,W
076A:  BNZ   077A
076C:  INCF   x57,F
076E:  BTFSC  FD8.2
0770:  INCF   x58,F
0772:  INCF   x59,F
0774:  BTFSC  FD8.2
0776:  INCF   x5A,F
0778:  BRA    073E
....................  
....................       if (*t == '\0') 
077A:  MOVFF  55A,03
077E:  MOVFF  559,FE9
0782:  MOVFF  03,FEA
0786:  MOVF   FEF,F
0788:  BNZ   0794
....................          return s1; 
078A:  MOVFF  553,01
078E:  MOVFF  554,02
0792:  BRA    07A6
....................       ++s1; 
0794:  INCF   x53,F
0796:  BTFSC  FD8.2
0798:  INCF   x54,F
....................       #ifdef FASTER_BUT_MORE_ROM 
079A:  MOVLB  0
079C:  BRA    071C
079E:  MOVLB  5
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
07A0:  MOVLW  00
07A2:  MOVWF  01
07A4:  MOVWF  02
07A6:  MOVLB  0
07A8:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Protótipo de Funções 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... void Obtem_SOH(); 
....................  
.................... #ENDIF 
....................  
.................... #include "SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
.................... #include"Serial.h" 
.................... #IFNDEF SERIAL_H 
.................... #DEFINE SERIAL_H 
....................  
.................... #define  SMS_COMMAND             1 
.................... #define  SMS_READ_COMMAND        2            
....................  
.................... void Executa_Comando(char comando); 
.................... char Get_Comando(); 
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao); 
.................... void get_numero(int nro_caracteres, int posicao, char *destino); 
.................... void clear_command(); 
....................  
.................... #include"Serial.c" 
.................... #include"SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
.................... int1 Get_Locate(char *numero); 
.................... void Get_Coordenadas(); 
....................  
.................... #include "SIM800L.c" 
....................  
.................... #ENDIF 
....................  
.................... #include"TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Protótipo de Funções 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
.................... void Obtem_SOH(); 
....................  
.................... #ENDIF 
....................  
.................... #include"numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
....................  
.................... #include"numeros.c" 
.................... char numeros[50]; 
.................... int8 qtd_numeros=0; 
.................... char *posicao_numero; 
....................  
.................... int1 insere_numero(char *numero){ // >+5531995822739>+5531995822739>+5531995822739 
*
0BF0:  MOVF   4F,W
0BF2:  MULLW  0F
0BF4:  MOVFF  FF3,4E0
0BF8:  MOVLB  4
0BFA:  CLRF   xE1
....................   
....................   int8 index = qtd_numeros*15; 
....................   int8 index_2 = 0; 
....................  
....................   if(qtd_numeros == 3){ 
0BFC:  MOVF   4F,W
0BFE:  SUBLW  03
0C00:  BNZ   0C08
....................  
....................     return 0; 
0C02:  MOVLW  00
0C04:  MOVWF  01
0C06:  BRA    0CAA
....................  
....................   } 
....................  
....................   posicao_numero = strstr(numeros,numero); 
0C08:  MOVLB  5
0C0A:  CLRF   x54
0C0C:  MOVLW  1D
0C0E:  MOVWF  x53
0C10:  MOVFF  4DF,556
0C14:  MOVFF  4DE,555
0C18:  MOVLB  0
0C1A:  RCALL  071C
0C1C:  MOVFF  02,51
0C20:  MOVFF  01,50
....................    
....................   if(posicao_numero == 0){ 
0C24:  MOVF   50,F
0C26:  BNZ   0CA4
0C28:  MOVF   51,F
0C2A:  BNZ   0CA4
....................  
....................     numeros[index] ='>'; 
0C2C:  CLRF   03
0C2E:  MOVLB  4
0C30:  MOVF   xE0,W
0C32:  ADDLW  1D
0C34:  MOVWF  FE9
0C36:  MOVLW  00
0C38:  ADDWFC 03,W
0C3A:  MOVWF  FEA
0C3C:  MOVLW  3E
0C3E:  MOVWF  FEF
....................      
....................     for(index = index+1;numero[index_2]!='\0';index++){ 
0C40:  MOVLW  01
0C42:  ADDWF  xE0,F
0C44:  CLRF   03
0C46:  MOVF   xE1,W
0C48:  ADDWF  xDE,W
0C4A:  MOVWF  FE9
0C4C:  MOVF   xDF,W
0C4E:  ADDWFC 03,W
0C50:  MOVWF  FEA
0C52:  MOVF   FEF,F
0C54:  BZ    0C8A
....................       
....................       numeros[index] = numero[index_2]; 
0C56:  CLRF   03
0C58:  MOVF   xE0,W
0C5A:  ADDLW  1D
0C5C:  MOVWF  01
0C5E:  MOVLW  00
0C60:  ADDWFC 03,F
0C62:  MOVFF  03,4E3
0C66:  CLRF   03
0C68:  MOVF   xE1,W
0C6A:  ADDWF  xDE,W
0C6C:  MOVWF  FE9
0C6E:  MOVF   xDF,W
0C70:  ADDWFC 03,W
0C72:  MOVWF  FEA
0C74:  MOVFF  FEF,4E4
0C78:  MOVFF  4E3,FEA
0C7C:  MOVFF  01,FE9
0C80:  MOVFF  4E4,FEF
....................       index_2++; 
0C84:  INCF   xE1,F
0C86:  INCF   xE0,F
0C88:  BRA    0C44
....................         
....................     } 
....................     numeros[index]='\0'; 
0C8A:  CLRF   03
0C8C:  MOVF   xE0,W
0C8E:  ADDLW  1D
0C90:  MOVWF  FE9
0C92:  MOVLW  00
0C94:  ADDWFC 03,W
0C96:  MOVWF  FEA
0C98:  CLRF   FEF
....................     qtd_numeros++; 
0C9A:  INCF   4F,F
....................     return 1; 
0C9C:  MOVLW  01
0C9E:  MOVWF  01
0CA0:  BRA    0CAA
0CA2:  MOVLB  0
....................    
....................   } 
....................   return 0; 
0CA4:  MOVLW  00
0CA6:  MOVWF  01
0CA8:  MOVLB  4
0CAA:  MOVLB  0
0CAC:  GOTO   1348 (RETURN)
.................... } 
....................  
....................  
.................... void limpa_numeros(){ 
....................  
....................   qtd_numeros = 0; 
*
0CCA:  CLRF   4F
....................   memset (numeros, 0x00, sizeof(numeros)); 
0CCC:  CLRF   FEA
0CCE:  MOVLW  1D
0CD0:  MOVWF  FE9
0CD2:  CLRF   00
0CD4:  CLRF   02
0CD6:  MOVLW  32
0CD8:  MOVWF  01
0CDA:  RCALL  0CB0
0CDC:  GOTO   13CC (RETURN)
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define   UART_BUFFER_SIZE         150 
....................  
.................... char comando_recibido_UART[UART_BUFFER_SIZE]; 
.................... char comando_recibido_BUFF [UART_BUFFER_SIZE]; 
.................... int *posicao_valor_comando = 0; 
.................... int16 timeout_trama_UART = 100000; 
.................... extern int1 comando_disponivel_UART; 
....................  
.................... #INT_RDA  
.................... void recepcao_UART() 
*
04D2:  MOVLW  01
04D4:  MOVLB  5
04D6:  MOVWF  x5C
.................... { 
....................  int i = 1; 
....................  int8 caracterRx; 
....................    if(kbhit(SIM800L_SERIAL) && comando_disponivel_UART == 0) { 
04D8:  BTFSS  F9E.5
04DA:  BRA    0582
04DC:  MOVLB  1
04DE:  BTFSS  x82.0
04E0:  BRA    04E6
04E2:  MOVLB  5
04E4:  BRA    0582
....................       caracterRx = getc(SIM800L_SERIAL); 
04E6:  MOVLB  0
04E8:  RCALL  04BC
04EA:  MOVFF  01,55D
....................       if(caracterRx == '>'||caracterRx == '+' ||caracterRx =='\n'||caracterRx =='\r') { 
04EE:  MOVLB  5
04F0:  MOVF   x5D,W
04F2:  SUBLW  3E
04F4:  BZ    0508
04F6:  MOVF   x5D,W
04F8:  SUBLW  2B
04FA:  BZ    0508
04FC:  MOVF   x5D,W
04FE:  SUBLW  0A
0500:  BZ    0508
0502:  MOVF   x5D,W
0504:  SUBLW  0D
0506:  BNZ   0582
....................         comando_recibido_UART[0] = caracterRx; 
0508:  MOVFF  55D,52
....................         while(i < (UART_BUFFER_SIZE-2) && timeout_trama_UART > 0) { 
050C:  MOVF   x5C,W
050E:  SUBLW  93
0510:  BNC   0564
0512:  MOVLB  1
0514:  MOVF   x80,F
0516:  BNZ   0522
0518:  MOVF   x81,F
051A:  BTFSS  FD8.2
051C:  BRA    0522
051E:  MOVLB  5
0520:  BRA    0564
....................            if(kbhit(SIM800L_SERIAL)) { 
0522:  BTFSS  F9E.5
0524:  BRA    0558
....................              caracterRx = getc(SIM800L_SERIAL); 
0526:  MOVLB  0
0528:  RCALL  04BC
052A:  MOVFF  01,55D
....................              comando_recibido_UART[i] = caracterRx; 
052E:  CLRF   03
0530:  MOVLB  5
0532:  MOVF   x5C,W
0534:  ADDLW  52
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  55D,FEF
....................              if(caracterRx == ';') {  
0542:  MOVF   x5D,W
0544:  SUBLW  3B
0546:  BNZ   054C
....................                i++; 
0548:  INCF   x5C,F
....................                break; 
054A:  BRA    0564
....................              } 
....................              i++; 
054C:  INCF   x5C,F
....................              timeout_trama_UART = 100000; 
054E:  MOVLW  86
0550:  MOVLB  1
0552:  MOVWF  x81
0554:  MOVLW  A0
0556:  MOVWF  x80
....................            } 
....................            timeout_trama_UART--; 
0558:  MOVF   x80,W
055A:  BTFSC  FD8.2
055C:  DECF   x81,F
055E:  DECF   x80,F
0560:  MOVLB  5
0562:  BRA    050C
....................         } 
....................         comando_disponivel_UART = 1; 
0564:  MOVLB  1
0566:  BSF    x82.0
....................         timeout_trama_UART = 100000; 
0568:  MOVLW  86
056A:  MOVWF  x81
056C:  MOVLW  A0
056E:  MOVWF  x80
....................         comando_recibido_UART[i] = 0; 
0570:  CLRF   03
0572:  MOVLB  5
0574:  MOVF   x5C,W
0576:  ADDLW  52
0578:  MOVWF  FE9
057A:  MOVLW  00
057C:  ADDWFC 03,W
057E:  MOVWF  FEA
0580:  CLRF   FEF
....................       } 
....................    } 
....................   return; 
0582:  BCF    F9E.5
0584:  MOVLB  0
0586:  GOTO   006C
.................... } 
....................  
.................... char Get_Comando() 
.................... { 
....................   char CMD[15]; 
....................   strcpy (comando_recibido_BUFF, comando_recibido_UART);                            
*
0A2A:  CLRF   FEA
0A2C:  MOVLW  E8
0A2E:  MOVWF  FE9
0A30:  CLRF   FE2
0A32:  MOVLW  52
0A34:  MOVWF  FE1
0A36:  MOVF   FE7,F
0A38:  MOVFF  FE6,FEE
0A3C:  BNZ   0A36
....................   strcpy (CMD, "+CMTI"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_COMMAND); 
0A3E:  MOVLW  04
0A40:  MOVWF  FEA
0A42:  MOVLW  A1
0A44:  MOVWF  FE9
0A46:  MOVFF  FF2,4B0
0A4A:  BCF    FF2.7
0A4C:  MOVLW  00
0A4E:  CALL   00AE
0A52:  TBLRD*-
0A54:  TBLRD*+
0A56:  MOVF   FF5,W
0A58:  MOVWF  FEE
0A5A:  IORLW  00
0A5C:  BNZ   0A54
0A5E:  MOVLB  4
0A60:  BTFSC  xB0.7
0A62:  BSF    FF2.7
0A64:  MOVLB  5
0A66:  CLRF   x54
0A68:  MOVLW  E8
0A6A:  MOVWF  x53
0A6C:  MOVLW  04
0A6E:  MOVWF  x56
0A70:  MOVLW  A1
0A72:  MOVWF  x55
0A74:  MOVLB  0
0A76:  RCALL  071C
0A78:  MOVFF  02,17F
0A7C:  MOVFF  01,17E
0A80:  MOVLB  1
0A82:  MOVF   x7E,F
0A84:  BNZ   0A8A
0A86:  MOVF   x7F,F
0A88:  BZ    0A90
0A8A:  MOVLW  01
0A8C:  MOVWF  01
0A8E:  BRA    0AE8
....................   strcpy (CMD, "+CMGL"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_READ_COMMAND); 
0A90:  MOVLW  04
0A92:  MOVWF  FEA
0A94:  MOVLW  A1
0A96:  MOVWF  FE9
0A98:  MOVFF  FF2,4B0
0A9C:  BCF    FF2.7
0A9E:  MOVLW  00
0AA0:  MOVLB  0
0AA2:  CALL   00CE
0AA6:  TBLRD*-
0AA8:  TBLRD*+
0AAA:  MOVF   FF5,W
0AAC:  MOVWF  FEE
0AAE:  IORLW  00
0AB0:  BNZ   0AA8
0AB2:  MOVLB  4
0AB4:  BTFSC  xB0.7
0AB6:  BSF    FF2.7
0AB8:  MOVLB  5
0ABA:  CLRF   x54
0ABC:  MOVLW  E8
0ABE:  MOVWF  x53
0AC0:  MOVLW  04
0AC2:  MOVWF  x56
0AC4:  MOVLW  A1
0AC6:  MOVWF  x55
0AC8:  MOVLB  0
0ACA:  RCALL  071C
0ACC:  MOVFF  02,17F
0AD0:  MOVFF  01,17E
0AD4:  MOVLB  1
0AD6:  MOVF   x7E,F
0AD8:  BNZ   0ADE
0ADA:  MOVF   x7F,F
0ADC:  BZ    0AE4
0ADE:  MOVLW  02
0AE0:  MOVWF  01
0AE2:  BRA    0AE8
....................  
....................   return(0); 
0AE4:  MOVLW  00
0AE6:  MOVWF  01
0AE8:  MOVLB  0
0AEA:  RETURN 0
.................... } 
....................  
....................  
.................... void Executa_Comando(char comando){ 
....................  
....................   char CMD[15]; 
....................   char numero[20]; 
....................   disable_interrupts(GLOBAL); 
*
120C:  BCF    FF2.6
120E:  BCF    FF2.7
1210:  BTFSC  FF2.7
1212:  BRA    120E
....................    
....................   switch(comando){ 
1214:  MOVLB  4
1216:  MOVF   xA1,W
1218:  XORLW  01
121A:  MOVLB  0
121C:  BZ    1224
121E:  XORLW  03
1220:  BZ    1228
1222:  BRA    14A8
....................       
....................     case SMS_COMMAND:       //+CMTI: "SM",10<CR><LF> 
....................       Read_SMS(); 
1224:  BRA    0AEC
....................     break; 
1226:  BRA    14A8
....................  
....................     case SMS_READ_COMMAND:  //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/13,21:57:54-12"<CR><LF> 
....................  
....................       strcpy (CMD, "OITAI");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); 
1228:  MOVLW  04
122A:  MOVWF  FEA
122C:  MOVLW  A2
122E:  MOVWF  FE9
1230:  MOVFF  FF2,4DE
1234:  BCF    FF2.7
1236:  MOVLW  00
1238:  CALL   00EE
123C:  TBLRD*-
123E:  TBLRD*+
1240:  MOVF   FF5,W
1242:  MOVWF  FEE
1244:  IORLW  00
1246:  BNZ   123E
1248:  MOVLB  4
124A:  BTFSC  xDE.7
124C:  BSF    FF2.7
124E:  MOVLB  5
1250:  CLRF   x54
1252:  MOVLW  E8
1254:  MOVWF  x53
1256:  MOVLW  04
1258:  MOVWF  x56
125A:  MOVLW  A2
125C:  MOVWF  x55
125E:  MOVLB  0
1260:  CALL   071C
1264:  MOVFF  02,17F
1268:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
126C:  MOVLB  1
126E:  MOVF   x7E,F
1270:  BNZ   1276
1272:  MOVF   x7F,F
1274:  BZ    12D4
....................  
....................         get_numero(14,25,numero); 
1276:  MOVLW  0E
1278:  MOVLB  4
127A:  MOVWF  xDE
127C:  MOVLW  19
127E:  MOVWF  xDF
1280:  MOVLW  04
1282:  MOVWF  xE1
1284:  MOVLW  B1
1286:  MOVWF  xE0
1288:  MOVLB  0
128A:  RCALL  0B9C
....................         Send_SMS(numero,"HEARTBEAT()"); 
128C:  MOVLW  04
128E:  MOVWF  FEA
1290:  MOVLW  C5
1292:  MOVWF  FE9
1294:  MOVFF  FF2,4DE
1298:  BCF    FF2.7
129A:  MOVLW  0C
129C:  MOVWF  01
129E:  CLRF   FF7
12A0:  MOVLW  00
12A2:  CALL   010E
12A6:  TBLRD*-
12A8:  TBLRD*+
12AA:  MOVFF  FF5,FEE
12AE:  DECFSZ 01,F
12B0:  BRA    12A8
12B2:  MOVLB  4
12B4:  BTFSC  xDE.7
12B6:  BSF    FF2.7
12B8:  MOVLW  04
12BA:  MOVLB  5
12BC:  MOVWF  x04
12BE:  MOVLW  B1
12C0:  MOVWF  x03
12C2:  MOVLW  04
12C4:  MOVWF  x06
12C6:  MOVLW  C5
12C8:  MOVWF  x05
12CA:  MOVLB  0
12CC:  CALL   08A4
....................         break; 
12D0:  BRA    14A8
12D2:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMADD");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/14,00:28:46-12"nr+NUMADD+5531995422738<CR><LF> 
12D4:  MOVLW  04
12D6:  MOVWF  FEA
12D8:  MOVLW  A2
12DA:  MOVWF  FE9
12DC:  MOVFF  FF2,4DE
12E0:  BCF    FF2.7
12E2:  MOVLW  00
12E4:  MOVLB  0
12E6:  CALL   0134
12EA:  TBLRD*-
12EC:  TBLRD*+
12EE:  MOVF   FF5,W
12F0:  MOVWF  FEE
12F2:  IORLW  00
12F4:  BNZ   12EC
12F6:  MOVLB  4
12F8:  BTFSC  xDE.7
12FA:  BSF    FF2.7
12FC:  MOVLB  5
12FE:  CLRF   x54
1300:  MOVLW  E8
1302:  MOVWF  x53
1304:  MOVLW  04
1306:  MOVWF  x56
1308:  MOVLW  A2
130A:  MOVWF  x55
130C:  MOVLB  0
130E:  CALL   071C
1312:  MOVFF  02,17F
1316:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
131A:  MOVLB  1
131C:  MOVF   x7E,F
131E:  BNZ   1324
1320:  MOVF   x7F,F
1322:  BZ    1378
....................          
....................         get_numero(14,75,numero); 
1324:  MOVLW  0E
1326:  MOVLB  4
1328:  MOVWF  xDE
132A:  MOVLW  4B
132C:  MOVWF  xDF
132E:  MOVLW  04
1330:  MOVWF  xE1
1332:  MOVLW  B1
1334:  MOVWF  xE0
1336:  MOVLB  0
1338:  RCALL  0B9C
....................         insere_numero(numero); 
133A:  MOVLW  04
133C:  MOVLB  4
133E:  MOVWF  xDF
1340:  MOVLW  B1
1342:  MOVWF  xDE
1344:  MOVLB  0
1346:  BRA    0BF0
....................         get_numero(14,25,numero); 
1348:  MOVLW  0E
134A:  MOVLB  4
134C:  MOVWF  xDE
134E:  MOVLW  19
1350:  MOVWF  xDF
1352:  MOVLW  04
1354:  MOVWF  xE1
1356:  MOVLW  B1
1358:  MOVWF  xE0
135A:  MOVLB  0
135C:  RCALL  0B9C
....................         Send_SMS(numero,numeros); 
135E:  MOVLW  04
1360:  MOVLB  5
1362:  MOVWF  x04
1364:  MOVLW  B1
1366:  MOVWF  x03
1368:  CLRF   x06
136A:  MOVLW  1D
136C:  MOVWF  x05
136E:  MOVLB  0
1370:  CALL   08A4
....................         break; 
1374:  BRA    14A8
1376:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMDEL");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+NUMDEL 
1378:  MOVLW  04
137A:  MOVWF  FEA
137C:  MOVLW  A2
137E:  MOVWF  FE9
1380:  MOVFF  FF2,4DE
1384:  BCF    FF2.7
1386:  MOVLW  00
1388:  MOVLB  0
138A:  CALL   0156
138E:  TBLRD*-
1390:  TBLRD*+
1392:  MOVF   FF5,W
1394:  MOVWF  FEE
1396:  IORLW  00
1398:  BNZ   1390
139A:  MOVLB  4
139C:  BTFSC  xDE.7
139E:  BSF    FF2.7
13A0:  MOVLB  5
13A2:  CLRF   x54
13A4:  MOVLW  E8
13A6:  MOVWF  x53
13A8:  MOVLW  04
13AA:  MOVWF  x56
13AC:  MOVLW  A2
13AE:  MOVWF  x55
13B0:  MOVLB  0
13B2:  CALL   071C
13B6:  MOVFF  02,17F
13BA:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
13BE:  MOVLB  1
13C0:  MOVF   x7E,F
13C2:  BNZ   13C8
13C4:  MOVF   x7F,F
13C6:  BZ    142C
....................           
....................         limpa_numeros();  
13C8:  MOVLB  0
13CA:  BRA    0CCA
....................         get_numero(14,25,numero); 
13CC:  MOVLW  0E
13CE:  MOVLB  4
13D0:  MOVWF  xDE
13D2:  MOVLW  19
13D4:  MOVWF  xDF
13D6:  MOVLW  04
13D8:  MOVWF  xE1
13DA:  MOVLW  B1
13DC:  MOVWF  xE0
13DE:  MOVLB  0
13E0:  CALL   0B9C
....................         Send_SMS(numero,"OK CLEAR ALL"); 
13E4:  MOVLW  04
13E6:  MOVWF  FEA
13E8:  MOVLW  D1
13EA:  MOVWF  FE9
13EC:  MOVFF  FF2,4DE
13F0:  BCF    FF2.7
13F2:  MOVLW  0D
13F4:  MOVWF  01
13F6:  CLRF   FF7
13F8:  MOVLW  00
13FA:  CALL   0178
13FE:  TBLRD*-
1400:  TBLRD*+
1402:  MOVFF  FF5,FEE
1406:  DECFSZ 01,F
1408:  BRA    1400
140A:  MOVLB  4
140C:  BTFSC  xDE.7
140E:  BSF    FF2.7
1410:  MOVLW  04
1412:  MOVLB  5
1414:  MOVWF  x04
1416:  MOVLW  B1
1418:  MOVWF  x03
141A:  MOVLW  04
141C:  MOVWF  x06
141E:  MOVLW  D1
1420:  MOVWF  x05
1422:  MOVLB  0
1424:  CALL   08A4
....................         break; 
1428:  BRA    14A8
142A:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+GSMLOCATE");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+GSMLOCATE 
142C:  MOVLW  04
142E:  MOVWF  FEA
1430:  MOVLW  A2
1432:  MOVWF  FE9
1434:  MOVFF  FF2,4DE
1438:  BCF    FF2.7
143A:  MOVLW  00
143C:  MOVLB  0
143E:  CALL   01A0
1442:  TBLRD*-
1444:  TBLRD*+
1446:  MOVF   FF5,W
1448:  MOVWF  FEE
144A:  IORLW  00
144C:  BNZ   1444
144E:  MOVLB  4
1450:  BTFSC  xDE.7
1452:  BSF    FF2.7
1454:  MOVLB  5
1456:  CLRF   x54
1458:  MOVLW  E8
145A:  MOVWF  x53
145C:  MOVLW  04
145E:  MOVWF  x56
1460:  MOVLW  A2
1462:  MOVWF  x55
1464:  MOVLB  0
1466:  CALL   071C
146A:  MOVFF  02,17F
146E:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
1472:  MOVLB  1
1474:  MOVF   x7E,F
1476:  BNZ   147C
1478:  MOVF   x7F,F
147A:  BZ    14A6
....................           
....................         get_numero(14,25,numero);  
147C:  MOVLW  0E
147E:  MOVLB  4
1480:  MOVWF  xDE
1482:  MOVLW  19
1484:  MOVWF  xDF
1486:  MOVLW  04
1488:  MOVWF  xE1
148A:  MOVLW  B1
148C:  MOVWF  xE0
148E:  MOVLB  0
1490:  CALL   0B9C
....................         Get_Locate(numero);  
1494:  MOVLW  04
1496:  MOVLB  4
1498:  MOVWF  xDF
149A:  MOVLW  B1
149C:  MOVWF  xDE
149E:  MOVLB  0
14A0:  BRA    0E42
....................         break; 
14A2:  BRA    14A8
14A4:  MOVLB  1
....................       } 
....................           
....................     break; 
14A6:  MOVLB  0
....................  
....................  
....................   } 
....................  
....................   return; 
14A8:  RETURN 0
....................  
.................... } 
....................  
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao) //get_value(posicao_valor_comando,3,6); 
.................... { 
....................   int32 valor = 0; 
....................   int i = 0; 
....................   int32 aux = 1; 
....................   int potencia = 0; 
....................  
....................   while(nro_caracteres > 0) 
....................   { 
....................     if( pointer_to_string[posicao+i] != '.' ) 
....................     { 
....................       nro_caracteres--; 
....................       potencia = nro_caracteres; 
....................       aux = 1; 
....................       while(potencia > 0) 
....................       { 
....................         aux = aux * 10; 
....................         potencia--; 
....................       } 
....................       valor = valor + ((int32)(pointer_to_string[posicao+i]-48)*aux); 
....................     } 
....................     i++; 
....................   } 
....................  
....................   return(valor); 
.................... } 
....................  
.................... void get_numero(int nro_caracteres, int posicao, char *destino){ 
*
0B9C:  MOVLB  4
0B9E:  CLRF   xE2
....................  
....................   int8 index = 0; 
....................  
....................   for(index = 0;index< nro_caracteres;index++){ 
0BA0:  CLRF   xE2
0BA2:  MOVF   xDE,W
0BA4:  SUBWF  xE2,W
0BA6:  BC    0BDC
....................  
....................     destino[index] = comando_recibido_BUFF[index+posicao]; 
0BA8:  CLRF   03
0BAA:  MOVF   xE2,W
0BAC:  ADDWF  xE0,W
0BAE:  MOVWF  01
0BB0:  MOVF   xE1,W
0BB2:  ADDWFC 03,F
0BB4:  MOVFF  03,4E4
0BB8:  MOVF   xDF,W
0BBA:  ADDWF  xE2,W
0BBC:  CLRF   03
0BBE:  ADDLW  E8
0BC0:  MOVWF  FE9
0BC2:  MOVLW  00
0BC4:  ADDWFC 03,W
0BC6:  MOVWF  FEA
0BC8:  MOVFF  FEF,4E5
0BCC:  MOVFF  4E4,FEA
0BD0:  MOVFF  01,FE9
0BD4:  MOVFF  4E5,FEF
0BD8:  INCF   xE2,F
0BDA:  BRA    0BA2
....................  
....................   } 
....................  
....................   destino[index] = '\0'; 
0BDC:  CLRF   03
0BDE:  MOVF   xE2,W
0BE0:  ADDWF  xE0,W
0BE2:  MOVWF  FE9
0BE4:  MOVF   xE1,W
0BE6:  ADDWFC 03,W
0BE8:  MOVWF  FEA
0BEA:  CLRF   FEF
....................  
....................   return; 
0BEC:  MOVLB  0
0BEE:  RETURN 0
.................... } 
....................  
.................... void clear_command(){ 
....................  
....................   delay_ms(200); 
*
14AA:  MOVLW  C8
14AC:  MOVLB  5
14AE:  MOVWF  x51
14B0:  MOVLB  0
14B2:  CALL   065A
....................   memset (comando_recibido_UART, 0x00, sizeof(comando_recibido_UART)); 
14B6:  CLRF   FEA
14B8:  MOVLW  52
14BA:  MOVWF  FE9
14BC:  CLRF   00
14BE:  CLRF   02
14C0:  MOVLW  96
14C2:  MOVWF  01
14C4:  CALL   0CB0
....................   memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
14C8:  CLRF   FEA
14CA:  MOVLW  E8
14CC:  MOVWF  FE9
14CE:  CLRF   00
14D0:  CLRF   02
14D2:  MOVLW  96
14D4:  MOVWF  01
14D6:  CALL   0CB0
....................  
....................   comando_disponivel_UART = FALSE; 
14DA:  MOVLB  1
14DC:  BCF    x82.0
....................   enable_interrupts(GLOBAL); 
14DE:  MOVLW  C0
14E0:  IORWF  FF2,F
....................   enable_interrupts(INT_RTCC); 
14E2:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
14E4:  BSF    F9D.5
....................    
....................   return; 
14E6:  MOVLB  0
14E8:  GOTO   15A2 (RETURN)
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... extern int1 resposta_SIM; 
.................... extern comando_disponivel_UART; 
.................... int32 timeout = 7000000; 
.................... char coordenada[40]; 
....................  
.................... int1 envia_SIM800L(char *send, char *recive){ 
*
07B4:  MOVLW  02
07B6:  MOVLB  5
07B8:  MOVWF  x4A
....................  
....................   int8 tentativas = 2; 
....................  
....................   disable_interrupts(INT_RTCC);  
07BA:  BCF    FF2.5
....................   enable_interrupts(INT_RDA);                                               
07BC:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
07BE:  MOVLW  C0
07C0:  IORWF  FF2,F
....................    
....................   do{ 
....................     timeout = 7000000;   
07C2:  MOVLB  1
07C4:  CLRF   x86
07C6:  MOVLW  6A
07C8:  MOVWF  x85
07CA:  MOVLW  CF
07CC:  MOVWF  x84
07CE:  MOVLW  C0
07D0:  MOVWF  x83
....................     comando_disponivel_UART = 0; 
07D2:  BCF    x82.0
....................  
....................     fprintf(SIM800L_SERIAL,send);                                             // Envia comando para o SIM800L  
07D4:  MOVFF  547,FEA
07D8:  MOVFF  546,FE9
07DC:  MOVLB  0
07DE:  BRA    06F4
....................     if(strstr(recive,"+CMGS")!=0){ 
07E0:  MOVLW  2B
07E2:  MOVLB  5
07E4:  MOVWF  x4B
07E6:  MOVLW  43
07E8:  MOVWF  x4C
07EA:  MOVLW  4D
07EC:  MOVWF  x4D
07EE:  MOVLW  47
07F0:  MOVWF  x4E
07F2:  MOVLW  53
07F4:  MOVWF  x4F
07F6:  CLRF   x50
07F8:  MOVFF  549,554
07FC:  MOVFF  548,553
0800:  MOVLW  05
0802:  MOVWF  x56
0804:  MOVLW  4B
0806:  MOVWF  x55
0808:  MOVLB  0
080A:  RCALL  071C
080C:  MOVFF  02,554
0810:  MOVFF  01,553
0814:  MOVLB  5
0816:  MOVF   x53,F
0818:  BNZ   081E
081A:  MOVF   x54,F
081C:  BZ    082C
....................       delay_ms(150); 
081E:  MOVLW  96
0820:  MOVWF  x51
0822:  MOVLB  0
0824:  RCALL  065A
....................       fputc(0x1A,SIM800L_SERIAL); 
0826:  MOVLW  1A
0828:  BRA    07AA
082A:  MOVLB  5
....................     }                                                                                         
....................     while(!comando_disponivel_UART && --timeout > 0);                         // Aguarda o SIM800L responder por ~23 segundos caso nao responda retorna 0 
082C:  MOVLB  1
082E:  BTFSC  x82.0
0830:  BRA    0852
0832:  MOVLW  FF
0834:  ADDWF  x83,F
0836:  BTFSS  FD8.0
0838:  ADDWF  x84,F
083A:  BTFSS  FD8.0
083C:  ADDWF  x85,F
083E:  BTFSS  FD8.0
0840:  ADDWF  x86,F
0842:  MOVF   x83,F
0844:  BNZ   082E
0846:  MOVF   x84,F
0848:  BNZ   082E
084A:  MOVF   x85,F
084C:  BNZ   082E
084E:  MOVF   x86,F
0850:  BNZ   082E
....................                           
....................     if(comando_disponivel_UART){                                              // Caso receba a resposta  
0852:  BTFSS  x82.0
0854:  BRA    088C
....................       comando_disponivel_UART = 0;                   
0856:  BCF    x82.0
....................       posicao_valor_comando = strstr(comando_recibido_UART,recive);           // Procura a palavra recive da funcao na resposta recebida 
0858:  MOVLB  5
085A:  CLRF   x54
085C:  MOVLW  52
085E:  MOVWF  x53
0860:  MOVFF  549,556
0864:  MOVFF  548,555
0868:  MOVLB  0
086A:  RCALL  071C
086C:  MOVFF  02,17F
0870:  MOVFF  01,17E
....................                  
....................       if(posicao_valor_comando!= 0){                                          // Caso encontre a resposta esperada 
0874:  MOVLB  1
0876:  MOVF   x7E,F
0878:  BNZ   087E
087A:  MOVF   x7F,F
087C:  BZ    088C
....................         enable_interrupts(INT_RDA); 
087E:  BSF    F9D.5
....................         enable_interrupts(INT_RTCC); 
0880:  BSF    FF2.5
....................         enable_interrupts(GLOBAL); 
0882:  MOVLW  C0
0884:  IORWF  FF2,F
....................         return 1; 
0886:  MOVLW  01
0888:  MOVWF  01
088A:  BRA    08A0
....................       } 
....................     } 
....................   }while(--tentativas>0);                 
088C:  MOVLB  5
088E:  DECFSZ x4A,F
0890:  BRA    07C2
....................    
....................   enable_interrupts(GLOBAL); 
0892:  MOVLW  C0
0894:  IORWF  FF2,F
....................   enable_interrupts(INT_RDA); 
0896:  BSF    F9D.5
....................   enable_interrupts(INT_RTCC); 
0898:  BSF    FF2.5
....................  
....................   return 0; 
089A:  MOVLW  00
089C:  MOVWF  01
089E:  MOVLB  1
08A0:  MOVLB  0
08A2:  RETURN 0
.................... } 
....................  
.................... int1 Send_SMS(char *numero,char *mensagem){ 
....................    
....................   char numero_envio[35]; 
....................  
....................   sprintf(numero_envio,"AT+CMGS=\"%s\"\r\n",numero); 
08A4:  MOVLW  05
08A6:  MOVLB  1
08A8:  MOVWF  xB0
08AA:  MOVLW  07
08AC:  MOVWF  xAF
08AE:  MOVLW  8A
08B0:  MOVWF  FF6
08B2:  MOVLW  05
08B4:  MOVWF  FF7
08B6:  MOVLW  09
08B8:  MOVLB  5
08BA:  MOVWF  x42
08BC:  MOVLB  0
08BE:  RCALL  06A6
08C0:  MOVFF  504,FEA
08C4:  MOVFF  503,FE9
08C8:  BRA    06CE
08CA:  MOVLW  95
08CC:  MOVWF  FF6
08CE:  MOVLW  05
08D0:  MOVWF  FF7
08D2:  MOVLW  03
08D4:  MOVLB  5
08D6:  MOVWF  x42
08D8:  MOVLB  0
08DA:  RCALL  06A6
....................  
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
08DC:  MOVLW  05
08DE:  MOVWF  FEA
08E0:  MOVLW  2A
08E2:  MOVWF  FE9
08E4:  MOVFF  FF2,542
08E8:  BCF    FF2.7
08EA:  MOVLW  0C
08EC:  MOVWF  01
08EE:  CLRF   FF7
08F0:  MOVLW  00
08F2:  RCALL  01C6
08F4:  TBLRD*-
08F6:  TBLRD*+
08F8:  MOVFF  FF5,FEE
08FC:  DECFSZ 01,F
08FE:  BRA    08F6
0900:  MOVLB  5
0902:  BTFSC  x42.7
0904:  BSF    FF2.7
0906:  MOVLW  4F
0908:  MOVWF  x36
090A:  MOVLW  4B
090C:  MOVWF  x37
090E:  CLRF   x38
0910:  MOVLW  05
0912:  MOVWF  x47
0914:  MOVLW  2A
0916:  MOVWF  x46
0918:  MOVLW  05
091A:  MOVWF  x49
091C:  MOVLW  36
091E:  MOVWF  x48
0920:  MOVLB  0
0922:  RCALL  07B4
0924:  MOVF   01,F
0926:  BZ    09DC
....................     if(envia_SIM800L("AT+CSMP=17,255,0,0\r\n","OK")) 
0928:  MOVLW  05
092A:  MOVWF  FEA
092C:  MOVLW  2A
092E:  MOVWF  FE9
0930:  MOVFF  FF2,542
0934:  BCF    FF2.7
0936:  MOVLW  15
0938:  MOVWF  01
093A:  CLRF   FF7
093C:  MOVLW  00
093E:  RCALL  01EC
0940:  TBLRD*-
0942:  TBLRD*+
0944:  MOVFF  FF5,FEE
0948:  DECFSZ 01,F
094A:  BRA    0942
094C:  MOVLB  5
094E:  BTFSC  x42.7
0950:  BSF    FF2.7
0952:  MOVLW  4F
0954:  MOVWF  x3F
0956:  MOVLW  4B
0958:  MOVWF  x40
095A:  CLRF   x41
095C:  MOVLW  05
095E:  MOVWF  x47
0960:  MOVLW  2A
0962:  MOVWF  x46
0964:  MOVLW  05
0966:  MOVWF  x49
0968:  MOVLW  3F
096A:  MOVWF  x48
096C:  MOVLB  0
096E:  RCALL  07B4
0970:  MOVF   01,F
0972:  BZ    09DC
....................       if(envia_SIM800L(numero_envio, ">")) 
0974:  MOVLW  3E
0976:  MOVLB  5
0978:  MOVWF  x2A
097A:  CLRF   x2B
097C:  MOVLW  05
097E:  MOVWF  x47
0980:  MOVLW  07
0982:  MOVWF  x46
0984:  MOVLW  05
0986:  MOVWF  x49
0988:  MOVLW  2A
098A:  MOVWF  x48
098C:  MOVLB  0
098E:  RCALL  07B4
0990:  MOVF   01,F
0992:  BZ    09DC
....................         if(envia_SIM800L(mensagem, "+CMGS:")) 
0994:  MOVLW  05
0996:  MOVWF  FEA
0998:  MOVLW  2A
099A:  MOVWF  FE9
099C:  MOVFF  FF2,542
09A0:  BCF    FF2.7
09A2:  MOVLW  07
09A4:  MOVWF  01
09A6:  CLRF   FF7
09A8:  MOVLW  00
09AA:  RCALL  021C
09AC:  TBLRD*-
09AE:  TBLRD*+
09B0:  MOVFF  FF5,FEE
09B4:  DECFSZ 01,F
09B6:  BRA    09AE
09B8:  MOVLB  5
09BA:  BTFSC  x42.7
09BC:  BSF    FF2.7
09BE:  MOVFF  506,547
09C2:  MOVFF  505,546
09C6:  MOVLW  05
09C8:  MOVWF  x49
09CA:  MOVLW  2A
09CC:  MOVWF  x48
09CE:  MOVLB  0
09D0:  RCALL  07B4
09D2:  MOVF   01,F
09D4:  BZ    09DC
....................           return 1; 
09D6:  MOVLW  01
09D8:  MOVWF  01
09DA:  BRA    09E0
....................   return 0; 
09DC:  MOVLW  00
09DE:  MOVWF  01
09E0:  RETURN 0
.................... } 
....................  
.................... int1 Read_SMS(){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")){ 
*
0AEC:  MOVLW  04
0AEE:  MOVWF  FEA
0AF0:  MOVLW  DE
0AF2:  MOVWF  FE9
0AF4:  MOVFF  FF2,4F6
0AF8:  BCF    FF2.7
0AFA:  MOVLW  0C
0AFC:  MOVWF  01
0AFE:  CLRF   FF7
0B00:  MOVLW  00
0B02:  CALL   01C6
0B06:  TBLRD*-
0B08:  TBLRD*+
0B0A:  MOVFF  FF5,FEE
0B0E:  DECFSZ 01,F
0B10:  BRA    0B08
0B12:  MOVLB  4
0B14:  BTFSC  xF6.7
0B16:  BSF    FF2.7
0B18:  MOVLW  4F
0B1A:  MOVWF  xEA
0B1C:  MOVLW  4B
0B1E:  MOVWF  xEB
0B20:  CLRF   xEC
0B22:  MOVLW  04
0B24:  MOVLB  5
0B26:  MOVWF  x47
0B28:  MOVLW  DE
0B2A:  MOVWF  x46
0B2C:  MOVLW  04
0B2E:  MOVWF  x49
0B30:  MOVLW  EA
0B32:  MOVWF  x48
0B34:  MOVLB  0
0B36:  RCALL  07B4
0B38:  MOVF   01,F
0B3A:  BZ    0B90
....................     if(envia_SIM800L("AT+CMGL=\"REC UNREAD\"\r\n", "")){ 
0B3C:  MOVLW  04
0B3E:  MOVWF  FEA
0B40:  MOVLW  DE
0B42:  MOVWF  FE9
0B44:  MOVFF  FF2,4F6
0B48:  BCF    FF2.7
0B4A:  MOVLW  17
0B4C:  MOVWF  01
0B4E:  CLRF   FF7
0B50:  MOVLW  00
0B52:  CALL   023E
0B56:  TBLRD*-
0B58:  TBLRD*+
0B5A:  MOVFF  FF5,FEE
0B5E:  DECFSZ 01,F
0B60:  BRA    0B58
0B62:  MOVLB  4
0B64:  BTFSC  xF6.7
0B66:  BSF    FF2.7
0B68:  CLRF   xF5
0B6A:  MOVLW  04
0B6C:  MOVLB  5
0B6E:  MOVWF  x47
0B70:  MOVLW  DE
0B72:  MOVWF  x46
0B74:  MOVLW  04
0B76:  MOVWF  x49
0B78:  MOVLW  F5
0B7A:  MOVWF  x48
0B7C:  MOVLB  0
0B7E:  RCALL  07B4
0B80:  MOVF   01,F
0B82:  BZ    0B90
....................       resposta_SIM = true; 
0B84:  MOVLB  1
0B86:  BSF    x82.1
....................       return 1;     
0B88:  MOVLW  01
0B8A:  MOVWF  01
0B8C:  BRA    0B96
0B8E:  MOVLB  0
....................     }   
....................   } 
....................   return 0; 
0B90:  MOVLW  00
0B92:  MOVWF  01
0B94:  MOVLB  1
0B96:  MOVLB  0
0B98:  GOTO   14A8 (RETURN)
.................... } 
....................  
.................... int1 Get_Locate(char *numero){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
*
0E42:  MOVLW  04
0E44:  MOVWF  FEA
0E46:  MOVLW  E0
0E48:  MOVWF  FE9
0E4A:  MOVFF  FF2,503
0E4E:  BCF    FF2.7
0E50:  MOVLW  0C
0E52:  MOVWF  01
0E54:  CLRF   FF7
0E56:  MOVLW  00
0E58:  CALL   01C6
0E5C:  TBLRD*-
0E5E:  TBLRD*+
0E60:  MOVFF  FF5,FEE
0E64:  DECFSZ 01,F
0E66:  BRA    0E5E
0E68:  MOVLB  5
0E6A:  BTFSC  x03.7
0E6C:  BSF    FF2.7
0E6E:  MOVLW  4F
0E70:  MOVLB  4
0E72:  MOVWF  xEC
0E74:  MOVLW  4B
0E76:  MOVWF  xED
0E78:  CLRF   xEE
0E7A:  MOVLW  04
0E7C:  MOVLB  5
0E7E:  MOVWF  x47
0E80:  MOVLW  E0
0E82:  MOVWF  x46
0E84:  MOVLW  04
0E86:  MOVWF  x49
0E88:  MOVLW  EC
0E8A:  MOVWF  x48
0E8C:  MOVLB  0
0E8E:  RCALL  07B4
0E90:  MOVF   01,F
0E92:  BTFSC  FD8.2
0E94:  BRA    11B4
....................     if(envia_SIM800L("AT+CGATT=1\r\n","OK")) 
0E96:  MOVLW  04
0E98:  MOVWF  FEA
0E9A:  MOVLW  E0
0E9C:  MOVWF  FE9
0E9E:  MOVFF  FF2,503
0EA2:  BCF    FF2.7
0EA4:  MOVLW  0D
0EA6:  MOVWF  01
0EA8:  CLRF   FF7
0EAA:  MOVLW  00
0EAC:  CALL   0270
0EB0:  TBLRD*-
0EB2:  TBLRD*+
0EB4:  MOVFF  FF5,FEE
0EB8:  DECFSZ 01,F
0EBA:  BRA    0EB2
0EBC:  MOVLB  5
0EBE:  BTFSC  x03.7
0EC0:  BSF    FF2.7
0EC2:  MOVLW  4F
0EC4:  MOVLB  4
0EC6:  MOVWF  xED
0EC8:  MOVLW  4B
0ECA:  MOVWF  xEE
0ECC:  CLRF   xEF
0ECE:  MOVLW  04
0ED0:  MOVLB  5
0ED2:  MOVWF  x47
0ED4:  MOVLW  E0
0ED6:  MOVWF  x46
0ED8:  MOVLW  04
0EDA:  MOVWF  x49
0EDC:  MOVLW  ED
0EDE:  MOVWF  x48
0EE0:  MOVLB  0
0EE2:  RCALL  07B4
0EE4:  MOVF   01,F
0EE6:  BTFSC  FD8.2
0EE8:  BRA    11B4
....................       if(envia_SIM800L("AT+SAPBR=3,1,\"CONTYPE\",\"GPRS\"\r\n","OK")) 
0EEA:  MOVLW  04
0EEC:  MOVWF  FEA
0EEE:  MOVLW  E0
0EF0:  MOVWF  FE9
0EF2:  MOVFF  FF2,503
0EF6:  BCF    FF2.7
0EF8:  MOVLW  20
0EFA:  MOVWF  01
0EFC:  CLRF   FF7
0EFE:  MOVLW  00
0F00:  CALL   0298
0F04:  TBLRD*-
0F06:  TBLRD*+
0F08:  MOVFF  FF5,FEE
0F0C:  DECFSZ 01,F
0F0E:  BRA    0F06
0F10:  MOVLB  5
0F12:  BTFSC  x03.7
0F14:  BSF    FF2.7
0F16:  MOVLW  4F
0F18:  MOVWF  x00
0F1A:  MOVLW  4B
0F1C:  MOVWF  x01
0F1E:  CLRF   x02
0F20:  MOVLW  04
0F22:  MOVWF  x47
0F24:  MOVLW  E0
0F26:  MOVWF  x46
0F28:  MOVLW  05
0F2A:  MOVWF  x49
0F2C:  CLRF   x48
0F2E:  MOVLB  0
0F30:  RCALL  07B4
0F32:  MOVF   01,F
0F34:  BTFSC  FD8.2
0F36:  BRA    11B4
....................         if(envia_SIM800L("AT+SAPBR=3,1,\"APN\",\"CMNET\"\r\n","OK")) 
0F38:  MOVLW  04
0F3A:  MOVWF  FEA
0F3C:  MOVLW  E0
0F3E:  MOVWF  FE9
0F40:  MOVFF  FF2,503
0F44:  BCF    FF2.7
0F46:  MOVLW  1D
0F48:  MOVWF  01
0F4A:  CLRF   FF7
0F4C:  MOVLW  00
0F4E:  CALL   02D2
0F52:  TBLRD*-
0F54:  TBLRD*+
0F56:  MOVFF  FF5,FEE
0F5A:  DECFSZ 01,F
0F5C:  BRA    0F54
0F5E:  MOVLB  5
0F60:  BTFSC  x03.7
0F62:  BSF    FF2.7
0F64:  MOVLW  4F
0F66:  MOVLB  4
0F68:  MOVWF  xFD
0F6A:  MOVLW  4B
0F6C:  MOVWF  xFE
0F6E:  CLRF   xFF
0F70:  MOVLW  04
0F72:  MOVLB  5
0F74:  MOVWF  x47
0F76:  MOVLW  E0
0F78:  MOVWF  x46
0F7A:  MOVLW  04
0F7C:  MOVWF  x49
0F7E:  MOVLW  FD
0F80:  MOVWF  x48
0F82:  MOVLB  0
0F84:  RCALL  07B4
0F86:  MOVF   01,F
0F88:  BTFSC  FD8.2
0F8A:  BRA    11B4
....................           if(envia_SIM800L("AT+SAPBR=1,1\r\n","OK")) 
0F8C:  MOVLW  04
0F8E:  MOVWF  FEA
0F90:  MOVLW  E0
0F92:  MOVWF  FE9
0F94:  MOVFF  FF2,503
0F98:  BCF    FF2.7
0F9A:  MOVLW  0F
0F9C:  MOVWF  01
0F9E:  CLRF   FF7
0FA0:  MOVLW  00
0FA2:  CALL   030A
0FA6:  TBLRD*-
0FA8:  TBLRD*+
0FAA:  MOVFF  FF5,FEE
0FAE:  DECFSZ 01,F
0FB0:  BRA    0FA8
0FB2:  MOVLB  5
0FB4:  BTFSC  x03.7
0FB6:  BSF    FF2.7
0FB8:  MOVLW  4F
0FBA:  MOVLB  4
0FBC:  MOVWF  xEF
0FBE:  MOVLW  4B
0FC0:  MOVWF  xF0
0FC2:  CLRF   xF1
0FC4:  MOVLW  04
0FC6:  MOVLB  5
0FC8:  MOVWF  x47
0FCA:  MOVLW  E0
0FCC:  MOVWF  x46
0FCE:  MOVLW  04
0FD0:  MOVWF  x49
0FD2:  MOVLW  EF
0FD4:  MOVWF  x48
0FD6:  MOVLB  0
0FD8:  CALL   07B4
0FDC:  MOVF   01,F
0FDE:  BTFSC  FD8.2
0FE0:  BRA    11B4
....................             if(envia_SIM800L("AT+SAPBR=2,1\r\n","+SAPBR:")) 
0FE2:  MOVLW  04
0FE4:  MOVWF  FEA
0FE6:  MOVLW  E0
0FE8:  MOVWF  FE9
0FEA:  MOVFF  FF2,503
0FEE:  BCF    FF2.7
0FF0:  MOVLW  0F
0FF2:  MOVWF  01
0FF4:  CLRF   FF7
0FF6:  MOVLW  00
0FF8:  CALL   0334
0FFC:  TBLRD*-
0FFE:  TBLRD*+
1000:  MOVFF  FF5,FEE
1004:  DECFSZ 01,F
1006:  BRA    0FFE
1008:  MOVLB  5
100A:  BTFSC  x03.7
100C:  BSF    FF2.7
100E:  MOVLW  04
1010:  MOVWF  FEA
1012:  MOVLW  EF
1014:  MOVWF  FE9
1016:  MOVFF  FF2,505
101A:  BCF    FF2.7
101C:  MOVLW  08
101E:  MOVWF  01
1020:  CLRF   FF7
1022:  MOVLW  00
1024:  MOVLB  0
1026:  CALL   035E
102A:  TBLRD*-
102C:  TBLRD*+
102E:  MOVFF  FF5,FEE
1032:  DECFSZ 01,F
1034:  BRA    102C
1036:  MOVLB  5
1038:  BTFSC  x05.7
103A:  BSF    FF2.7
103C:  MOVLW  04
103E:  MOVWF  x47
1040:  MOVLW  E0
1042:  MOVWF  x46
1044:  MOVLW  04
1046:  MOVWF  x49
1048:  MOVLW  EF
104A:  MOVWF  x48
104C:  MOVLB  0
104E:  CALL   07B4
1052:  MOVF   01,F
1054:  BTFSC  FD8.2
1056:  BRA    11B4
....................               if(envia_SIM800L("AT+CLBSCFG=0,1\r\n","+CLBSCFG:")){                 
1058:  MOVLW  04
105A:  MOVWF  FEA
105C:  MOVLW  E0
105E:  MOVWF  FE9
1060:  MOVFF  FF2,503
1064:  BCF    FF2.7
1066:  MOVLW  11
1068:  MOVWF  01
106A:  CLRF   FF7
106C:  MOVLW  00
106E:  CALL   0380
1072:  TBLRD*-
1074:  TBLRD*+
1076:  MOVFF  FF5,FEE
107A:  DECFSZ 01,F
107C:  BRA    1074
107E:  MOVLB  5
1080:  BTFSC  x03.7
1082:  BSF    FF2.7
1084:  MOVLW  04
1086:  MOVWF  FEA
1088:  MOVLW  F1
108A:  MOVWF  FE9
108C:  MOVFF  FF2,505
1090:  BCF    FF2.7
1092:  MOVLW  0A
1094:  MOVWF  01
1096:  CLRF   FF7
1098:  MOVLW  00
109A:  MOVLB  0
109C:  CALL   03AC
10A0:  TBLRD*-
10A2:  TBLRD*+
10A4:  MOVFF  FF5,FEE
10A8:  DECFSZ 01,F
10AA:  BRA    10A2
10AC:  MOVLB  5
10AE:  BTFSC  x05.7
10B0:  BSF    FF2.7
10B2:  MOVLW  04
10B4:  MOVWF  x47
10B6:  MOVLW  E0
10B8:  MOVWF  x46
10BA:  MOVLW  04
10BC:  MOVWF  x49
10BE:  MOVLW  F1
10C0:  MOVWF  x48
10C2:  MOVLB  0
10C4:  CALL   07B4
10C8:  MOVF   01,F
10CA:  BZ    11B4
....................                 if(envia_SIM800L("AT+CLBS=1,1\r\n","+CLBS:")){ 
10CC:  MOVLW  04
10CE:  MOVWF  FEA
10D0:  MOVLW  E0
10D2:  MOVWF  FE9
10D4:  MOVFF  FF2,503
10D8:  BCF    FF2.7
10DA:  MOVLW  0E
10DC:  MOVWF  01
10DE:  CLRF   FF7
10E0:  MOVLW  00
10E2:  CALL   03D0
10E6:  TBLRD*-
10E8:  TBLRD*+
10EA:  MOVFF  FF5,FEE
10EE:  DECFSZ 01,F
10F0:  BRA    10E8
10F2:  MOVLB  5
10F4:  BTFSC  x03.7
10F6:  BSF    FF2.7
10F8:  MOVLW  04
10FA:  MOVWF  FEA
10FC:  MOVLW  EE
10FE:  MOVWF  FE9
1100:  MOVFF  FF2,505
1104:  BCF    FF2.7
1106:  MOVLW  07
1108:  MOVWF  01
110A:  CLRF   FF7
110C:  MOVLW  00
110E:  MOVLB  0
1110:  CALL   03F8
1114:  TBLRD*-
1116:  TBLRD*+
1118:  MOVFF  FF5,FEE
111C:  DECFSZ 01,F
111E:  BRA    1116
1120:  MOVLB  5
1122:  BTFSC  x05.7
1124:  BSF    FF2.7
1126:  MOVLW  04
1128:  MOVWF  x47
112A:  MOVLW  E0
112C:  MOVWF  x46
112E:  MOVLW  04
1130:  MOVWF  x49
1132:  MOVLW  EE
1134:  MOVWF  x48
1136:  MOVLB  0
1138:  CALL   07B4
113C:  MOVF   01,F
113E:  BZ    11B4
....................                   Get_Coordenadas(); 
1140:  BRA    0CE0
....................                   Send_SMS(numero,coordenada);  
1142:  MOVFF  4DF,504
1146:  MOVFF  4DE,503
114A:  MOVLW  01
114C:  MOVLB  5
114E:  MOVWF  x06
1150:  MOVLW  87
1152:  MOVWF  x05
1154:  MOVLB  0
1156:  CALL   08A4
....................                   if(envia_SIM800L("AT+SAPBR=0,1\r\n","OK")) 
115A:  MOVLW  04
115C:  MOVWF  FEA
115E:  MOVLW  E0
1160:  MOVWF  FE9
1162:  MOVFF  FF2,503
1166:  BCF    FF2.7
1168:  MOVLW  0F
116A:  MOVWF  01
116C:  CLRF   FF7
116E:  MOVLW  00
1170:  CALL   041A
1174:  TBLRD*-
1176:  TBLRD*+
1178:  MOVFF  FF5,FEE
117C:  DECFSZ 01,F
117E:  BRA    1176
1180:  MOVLB  5
1182:  BTFSC  x03.7
1184:  BSF    FF2.7
1186:  MOVLW  4F
1188:  MOVLB  4
118A:  MOVWF  xEF
118C:  MOVLW  4B
118E:  MOVWF  xF0
1190:  CLRF   xF1
1192:  MOVLW  04
1194:  MOVLB  5
1196:  MOVWF  x47
1198:  MOVLW  E0
119A:  MOVWF  x46
119C:  MOVLW  04
119E:  MOVWF  x49
11A0:  MOVLW  EF
11A2:  MOVWF  x48
11A4:  MOVLB  0
11A6:  CALL   07B4
11AA:  MOVF   01,F
11AC:  BZ    11B4
....................                     return 1;  
11AE:  MOVLW  01
11B0:  MOVWF  01
11B2:  BRA    1208
....................                 } 
....................               } 
....................   
....................   envia_SIM800L("AT+SAPBR=0,1\r\n","OK"); 
11B4:  MOVLW  04
11B6:  MOVWF  FEA
11B8:  MOVLW  E0
11BA:  MOVWF  FE9
11BC:  MOVFF  FF2,503
11C0:  BCF    FF2.7
11C2:  MOVLW  0F
11C4:  MOVWF  01
11C6:  CLRF   FF7
11C8:  MOVLW  00
11CA:  CALL   041A
11CE:  TBLRD*-
11D0:  TBLRD*+
11D2:  MOVFF  FF5,FEE
11D6:  DECFSZ 01,F
11D8:  BRA    11D0
11DA:  MOVLB  5
11DC:  BTFSC  x03.7
11DE:  BSF    FF2.7
11E0:  MOVLW  4F
11E2:  MOVLB  4
11E4:  MOVWF  xEF
11E6:  MOVLW  4B
11E8:  MOVWF  xF0
11EA:  CLRF   xF1
11EC:  MOVLW  04
11EE:  MOVLB  5
11F0:  MOVWF  x47
11F2:  MOVLW  E0
11F4:  MOVWF  x46
11F6:  MOVLW  04
11F8:  MOVWF  x49
11FA:  MOVLW  EF
11FC:  MOVWF  x48
11FE:  MOVLB  0
1200:  CALL   07B4
....................   return 0;    
1204:  MOVLW  00
1206:  MOVWF  01
1208:  GOTO   14A8 (RETURN)
.................... } 
....................  
.................... void Get_Coordenadas(){ 
*
0CE0:  MOVLB  5
0CE2:  CLRF   x03
0CE4:  CLRF   x04
....................   
....................  int8 index=0; 
....................  int8 index2=0; 
....................  
....................   memset (coordenada, 0x00, sizeof(coordenada)); 
0CE6:  MOVLW  01
0CE8:  MOVWF  FEA
0CEA:  MOVLW  87
0CEC:  MOVWF  FE9
0CEE:  CLRF   00
0CF0:  CLRF   02
0CF2:  MOVLW  28
0CF4:  MOVWF  01
0CF6:  MOVLB  0
0CF8:  RCALL  0CB0
....................    
....................   coordenada[0] ='L'; 
0CFA:  MOVLW  4C
0CFC:  MOVLB  1
0CFE:  MOVWF  x87
....................   coordenada[1] ='O'; 
0D00:  MOVLW  4F
0D02:  MOVWF  x88
....................   coordenada[2] ='C'; 
0D04:  MOVLW  43
0D06:  MOVWF  x89
....................   coordenada[3] ='A'; 
0D08:  MOVLW  41
0D0A:  MOVWF  x8A
....................   coordenada[4] ='T'; 
0D0C:  MOVLW  54
0D0E:  MOVWF  x8B
....................   coordenada[5] ='E'; 
0D10:  MOVLW  45
0D12:  MOVWF  x8C
....................   coordenada[6] =':'; 
0D14:  MOVLW  3A
0D16:  MOVWF  x8D
....................   coordenada[7] =' '; 
0D18:  MOVLW  20
0D1A:  MOVWF  x8E
....................   
....................   index2 = 8; 
0D1C:  MOVLW  08
0D1E:  MOVLB  5
0D20:  MOVWF  x04
....................   for(index=22;index<33;index++){ //Latitude 
0D22:  MOVLW  16
0D24:  MOVWF  x03
0D26:  MOVF   x03,W
0D28:  SUBLW  20
0D2A:  BNC   0D60
....................    coordenada[index2] = comando_recibido_UART[index]; 
0D2C:  CLRF   03
0D2E:  MOVF   x04,W
0D30:  ADDLW  87
0D32:  MOVWF  01
0D34:  MOVLW  01
0D36:  ADDWFC 03,F
0D38:  MOVFF  03,506
0D3C:  CLRF   03
0D3E:  MOVF   x03,W
0D40:  ADDLW  52
0D42:  MOVWF  FE9
0D44:  MOVLW  00
0D46:  ADDWFC 03,W
0D48:  MOVWF  FEA
0D4A:  MOVFF  FEF,507
0D4E:  MOVFF  506,FEA
0D52:  MOVFF  01,FE9
0D56:  MOVFF  507,FEF
....................    index2++;    
0D5A:  INCF   x04,F
0D5C:  INCF   x03,F
0D5E:  BRA    0D26
....................   } 
....................  
....................   for(index=11;index<22;index++){ //Longitude 
0D60:  MOVLW  0B
0D62:  MOVWF  x03
0D64:  MOVF   x03,W
0D66:  SUBLW  15
0D68:  BNC   0D9E
....................    coordenada[index2] = comando_recibido_UART[index]; 
0D6A:  CLRF   03
0D6C:  MOVF   x04,W
0D6E:  ADDLW  87
0D70:  MOVWF  01
0D72:  MOVLW  01
0D74:  ADDWFC 03,F
0D76:  MOVFF  03,506
0D7A:  CLRF   03
0D7C:  MOVF   x03,W
0D7E:  ADDLW  52
0D80:  MOVWF  FE9
0D82:  MOVLW  00
0D84:  ADDWFC 03,W
0D86:  MOVWF  FEA
0D88:  MOVFF  FEF,507
0D8C:  MOVFF  506,FEA
0D90:  MOVFF  01,FE9
0D94:  MOVFF  507,FEF
....................    index2++;    
0D98:  INCF   x04,F
0D9A:  INCF   x03,F
0D9C:  BRA    0D64
....................   } 
....................    
....................   coordenada[index2++] =' '; 
0D9E:  MOVF   x04,W
0DA0:  INCF   x04,F
0DA2:  CLRF   03
0DA4:  ADDLW  87
0DA6:  MOVWF  FE9
0DA8:  MOVLW  01
0DAA:  ADDWFC 03,W
0DAC:  MOVWF  FEA
0DAE:  MOVLW  20
0DB0:  MOVWF  FEF
....................   coordenada[index2++] ='R'; 
0DB2:  MOVF   x04,W
0DB4:  INCF   x04,F
0DB6:  CLRF   03
0DB8:  ADDLW  87
0DBA:  MOVWF  FE9
0DBC:  MOVLW  01
0DBE:  ADDWFC 03,W
0DC0:  MOVWF  FEA
0DC2:  MOVLW  52
0DC4:  MOVWF  FEF
....................   coordenada[index2++] ='='; 
0DC6:  MOVF   x04,W
0DC8:  INCF   x04,F
0DCA:  CLRF   03
0DCC:  ADDLW  87
0DCE:  MOVWF  FE9
0DD0:  MOVLW  01
0DD2:  ADDWFC 03,W
0DD4:  MOVWF  FEA
0DD6:  MOVLW  3D
0DD8:  MOVWF  FEF
....................  
....................   for(index=33;index<36;index++){ //Precisão 
0DDA:  MOVLW  21
0DDC:  MOVWF  x03
0DDE:  MOVF   x03,W
0DE0:  SUBLW  23
0DE2:  BNC   0E18
....................    coordenada[index2] = comando_recibido_UART[index]; 
0DE4:  CLRF   03
0DE6:  MOVF   x04,W
0DE8:  ADDLW  87
0DEA:  MOVWF  01
0DEC:  MOVLW  01
0DEE:  ADDWFC 03,F
0DF0:  MOVFF  03,506
0DF4:  CLRF   03
0DF6:  MOVF   x03,W
0DF8:  ADDLW  52
0DFA:  MOVWF  FE9
0DFC:  MOVLW  00
0DFE:  ADDWFC 03,W
0E00:  MOVWF  FEA
0E02:  MOVFF  FEF,507
0E06:  MOVFF  506,FEA
0E0A:  MOVFF  01,FE9
0E0E:  MOVFF  507,FEF
....................    index2++;    
0E12:  INCF   x04,F
0E14:  INCF   x03,F
0E16:  BRA    0DDE
....................   } 
....................    
....................   coordenada[index2++] ='m'; 
0E18:  MOVF   x04,W
0E1A:  INCF   x04,F
0E1C:  CLRF   03
0E1E:  ADDLW  87
0E20:  MOVWF  FE9
0E22:  MOVLW  01
0E24:  ADDWFC 03,W
0E26:  MOVWF  FEA
0E28:  MOVLW  6D
0E2A:  MOVWF  FEF
....................   coordenada[index2] = 0; 
0E2C:  CLRF   03
0E2E:  MOVF   x04,W
0E30:  ADDLW  87
0E32:  MOVWF  FE9
0E34:  MOVLW  01
0E36:  ADDWFC 03,W
0E38:  MOVWF  FEA
0E3A:  CLRF   FEF
0E3C:  MOVLB  0
0E3E:  GOTO   1142 (RETURN)
....................  
.................... } 
....................  
....................  
.................... #ENDIF 
....................  
....................  
.................... // DeclaraÃ§Ã£o de VariÃ¡veis 
....................  
.................... int1 comando_disponivel_UART = FALSE; 
.................... int1 One_Second = FALSE; 
.................... int1 One_Minute = FALSE; 
.................... int16 Miliseconds = 0; 
.................... int16 seconds = 0; 
.................... char comando = 0; 
.................... int1 resposta_SIM = false; 
.................... int8 leitura_tensao[500]; 
.................... int16 leitura_corrente[100]; 
.................... int1 partida_iniciada = FALSE; 
.................... int1 aquisicao_tensao_partida = FALSE; 
.................... int1 veiculo_ligado = FALSE; 
.................... int16 index = 0; 
.................... int8 V1 = 255; 
.................... int8 V2 = 255; 
.................... //Fim declaraÃ§Ã£o de variÃ¡veis 
....................  
.................... #INT_RTCC 
.................... void Timer_0(){ 
....................  
....................   set_timer0(6);   
*
059A:  CLRF   FD7
059C:  MOVLW  06
059E:  MOVWF  FD6
....................    
....................   if(partida_iniciada){ 
05A0:  MOVLB  1
05A2:  BTFSS  x82.4
05A4:  BRA    05FA
....................      
....................     if(index<500){  
05A6:  MOVLB  4
05A8:  MOVF   x73,W
05AA:  SUBLW  01
05AC:  BNC   05EA
05AE:  BNZ   05B6
05B0:  MOVF   x72,W
05B2:  SUBLW  F3
05B4:  BNC   05EA
....................  
....................       leitura_tensao[index] = (read_adc()>>2); 
05B6:  MOVLW  B6
05B8:  ADDWF  x72,W
05BA:  MOVWF  FE9
05BC:  MOVLW  01
05BE:  ADDWFC x73,W
05C0:  MOVWF  FEA
05C2:  BSF    FC2.1
05C4:  BTFSC  FC2.1
05C6:  BRA    05C4
05C8:  MOVLB  5
05CA:  RRCF   FC4,W
05CC:  MOVWF  03
05CE:  RRCF   FC3,W
05D0:  MOVWF  02
05D2:  RRCF   03,F
05D4:  RRCF   02,F
05D6:  MOVLW  3F
05D8:  ANDWF  03,F
05DA:  MOVFF  02,FEF
....................       output_toggle(PIN_A0); 
05DE:  BTG    F89.0
....................       index++; 
05E0:  MOVLB  4
05E2:  INCF   x72,F
05E4:  BTFSC  FD8.2
05E6:  INCF   x73,F
....................     }  
05E8:  BRA    05F6
....................     else{ 
....................       partida_iniciada = FALSE; 
05EA:  MOVLB  1
05EC:  BCF    x82.4
....................       aquisicao_tensao_partida = TRUE; 
05EE:  BSF    x82.5
....................       enable_interrupts(INT_RDA); 
05F0:  BSF    F9D.5
....................       enable_interrupts(INT_EXT); 
05F2:  BSF    FF2.4
05F4:  MOVLB  4
....................     } 
....................   } 
05F6:  BRA    062C
05F8:  MOVLB  1
....................   else{ 
....................     Miliseconds++; 
05FA:  INCF   xB1,F
05FC:  BTFSC  FD8.2
05FE:  INCF   xB2,F
....................      
....................     if(Miliseconds == 1000){ 
0600:  MOVF   xB1,W
0602:  SUBLW  E8
0604:  BNZ   062A
0606:  MOVF   xB2,W
0608:  SUBLW  03
060A:  BNZ   062A
....................       seconds++; 
060C:  INCF   xB3,F
060E:  BTFSC  FD8.2
0610:  INCF   xB4,F
....................       Miliseconds = 0; 
0612:  CLRF   xB2
0614:  CLRF   xB1
....................       One_Second = TRUE; 
0616:  BSF    x82.2
....................       output_toggle(PIN_A0); 
0618:  BTG    F89.0
....................       if(seconds==60){ 
061A:  MOVF   xB3,W
061C:  SUBLW  3C
061E:  BNZ   062A
0620:  MOVF   xB4,F
0622:  BNZ   062A
....................         seconds = 0; 
0624:  CLRF   xB4
0626:  CLRF   xB3
....................         One_Minute = TRUE; 
0628:  BSF    x82.3
062A:  MOVLB  4
....................       } 
....................     } 
....................   } 
....................   return; 
.................... } 
....................  
062C:  BCF    FF2.2
062E:  MOVLB  0
0630:  GOTO   006C
.................... #INT_EXT 
.................... void Interrupcao_Externa(){ 
....................    
....................   set_adc_channel(1); 
0634:  MOVLW  04
0636:  MOVWF  01
0638:  MOVF   FC2,W
063A:  ANDLW  C3
063C:  IORWF  01,W
063E:  MOVWF  FC2
....................   disable_interrupts(INT_RDA); 
0640:  BCF    F9D.5
....................   disable_interrupts(INT_EXT); 
0642:  BCF    FF2.4
....................   partida_iniciada = TRUE; 
0644:  MOVLB  1
0646:  BSF    x82.4
....................   veiculo_ligado = TRUE; 
0648:  BSF    x82.6
....................   aquisicao_tensao_partida = FALSE; 
064A:  BCF    x82.5
....................   index = 0; 
064C:  MOVLB  4
064E:  CLRF   x73
0650:  CLRF   x72
....................  
....................   return; 
0652:  BCF    FF2.1
0654:  MOVLB  0
0656:  GOTO   006C
.................... } 
....................  
.................... void main() 
*
15AA:  CLRF   FF8
15AC:  BCF    FD0.7
15AE:  BSF    07.7
15B0:  CLRF   16
15B2:  BSF    FB8.3
15B4:  MOVLW  22
15B6:  MOVWF  FAF
15B8:  MOVLW  00
15BA:  MOVWF  FB0
15BC:  MOVLW  A6
15BE:  MOVWF  FAC
15C0:  MOVLW  90
15C2:  MOVWF  FAB
15C4:  BCF    F93.2
15C6:  BSF    F8A.2
15C8:  CLRF   4F
15CA:  MOVLB  1
15CC:  CLRF   x7F
15CE:  CLRF   x7E
15D0:  MOVLW  86
15D2:  MOVWF  x81
15D4:  MOVLW  A0
15D6:  MOVWF  x80
15D8:  CLRF   x86
15DA:  MOVLW  6A
15DC:  MOVWF  x85
15DE:  MOVLW  CF
15E0:  MOVWF  x84
15E2:  MOVLW  C0
15E4:  MOVWF  x83
15E6:  CLRF   xB0
15E8:  CLRF   xAF
15EA:  BCF    x82.0
15EC:  BCF    x82.2
15EE:  BCF    x82.3
15F0:  CLRF   xB2
15F2:  CLRF   xB1
15F4:  CLRF   xB4
15F6:  CLRF   xB3
15F8:  CLRF   xB5
15FA:  BCF    x82.1
15FC:  BCF    x82.4
15FE:  BCF    x82.5
1600:  BCF    x82.6
1602:  MOVLB  4
1604:  CLRF   x73
1606:  CLRF   x72
1608:  SETF   x74
160A:  SETF   x75
160C:  MOVF   FC1,W
160E:  ANDLW  C0
1610:  IORLW  0F
1612:  MOVWF  FC1
1614:  MOVLW  07
1616:  MOVWF  FB4
1618:  CLRF   17
161A:  CLRF   18
.................... { 
....................   set_tris_a (0b00001110);                                                     //Ra7-Ra6-Ra5-Ra4-Ra3-Ra2-Ra1-Ra0 
161C:  MOVLW  0E
161E:  MOVWF  F92
....................   set_tris_b (0b00001001);                                                     //Rb7-Rb6-Rb5-Rb4-Rb3-Rb2-Rb1-Rb0 
1620:  MOVLW  09
1622:  MOVWF  F93
....................   set_tris_c (0b10000000);                                                     //Rc7-Rc6-Rc5-Rc4-Rc3-Rc2-Rc1-Rc0 
1624:  MOVLW  80
1626:  MOVWF  F94
....................   set_tris_d (0b00000000);  
1628:  MOVLW  00
162A:  MOVWF  F95
....................    
....................   setup_adc_ports(AN0_TO_AN3); 
162C:  MOVF   FC1,W
162E:  ANDLW  C0
1630:  IORLW  0B
1632:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_2); 
1634:  MOVF   FC0,W
1636:  ANDLW  C0
1638:  MOVWF  FC0
163A:  BSF    FC0.7
163C:  BSF    FC2.0
....................   set_adc_channel(1); 
163E:  MOVLW  04
1640:  MOVWF  01
1642:  MOVF   FC2,W
1644:  ANDLW  C3
1646:  IORWF  01,W
1648:  MOVWF  FC2
....................   setup_wdt(WDT_OFF); 
164A:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 | RTCC_8_BIT); 
164C:  MOVLW  C3
164E:  MOVWF  FD5
....................   set_timer0(6); 
1650:  CLRF   FD7
1652:  MOVLW  06
1654:  MOVWF  FD6
....................   ext_int_edge(H_TO_L); 
1656:  BCF    FF1.6
....................    
....................   enable_interrupts(INT_RTCC); 
1658:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
165A:  BSF    F9D.5
....................   enable_interrupts(INT_EXT_H2L); 
165C:  BSF    FF2.4
165E:  BCF    FF1.6
....................   enable_interrupts(GLOBAL);  
1660:  MOVLW  C0
1662:  IORWF  FF2,F
....................   output_low(PIN_D2); 
1664:  BCF    F8C.2
....................   delay_ms(2000); 
1666:  MOVLW  08
1668:  MOVWF  x90
166A:  MOVLW  FA
166C:  MOVLB  5
166E:  MOVWF  x51
1670:  MOVLB  0
1672:  CALL   065A
1676:  MOVLB  4
1678:  DECFSZ x90,F
167A:  BRA    166A
....................   output_high(PIN_D2); 
167C:  BSF    F8C.2
....................   delay_ms(15000); 
167E:  MOVLW  3C
1680:  MOVWF  x90
1682:  MOVLW  FA
1684:  MOVLB  5
1686:  MOVWF  x51
1688:  MOVLB  0
168A:  CALL   065A
168E:  MOVLB  4
1690:  DECFSZ x90,F
1692:  BRA    1682
....................   Send_SMS("031995822739","INICIANDO..."); 
1694:  MOVLW  04
1696:  MOVWF  FEA
1698:  MOVLW  76
169A:  MOVWF  FE9
169C:  MOVFF  FF2,490
16A0:  BCF    FF2.7
16A2:  MOVLW  0D
16A4:  MOVWF  01
16A6:  CLRF   FF7
16A8:  MOVLW  00
16AA:  MOVLB  0
16AC:  CALL   0444
16B0:  TBLRD*-
16B2:  TBLRD*+
16B4:  MOVFF  FF5,FEE
16B8:  DECFSZ 01,F
16BA:  BRA    16B2
16BC:  MOVLB  4
16BE:  BTFSC  x90.7
16C0:  BSF    FF2.7
16C2:  MOVLW  04
16C4:  MOVWF  FEA
16C6:  MOVLW  83
16C8:  MOVWF  FE9
16CA:  MOVFF  FF2,492
16CE:  BCF    FF2.7
16D0:  MOVLW  0D
16D2:  MOVWF  01
16D4:  CLRF   FF7
16D6:  MOVLW  00
16D8:  MOVLB  0
16DA:  CALL   046C
16DE:  TBLRD*-
16E0:  TBLRD*+
16E2:  MOVFF  FF5,FEE
16E6:  DECFSZ 01,F
16E8:  BRA    16E0
16EA:  MOVLB  4
16EC:  BTFSC  x92.7
16EE:  BSF    FF2.7
16F0:  MOVLW  04
16F2:  MOVLB  5
16F4:  MOVWF  x04
16F6:  MOVLW  76
16F8:  MOVWF  x03
16FA:  MOVLW  04
16FC:  MOVWF  x06
16FE:  MOVLW  83
1700:  MOVWF  x05
1702:  MOVLB  0
1704:  CALL   08A4
....................  
....................   while(TRUE){ 
....................  
....................     if(One_Second){ 
1708:  MOVLB  1
170A:  BTFSS  x82.2
170C:  BRA    1716
....................  
....................       One_Second = FALSE; 
170E:  BCF    x82.2
....................       Executar_Cada_Segundo(); 
1710:  MOVLB  0
1712:  BRA    14EC
1714:  MOVLB  1
....................  
....................     } 
....................  
....................     if(One_Minute){ 
1716:  BTFSS  x82.3
1718:  BRA    1724
....................  
....................       One_Minute = FALSE; 
171A:  BCF    x82.3
....................       Executar_Cada_Minuto(); 
171C:  MOVLB  0
171E:  GOTO   0004
1722:  MOVLB  1
....................  
....................     } 
1724:  BRA    170A
....................  
....................   } 
....................  
.................... } 
....................  
1726:  SLEEP 
.................... void Executar_Cada_Segundo(){ 
....................    
....................   if(aquisicao_tensao_partida){ 
*
14EC:  MOVLB  1
14EE:  BTFSS  x82.5
14F0:  BRA    14FC
....................  
....................     aquisicao_tensao_partida = FALSE; 
14F2:  BCF    x82.5
....................     Obtem_SOH(); 
14F4:  MOVLB  0
14F6:  GOTO   09E2
14FA:  MOVLB  1
....................  
....................   } 
....................   if(comando_disponivel_UART){ 
14FC:  BTFSS  x82.0
14FE:  BRA    15A4
....................    
....................     disable_interrupts(GLOBAL); 
1500:  BCF    FF2.6
1502:  BCF    FF2.7
1504:  BTFSC  FF2.7
1506:  BRA    1502
....................     comando = Get_Comando(); 
1508:  MOVLB  0
150A:  CALL   0A2A
150E:  MOVFF  01,1B5
....................      
....................     if(comando != 0){ 
1512:  MOVLB  1
1514:  MOVF   xB5,F
1516:  BZ    1522
....................  
....................       Executa_Comando(comando); 
1518:  MOVFF  1B5,4A1
151C:  MOVLB  0
151E:  RCALL  120C
1520:  MOVLB  1
....................        
....................     } 
....................     if(resposta_SIM == 1){ 
1522:  BTFSS  x82.1
1524:  BRA    159C
....................       disable_interrupts(GLOBAL); 
1526:  BCF    FF2.6
1528:  BCF    FF2.7
152A:  BTFSC  FF2.7
152C:  BRA    1528
....................       resposta_SIM = 0; 
152E:  BCF    x82.1
....................       comando = Get_Comando(); 
1530:  MOVLB  0
1532:  CALL   0A2A
1536:  MOVFF  01,1B5
....................       Executa_Comando(comando); 
153A:  MOVFF  1B5,4A1
153E:  RCALL  120C
....................       delay_ms(100); 
1540:  MOVLW  64
1542:  MOVLB  5
1544:  MOVWF  x51
1546:  MOVLB  0
1548:  CALL   065A
....................       envia_SIM800L("AT+CMGD=1,1\r\n", "OK"); 
154C:  MOVLW  04
154E:  MOVWF  FEA
1550:  MOVLW  90
1552:  MOVWF  FE9
1554:  MOVFF  FF2,4A1
1558:  BCF    FF2.7
155A:  MOVLW  0E
155C:  MOVWF  01
155E:  CLRF   FF7
1560:  MOVLW  00
1562:  CALL   0494
1566:  TBLRD*-
1568:  TBLRD*+
156A:  MOVFF  FF5,FEE
156E:  DECFSZ 01,F
1570:  BRA    1568
1572:  MOVLB  4
1574:  BTFSC  xA1.7
1576:  BSF    FF2.7
1578:  MOVLW  4F
157A:  MOVWF  x9E
157C:  MOVLW  4B
157E:  MOVWF  x9F
1580:  CLRF   xA0
1582:  MOVLW  04
1584:  MOVLB  5
1586:  MOVWF  x47
1588:  MOVLW  90
158A:  MOVWF  x46
158C:  MOVLW  04
158E:  MOVWF  x49
1590:  MOVLW  9E
1592:  MOVWF  x48
1594:  MOVLB  0
1596:  CALL   07B4
159A:  MOVLB  1
....................     } 
....................     comando = 0; 
159C:  CLRF   xB5
....................     clear_command(); 
159E:  MOVLB  0
15A0:  BRA    14AA
15A2:  MOVLB  1
....................   } 
....................    
....................   return; 
15A4:  MOVLB  0
15A6:  GOTO   1714 (RETURN)
.................... } 
....................  
.................... void Executar_Cada_Minuto(){ 
....................    
....................  
....................   return; 
*
0004:  GOTO   1722 (RETURN)
.................... } 
....................  
.................... void Obtem_SOH(){ 
....................   
....................   V1 = 255; 
*
09E2:  MOVLB  4
09E4:  SETF   x74
....................   V2 = 255; 
09E6:  SETF   x75
....................   index = 0; 
09E8:  CLRF   x73
09EA:  CLRF   x72
....................  
....................   for(index=0;index<15;index++){ 
09EC:  CLRF   x73
09EE:  CLRF   x72
09F0:  MOVF   x73,F
09F2:  BNZ   0A24
09F4:  MOVF   x72,W
09F6:  SUBLW  0E
09F8:  BNC   0A24
....................      
....................     if(leitura_tensao[index]<V1) 
09FA:  MOVLW  B6
09FC:  ADDWF  x72,W
09FE:  MOVWF  FE9
0A00:  MOVLW  01
0A02:  ADDWFC x73,W
0A04:  MOVWF  FEA
0A06:  MOVF   x74,W
0A08:  SUBWF  FEF,W
0A0A:  BC    0A1C
....................       V1 = leitura_tensao[index]; 
0A0C:  MOVLW  B6
0A0E:  ADDWF  x72,W
0A10:  MOVWF  FE9
0A12:  MOVLW  01
0A14:  ADDWFC x73,W
0A16:  MOVWF  FEA
0A18:  MOVFF  FEF,474
0A1C:  INCF   x72,F
0A1E:  BTFSC  FD8.2
0A20:  INCF   x73,F
0A22:  BRA    09F0
....................     
....................   } 
....................    
....................  
....................   return; 
0A24:  MOVLB  0
0A26:  GOTO   14FA (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CE3B   PLL4 CPUDIV4 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
