CCS PCH C Compiler, Version 5.015, 5967               21-out-18 11:33

               Filename:   C:\Users\Vitor\Desktop\Monitor_Estado_Baterias\TAI_Bateria.lst

               ROM used:   3654 bytes (11%)
                           Largest free fragment is 29114
               RAM used:   404 (20%) at main() level
                           597 (29%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0CFA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   02CC
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   0394
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... // Projeto Monitor do Estado de Baterias - TAI  
.................... // Data: Setembro de 2018 
....................  
....................  
.................... //******************* Interrupção do Timer 0 / RTCC ************************** 
.................... //   
.................... //  Cristal externo = 16 MHz - Uso de PLL*4 -> Frequencia de trabalho = 16MHz  
.................... //  Prescaler = 1:16 
.................... //  Tout =(4*prescaler* (256-TMR0))/fclk   
.................... //  Para interrupção a cada 1 ms 
.................... //  TMR0 = 6  
.................... //  
.................... //**************************************************************************** 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00A2:  MOVFF  FF2,0D
00A6:  BCF    FF2.7
00A8:  CLRF   FF7
00AA:  ADDLW  BC
00AC:  MOVWF  FF6
00AE:  MOVLW  00
00B0:  ADDWFC FF7,F
00B2:  TBLRD*+
00B4:  MOVF   FF5,W
00B6:  BTFSC  0D.7
00B8:  BSF    FF2.7
00BA:  RETURN 0
00BC:  DATA 2B,43
00BE:  DATA 4D,54
00C0:  DATA 49,00
00C2:  MOVFF  FF2,0D
00C6:  BCF    FF2.7
00C8:  CLRF   FF7
00CA:  ADDLW  DC
00CC:  MOVWF  FF6
00CE:  MOVLW  00
00D0:  ADDWFC FF7,F
00D2:  TBLRD*+
00D4:  MOVF   FF5,W
00D6:  BTFSC  0D.7
00D8:  BSF    FF2.7
00DA:  RETURN 0
00DC:  DATA 2B,43
00DE:  DATA 4D,47
00E0:  DATA 4C,00
00E2:  MOVFF  FF2,0D
00E6:  BCF    FF2.7
00E8:  CLRF   FF7
00EA:  ADDLW  FC
00EC:  MOVWF  FF6
00EE:  MOVLW  00
00F0:  ADDWFC FF7,F
00F2:  TBLRD*+
00F4:  MOVF   FF5,W
00F6:  BTFSC  0D.7
00F8:  BSF    FF2.7
00FA:  RETURN 0
00FC:  DATA 4F,49
00FE:  DATA 54,41
0100:  DATA 49,00
0102:  MOVFF  FF2,0D
0106:  BCF    FF2.7
0108:  CLRF   FF7
010A:  ADDLW  1C
010C:  MOVWF  FF6
010E:  MOVLW  01
0110:  ADDWFC FF7,F
0112:  TBLRD*+
0114:  MOVF   FF5,W
0116:  BTFSC  0D.7
0118:  BSF    FF2.7
011A:  RETURN 0
011C:  DATA 48,45
011E:  DATA 41,52
0120:  DATA 54,42
0122:  DATA 45,41
0124:  DATA 54,28
0126:  DATA 29,00
0128:  MOVFF  FF2,0D
012C:  BCF    FF2.7
012E:  CLRF   FF7
0130:  ADDLW  42
0132:  MOVWF  FF6
0134:  MOVLW  01
0136:  ADDWFC FF7,F
0138:  TBLRD*+
013A:  MOVF   FF5,W
013C:  BTFSC  0D.7
013E:  BSF    FF2.7
0140:  RETURN 0
0142:  DATA 2B,4E
0144:  DATA 55,4D
0146:  DATA 41,44
0148:  DATA 44,00
014A:  MOVFF  FF2,0D
014E:  BCF    FF2.7
0150:  CLRF   FF7
0152:  ADDLW  64
0154:  MOVWF  FF6
0156:  MOVLW  01
0158:  ADDWFC FF7,F
015A:  TBLRD*+
015C:  MOVF   FF5,W
015E:  BTFSC  0D.7
0160:  BSF    FF2.7
0162:  RETURN 0
0164:  DATA 2B,4E
0166:  DATA 55,4D
0168:  DATA 44,45
016A:  DATA 4C,00
016C:  MOVFF  FF2,0D
0170:  BCF    FF2.7
0172:  CLRF   FF7
0174:  ADDLW  86
0176:  MOVWF  FF6
0178:  MOVLW  01
017A:  ADDWFC FF7,F
017C:  TBLRD*+
017E:  MOVF   FF5,W
0180:  BTFSC  0D.7
0182:  BSF    FF2.7
0184:  RETURN 0
0186:  DATA 4F,4B
0188:  DATA 20,43
018A:  DATA 4C,45
018C:  DATA 41,52
018E:  DATA 20,41
0190:  DATA 4C,4C
0192:  DATA 00,00
0194:  MOVFF  FF2,0D
0198:  BCF    FF2.7
019A:  CLRF   FF7
019C:  ADDLW  AE
019E:  MOVWF  FF6
01A0:  MOVLW  01
01A2:  ADDWFC FF7,F
01A4:  TBLRD*+
01A6:  MOVF   FF5,W
01A8:  BTFSC  0D.7
01AA:  BSF    FF2.7
01AC:  RETURN 0
01AE:  DATA 41,54
01B0:  DATA 2B,43
01B2:  DATA 4D,47
01B4:  DATA 46,3D
01B6:  DATA 31,0D
01B8:  DATA 0A,00
01BA:  MOVFF  FF2,0D
01BE:  BCF    FF2.7
01C0:  CLRF   FF7
01C2:  ADDLW  D4
01C4:  MOVWF  FF6
01C6:  MOVLW  01
01C8:  ADDWFC FF7,F
01CA:  TBLRD*+
01CC:  MOVF   FF5,W
01CE:  BTFSC  0D.7
01D0:  BSF    FF2.7
01D2:  RETURN 0
01D4:  DATA 41,54
01D6:  DATA 2B,43
01D8:  DATA 53,4D
01DA:  DATA 50,3D
01DC:  DATA 31,37
01DE:  DATA 2C,32
01E0:  DATA 35,35
01E2:  DATA 2C,30
01E4:  DATA 2C,30
01E6:  DATA 0D,0A
01E8:  DATA 00,00
01EA:  MOVFF  FF2,0D
01EE:  BCF    FF2.7
01F0:  CLRF   FF7
01F2:  ADDLW  04
01F4:  MOVWF  FF6
01F6:  MOVLW  02
01F8:  ADDWFC FF7,F
01FA:  TBLRD*+
01FC:  MOVF   FF5,W
01FE:  BTFSC  0D.7
0200:  BSF    FF2.7
0202:  RETURN 0
0204:  DATA 2B,43
0206:  DATA 4D,47
0208:  DATA 53,3A
020A:  DATA 00,00
020C:  MOVFF  FF2,0D
0210:  BCF    FF2.7
0212:  CLRF   FF7
0214:  ADDLW  26
0216:  MOVWF  FF6
0218:  MOVLW  02
021A:  ADDWFC FF7,F
021C:  TBLRD*+
021E:  MOVF   FF5,W
0220:  BTFSC  0D.7
0222:  BSF    FF2.7
0224:  RETURN 0
0226:  DATA 41,54
0228:  DATA 2B,43
022A:  DATA 4D,47
022C:  DATA 4C,3D
022E:  DATA 22,52
0230:  DATA 45,43
0232:  DATA 20,55
0234:  DATA 4E,52
0236:  DATA 45,41
0238:  DATA 44,22
023A:  DATA 0D,0A
023C:  DATA 00,00
023E:  MOVFF  FF2,0D
0242:  BCF    FF2.7
0244:  CLRF   FF7
0246:  ADDLW  58
0248:  MOVWF  FF6
024A:  MOVLW  02
024C:  ADDWFC FF7,F
024E:  TBLRD*+
0250:  MOVF   FF5,W
0252:  BTFSC  0D.7
0254:  BSF    FF2.7
0256:  RETURN 0
0258:  DATA 30,33
025A:  DATA 31,39
025C:  DATA 39,35
025E:  DATA 38,32
0260:  DATA 32,37
0262:  DATA 33,39
0264:  DATA 00,00
0266:  MOVFF  FF2,0D
026A:  BCF    FF2.7
026C:  CLRF   FF7
026E:  ADDLW  80
0270:  MOVWF  FF6
0272:  MOVLW  02
0274:  ADDWFC FF7,F
0276:  TBLRD*+
0278:  MOVF   FF5,W
027A:  BTFSC  0D.7
027C:  BSF    FF2.7
027E:  RETURN 0
0280:  DATA 49,4E
0282:  DATA 49,43
0284:  DATA 49,41
0286:  DATA 4E,44
0288:  DATA 4F,2E
028A:  DATA 2E,2E
028C:  DATA 00,00
028E:  MOVFF  FF2,0D
0292:  BCF    FF2.7
0294:  CLRF   FF7
0296:  ADDLW  A8
0298:  MOVWF  FF6
029A:  MOVLW  02
029C:  ADDWFC FF7,F
029E:  TBLRD*+
02A0:  MOVF   FF5,W
02A2:  BTFSC  0D.7
02A4:  BSF    FF2.7
02A6:  RETURN 0
02A8:  DATA 41,54
02AA:  DATA 2B,43
02AC:  DATA 4D,47
02AE:  DATA 44,3D
02B0:  DATA 31,2C
02B2:  DATA 31,0D
02B4:  DATA 0A,00
*
0384:  DATA 41,54
0386:  DATA 2B,43
0388:  DATA 4D,47
038A:  DATA 53,3D
038C:  DATA 22,25
038E:  DATA 73,22
0390:  DATA 0D,0A
0392:  DATA 00,00
*
03FE:  MOVFF  188,FEA
0402:  MOVFF  187,FE9
0406:  MOVLB  2
0408:  MOVFF  23A,FEF
040C:  INCF   FE9,F
040E:  BTFSC  FD8.2
0410:  INCF   FEA,F
0412:  CLRF   FEF
0414:  MOVLB  1
0416:  INCF   x87,F
0418:  BTFSC  FD8.2
041A:  INCF   x88,F
041C:  MOVLB  0
041E:  RETURN 0
0420:  TBLRD*+
0422:  MOVFF  FF6,238
0426:  MOVFF  FF7,239
042A:  MOVFF  FF5,23A
042E:  RCALL  03FE
0430:  MOVFF  238,FF6
0434:  MOVFF  239,FF7
0438:  MOVLB  2
043A:  DECFSZ x37,F
043C:  BRA    0440
043E:  BRA    0444
0440:  MOVLB  0
0442:  BRA    0420
0444:  MOVLB  0
0446:  RETURN 0
0448:  MOVF   FEF,F
044A:  BZ    046A
044C:  MOVFF  FEA,238
0450:  MOVFF  FE9,237
0454:  MOVFF  FEF,23A
0458:  RCALL  03FE
045A:  MOVFF  238,FEA
045E:  MOVFF  237,FE9
0462:  INCF   FE9,F
0464:  BTFSC  FD8.2
0466:  INCF   FEA,F
0468:  BRA    0448
046A:  GOTO   0644 (RETURN)
046E:  MOVF   FEF,F
0470:  BZ    0492
0472:  MOVFF  FEA,247
0476:  MOVFF  FE9,246
047A:  MOVF   FEF,W
047C:  BTFSS  F9E.4
047E:  BRA    047C
0480:  MOVWF  FAD
0482:  MOVFF  247,FEA
0486:  MOVFF  246,FE9
048A:  INCF   FE9,F
048C:  BTFSC  FD8.2
048E:  INCF   FEA,F
0490:  BRA    046E
0492:  GOTO   055A (RETURN)
*
09D4:  TSTFSZ 01
09D6:  BRA    09DE
09D8:  TSTFSZ 02
09DA:  BRA    09E0
09DC:  BRA    09EC
09DE:  INCF   02,F
09E0:  MOVFF  00,FEE
09E4:  DECFSZ 01,F
09E6:  BRA    09E0
09E8:  DECFSZ 02,F
09EA:  BRA    09E0
09EC:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,NOPROTECT,NOLVP,MCLR,HSPLL,PLL4 
.................... #device PASS_STRINGS=IN_RAM 
.................... #use delay(clock=16000000) 
*
03D4:  MOVLW  02
03D6:  MOVWF  FEA
03D8:  MOVLW  46
03DA:  MOVWF  FE9
03DC:  MOVF   FEF,W
03DE:  BZ    03FC
03E0:  MOVLW  05
03E2:  MOVWF  01
03E4:  CLRF   00
03E6:  DECFSZ 00,F
03E8:  BRA    03E6
03EA:  DECFSZ 01,F
03EC:  BRA    03E4
03EE:  MOVLW  2E
03F0:  MOVWF  00
03F2:  DECFSZ 00,F
03F4:  BRA    03F2
03F6:  BRA    03F8
03F8:  DECFSZ FEF,F
03FA:  BRA    03E0
03FC:  RETURN 0
.................... #use rs232(uart1,baud=115200, xmit=PIN_C6, rcv=PIN_C7, stream = SIM800L_SERIAL, ERRORS) 
*
02B6:  BTFSS  F9E.5
02B8:  BRA    02B6
02BA:  MOVFF  FAB,16
02BE:  MOVFF  FAE,01
02C2:  BTFSS  16.1
02C4:  BRA    02CA
02C6:  BCF    FAB.4
02C8:  BSF    FAB.4
02CA:  RETURN 0
*
0524:  BTFSS  F9E.4
0526:  BRA    0524
0528:  MOVWF  FAD
052A:  GOTO   05A4 (RETURN)
.................... #use fast_io (ALL) 
.................... #priority rda, rtcc, 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0496:  MOVFF  249,03
049A:  MOVLB  2
049C:  MOVFF  248,FE9
04A0:  MOVFF  249,FEA
04A4:  MOVF   FEF,F
04A6:  BZ    051A
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
04A8:  MOVFF  249,24D
04AC:  MOVFF  248,24C
04B0:  MOVFF  24B,24F
04B4:  MOVFF  24A,24E
04B8:  MOVFF  24F,03
04BC:  MOVFF  24E,FE9
04C0:  MOVFF  24F,FEA
04C4:  MOVF   FEF,F
04C6:  BZ    04F4
04C8:  MOVFF  24C,FE9
04CC:  MOVFF  24D,FEA
04D0:  MOVFF  FEF,250
04D4:  MOVFF  24F,03
04D8:  MOVFF  24E,FE9
04DC:  MOVFF  24F,FEA
04E0:  MOVF   FEF,W
04E2:  SUBWF  x50,W
04E4:  BNZ   04F4
04E6:  INCF   x4C,F
04E8:  BTFSC  FD8.2
04EA:  INCF   x4D,F
04EC:  INCF   x4E,F
04EE:  BTFSC  FD8.2
04F0:  INCF   x4F,F
04F2:  BRA    04B8
....................  
....................       if (*t == '\0') 
04F4:  MOVFF  24F,03
04F8:  MOVFF  24E,FE9
04FC:  MOVFF  03,FEA
0500:  MOVF   FEF,F
0502:  BNZ   050E
....................          return s1; 
0504:  MOVFF  248,01
0508:  MOVFF  249,02
050C:  BRA    0520
....................       ++s1; 
050E:  INCF   x48,F
0510:  BTFSC  FD8.2
0512:  INCF   x49,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0514:  MOVLB  0
0516:  BRA    0496
0518:  MOVLB  2
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
051A:  MOVLW  00
051C:  MOVWF  01
051E:  MOVWF  02
0520:  MOVLB  0
0522:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
....................  
.................... #ENDIF 
....................  
.................... #include "SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
....................  
.................... #include "SIM800L.c" 
.................... #include"Serial.h" 
.................... #IFNDEF SERIAL_H 
.................... #DEFINE SERIAL_H 
....................  
.................... #define  SMS_COMMAND             1 
.................... #define  SMS_READ_COMMAND        2            
....................  
.................... void Executa_Comando(char comando); 
.................... char Get_Comando(); 
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao); 
.................... void get_numero(int nro_caracteres, int posicao, char *destino); 
.................... void clear_command(); 
....................  
.................... #include"Serial.c" 
.................... #include"SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
....................  
.................... #include "SIM800L.c" 
....................  
.................... #ENDIF 
....................  
.................... #include"TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
....................  
.................... #ENDIF 
....................  
.................... #include"numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
....................  
.................... #include"numeros.c" 
.................... char numeros[50]; 
.................... int8 qtd_numeros=0; 
.................... char *posicao_numero; 
....................  
.................... int1 insere_numero(char *numero){ // >+5531995822739>+5531995822739>+5531995822739 
*
0914:  MOVF   4F,W
0916:  MULLW  0F
0918:  MOVFF  FF3,1F8
091C:  MOVLB  1
091E:  CLRF   xF9
....................   
....................   int8 index = qtd_numeros*15; 
....................   int8 index_2 = 0; 
....................  
....................   if(qtd_numeros == 3){ 
0920:  MOVF   4F,W
0922:  SUBLW  03
0924:  BNZ   092C
....................  
....................     return 0; 
0926:  MOVLW  00
0928:  MOVWF  01
092A:  BRA    09CE
....................  
....................   } 
....................  
....................   posicao_numero = strstr(numeros,numero); 
092C:  MOVLB  2
092E:  CLRF   x49
0930:  MOVLW  1D
0932:  MOVWF  x48
0934:  MOVFF  1F7,24B
0938:  MOVFF  1F6,24A
093C:  MOVLB  0
093E:  RCALL  0496
0940:  MOVFF  02,51
0944:  MOVFF  01,50
....................    
....................   if(posicao_numero == 0){ 
0948:  MOVF   50,F
094A:  BNZ   09C8
094C:  MOVF   51,F
094E:  BNZ   09C8
....................  
....................     numeros[index] ='>'; 
0950:  CLRF   03
0952:  MOVLB  1
0954:  MOVF   xF8,W
0956:  ADDLW  1D
0958:  MOVWF  FE9
095A:  MOVLW  00
095C:  ADDWFC 03,W
095E:  MOVWF  FEA
0960:  MOVLW  3E
0962:  MOVWF  FEF
....................      
....................     for(index = index+1;numero[index_2]!='\0';index++){ 
0964:  MOVLW  01
0966:  ADDWF  xF8,F
0968:  CLRF   03
096A:  MOVF   xF9,W
096C:  ADDWF  xF6,W
096E:  MOVWF  FE9
0970:  MOVF   xF7,W
0972:  ADDWFC 03,W
0974:  MOVWF  FEA
0976:  MOVF   FEF,F
0978:  BZ    09AE
....................       
....................       numeros[index] = numero[index_2]; 
097A:  CLRF   03
097C:  MOVF   xF8,W
097E:  ADDLW  1D
0980:  MOVWF  01
0982:  MOVLW  00
0984:  ADDWFC 03,F
0986:  MOVFF  03,1FB
098A:  CLRF   03
098C:  MOVF   xF9,W
098E:  ADDWF  xF6,W
0990:  MOVWF  FE9
0992:  MOVF   xF7,W
0994:  ADDWFC 03,W
0996:  MOVWF  FEA
0998:  MOVFF  FEF,1FC
099C:  MOVFF  1FB,FEA
09A0:  MOVFF  01,FE9
09A4:  MOVFF  1FC,FEF
....................       index_2++; 
09A8:  INCF   xF9,F
09AA:  INCF   xF8,F
09AC:  BRA    0968
....................         
....................     } 
....................     numeros[index]='\0'; 
09AE:  CLRF   03
09B0:  MOVF   xF8,W
09B2:  ADDLW  1D
09B4:  MOVWF  FE9
09B6:  MOVLW  00
09B8:  ADDWFC 03,W
09BA:  MOVWF  FEA
09BC:  CLRF   FEF
....................     qtd_numeros++; 
09BE:  INCF   4F,F
....................     return 1; 
09C0:  MOVLW  01
09C2:  MOVWF  01
09C4:  BRA    09CE
09C6:  MOVLB  0
....................    
....................   } 
....................   return 0; 
09C8:  MOVLW  00
09CA:  MOVWF  01
09CC:  MOVLB  1
09CE:  MOVLB  0
09D0:  GOTO   0B34 (RETURN)
.................... } 
....................  
....................  
.................... void limpa_numeros(){ 
....................  
....................   qtd_numeros = 0; 
*
09EE:  CLRF   4F
....................   memset (numeros, 0x00, sizeof(numeros)); 
09F0:  CLRF   FEA
09F2:  MOVLW  1D
09F4:  MOVWF  FE9
09F6:  CLRF   00
09F8:  CLRF   02
09FA:  MOVLW  32
09FC:  MOVWF  01
09FE:  RCALL  09D4
0A00:  GOTO   0BB4 (RETURN)
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define   UART_BUFFER_SIZE         150 
....................  
.................... char comando_recibido_UART[UART_BUFFER_SIZE]; 
.................... char comando_recibido_BUFF [UART_BUFFER_SIZE]; 
.................... int *posicao_valor_comando = 0; 
.................... int16 timeout_trama_UART = 100000; 
.................... extern int1 comando_disponivel_UART; 
....................  
.................... #INT_RDA  
.................... void recepcao_UART() 
*
02CC:  MOVLW  01
02CE:  MOVLB  2
02D0:  MOVWF  x51
.................... { 
....................  int i = 1; 
....................  int8 caracterRx; 
....................    if(kbhit(SIM800L_SERIAL) && comando_disponivel_UART == 0) { 
02D2:  BTFSS  F9E.5
02D4:  BRA    037C
02D6:  MOVLB  1
02D8:  BTFSS  x82.0
02DA:  BRA    02E0
02DC:  MOVLB  2
02DE:  BRA    037C
....................       caracterRx = getc(SIM800L_SERIAL); 
02E0:  MOVLB  0
02E2:  RCALL  02B6
02E4:  MOVFF  01,252
....................       if(caracterRx == '>'||caracterRx == '+' ||caracterRx =='\n'||caracterRx =='\r') { 
02E8:  MOVLB  2
02EA:  MOVF   x52,W
02EC:  SUBLW  3E
02EE:  BZ    0302
02F0:  MOVF   x52,W
02F2:  SUBLW  2B
02F4:  BZ    0302
02F6:  MOVF   x52,W
02F8:  SUBLW  0A
02FA:  BZ    0302
02FC:  MOVF   x52,W
02FE:  SUBLW  0D
0300:  BNZ   037C
....................         comando_recibido_UART[0] = caracterRx; 
0302:  MOVFF  252,52
....................         while(i < (UART_BUFFER_SIZE-2) && timeout_trama_UART > 0) { 
0306:  MOVF   x51,W
0308:  SUBLW  93
030A:  BNC   035E
030C:  MOVLB  1
030E:  MOVF   x80,F
0310:  BNZ   031C
0312:  MOVF   x81,F
0314:  BTFSS  FD8.2
0316:  BRA    031C
0318:  MOVLB  2
031A:  BRA    035E
....................            if(kbhit(SIM800L_SERIAL)) { 
031C:  BTFSS  F9E.5
031E:  BRA    0352
....................              caracterRx = getc(SIM800L_SERIAL); 
0320:  MOVLB  0
0322:  RCALL  02B6
0324:  MOVFF  01,252
....................              comando_recibido_UART[i] = caracterRx; 
0328:  CLRF   03
032A:  MOVLB  2
032C:  MOVF   x51,W
032E:  ADDLW  52
0330:  MOVWF  FE9
0332:  MOVLW  00
0334:  ADDWFC 03,W
0336:  MOVWF  FEA
0338:  MOVFF  252,FEF
....................              if(caracterRx == ';') {  
033C:  MOVF   x52,W
033E:  SUBLW  3B
0340:  BNZ   0346
....................                i++; 
0342:  INCF   x51,F
....................                break; 
0344:  BRA    035E
....................              } 
....................              i++; 
0346:  INCF   x51,F
....................              timeout_trama_UART = 100000; 
0348:  MOVLW  86
034A:  MOVLB  1
034C:  MOVWF  x81
034E:  MOVLW  A0
0350:  MOVWF  x80
....................            } 
....................            timeout_trama_UART--; 
0352:  MOVF   x80,W
0354:  BTFSC  FD8.2
0356:  DECF   x81,F
0358:  DECF   x80,F
035A:  MOVLB  2
035C:  BRA    0306
....................         } 
....................         comando_disponivel_UART = 1; 
035E:  MOVLB  1
0360:  BSF    x82.0
....................         timeout_trama_UART = 100000; 
0362:  MOVLW  86
0364:  MOVWF  x81
0366:  MOVLW  A0
0368:  MOVWF  x80
....................         comando_recibido_UART[i] = 0; 
036A:  CLRF   03
036C:  MOVLB  2
036E:  MOVF   x51,W
0370:  ADDLW  52
0372:  MOVWF  FE9
0374:  MOVLW  00
0376:  ADDWFC 03,W
0378:  MOVWF  FEA
037A:  CLRF   FEF
....................       } 
....................    } 
....................   return; 
037C:  BCF    F9E.5
037E:  MOVLB  0
0380:  GOTO   0060
.................... } 
....................  
.................... char Get_Comando() 
.................... { 
....................   char CMD[15]; 
....................   strcpy (comando_recibido_BUFF, comando_recibido_UART);                            
*
075C:  CLRF   FEA
075E:  MOVLW  E8
0760:  MOVWF  FE9
0762:  CLRF   FE2
0764:  MOVLW  52
0766:  MOVWF  FE1
0768:  MOVF   FE7,F
076A:  MOVFF  FE6,FEE
076E:  BNZ   0768
....................   strcpy (CMD, "+CMTI"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_COMMAND); 
0770:  MOVLW  01
0772:  MOVWF  FEA
0774:  MOVLW  B9
0776:  MOVWF  FE9
0778:  MOVFF  FF2,1C8
077C:  BCF    FF2.7
077E:  MOVLW  00
0780:  RCALL  00A2
0782:  TBLRD*-
0784:  TBLRD*+
0786:  MOVF   FF5,W
0788:  MOVWF  FEE
078A:  IORLW  00
078C:  BNZ   0784
078E:  MOVLB  1
0790:  BTFSC  xC8.7
0792:  BSF    FF2.7
0794:  MOVLB  2
0796:  CLRF   x49
0798:  MOVLW  E8
079A:  MOVWF  x48
079C:  MOVLW  01
079E:  MOVWF  x4B
07A0:  MOVLW  B9
07A2:  MOVWF  x4A
07A4:  MOVLB  0
07A6:  RCALL  0496
07A8:  MOVFF  02,17F
07AC:  MOVFF  01,17E
07B0:  MOVLB  1
07B2:  MOVF   x7E,F
07B4:  BNZ   07BA
07B6:  MOVF   x7F,F
07B8:  BZ    07C0
07BA:  MOVLW  01
07BC:  MOVWF  01
07BE:  BRA    0816
....................   strcpy (CMD, "+CMGL"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_READ_COMMAND); 
07C0:  MOVLW  01
07C2:  MOVWF  FEA
07C4:  MOVLW  B9
07C6:  MOVWF  FE9
07C8:  MOVFF  FF2,1C8
07CC:  BCF    FF2.7
07CE:  MOVLW  00
07D0:  MOVLB  0
07D2:  RCALL  00C2
07D4:  TBLRD*-
07D6:  TBLRD*+
07D8:  MOVF   FF5,W
07DA:  MOVWF  FEE
07DC:  IORLW  00
07DE:  BNZ   07D6
07E0:  MOVLB  1
07E2:  BTFSC  xC8.7
07E4:  BSF    FF2.7
07E6:  MOVLB  2
07E8:  CLRF   x49
07EA:  MOVLW  E8
07EC:  MOVWF  x48
07EE:  MOVLW  01
07F0:  MOVWF  x4B
07F2:  MOVLW  B9
07F4:  MOVWF  x4A
07F6:  MOVLB  0
07F8:  RCALL  0496
07FA:  MOVFF  02,17F
07FE:  MOVFF  01,17E
0802:  MOVLB  1
0804:  MOVF   x7E,F
0806:  BNZ   080C
0808:  MOVF   x7F,F
080A:  BZ    0812
080C:  MOVLW  02
080E:  MOVWF  01
0810:  BRA    0816
....................  
....................   return(0); 
0812:  MOVLW  00
0814:  MOVWF  01
0816:  MOVLB  0
0818:  RETURN 0
.................... } 
....................  
....................  
.................... void Executa_Comando(char comando){ 
....................  
....................   char CMD[15]; 
....................   char numero[20]; 
....................   disable_interrupts(GLOBAL); 
*
0A04:  BCF    FF2.6
0A06:  BCF    FF2.7
0A08:  BTFSC  FF2.7
0A0A:  BRA    0A06
....................    
....................   switch(comando){ 
0A0C:  MOVLB  1
0A0E:  MOVF   xB9,W
0A10:  XORLW  01
0A12:  MOVLB  0
0A14:  BZ    0A1C
0A16:  XORLW  03
0A18:  BZ    0A20
0A1A:  BRA    0C10
....................       
....................     case SMS_COMMAND:       //+CMTI: "SM",10<CR><LF> 
....................       Read_SMS(); 
0A1C:  BRA    081A
....................     break; 
0A1E:  BRA    0C10
....................  
....................     case SMS_READ_COMMAND:  //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/13,21:57:54-12"<CR><LF> 
....................  
....................       strcpy (CMD, "OITAI");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); 
0A20:  MOVLW  01
0A22:  MOVWF  FEA
0A24:  MOVLW  BA
0A26:  MOVWF  FE9
0A28:  MOVFF  FF2,1F6
0A2C:  BCF    FF2.7
0A2E:  MOVLW  00
0A30:  CALL   00E2
0A34:  TBLRD*-
0A36:  TBLRD*+
0A38:  MOVF   FF5,W
0A3A:  MOVWF  FEE
0A3C:  IORLW  00
0A3E:  BNZ   0A36
0A40:  MOVLB  1
0A42:  BTFSC  xF6.7
0A44:  BSF    FF2.7
0A46:  MOVLB  2
0A48:  CLRF   x49
0A4A:  MOVLW  E8
0A4C:  MOVWF  x48
0A4E:  MOVLW  01
0A50:  MOVWF  x4B
0A52:  MOVLW  BA
0A54:  MOVWF  x4A
0A56:  MOVLB  0
0A58:  RCALL  0496
0A5A:  MOVFF  02,17F
0A5E:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
0A62:  MOVLB  1
0A64:  MOVF   x7E,F
0A66:  BNZ   0A6C
0A68:  MOVF   x7F,F
0A6A:  BZ    0AC4
....................  
....................         get_numero(14,25,numero); 
0A6C:  MOVLW  0E
0A6E:  MOVWF  xF6
0A70:  MOVLW  19
0A72:  MOVWF  xF7
0A74:  MOVLW  01
0A76:  MOVWF  xF9
0A78:  MOVLW  C9
0A7A:  MOVWF  xF8
0A7C:  MOVLB  0
0A7E:  RCALL  08C0
....................         Send_SMS(numero,"HEARTBEAT()"); 
0A80:  MOVLW  01
0A82:  MOVWF  FEA
0A84:  MOVLW  DD
0A86:  MOVWF  FE9
0A88:  MOVFF  FF2,1F6
0A8C:  BCF    FF2.7
0A8E:  MOVLW  0C
0A90:  MOVWF  01
0A92:  CLRF   FF7
0A94:  MOVLW  00
0A96:  CALL   0102
0A9A:  TBLRD*-
0A9C:  TBLRD*+
0A9E:  MOVFF  FF5,FEE
0AA2:  DECFSZ 01,F
0AA4:  BRA    0A9C
0AA6:  MOVLB  1
0AA8:  BTFSC  xF6.7
0AAA:  BSF    FF2.7
0AAC:  MOVLW  01
0AAE:  MOVWF  xF9
0AB0:  MOVLW  C9
0AB2:  MOVWF  xF8
0AB4:  MOVLW  01
0AB6:  MOVWF  xFB
0AB8:  MOVLW  DD
0ABA:  MOVWF  xFA
0ABC:  MOVLB  0
0ABE:  RCALL  061E
....................         break; 
0AC0:  BRA    0C10
0AC2:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMADD");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/14,00:28:46-12"nr+NUMADD+5531995422738<CR><LF> 
0AC4:  MOVLW  01
0AC6:  MOVWF  FEA
0AC8:  MOVLW  BA
0ACA:  MOVWF  FE9
0ACC:  MOVFF  FF2,1F6
0AD0:  BCF    FF2.7
0AD2:  MOVLW  00
0AD4:  MOVLB  0
0AD6:  CALL   0128
0ADA:  TBLRD*-
0ADC:  TBLRD*+
0ADE:  MOVF   FF5,W
0AE0:  MOVWF  FEE
0AE2:  IORLW  00
0AE4:  BNZ   0ADC
0AE6:  MOVLB  1
0AE8:  BTFSC  xF6.7
0AEA:  BSF    FF2.7
0AEC:  MOVLB  2
0AEE:  CLRF   x49
0AF0:  MOVLW  E8
0AF2:  MOVWF  x48
0AF4:  MOVLW  01
0AF6:  MOVWF  x4B
0AF8:  MOVLW  BA
0AFA:  MOVWF  x4A
0AFC:  MOVLB  0
0AFE:  RCALL  0496
0B00:  MOVFF  02,17F
0B04:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
0B08:  MOVLB  1
0B0A:  MOVF   x7E,F
0B0C:  BNZ   0B12
0B0E:  MOVF   x7F,F
0B10:  BZ    0B62
....................          
....................         get_numero(14,75,numero); 
0B12:  MOVLW  0E
0B14:  MOVWF  xF6
0B16:  MOVLW  4B
0B18:  MOVWF  xF7
0B1A:  MOVLW  01
0B1C:  MOVWF  xF9
0B1E:  MOVLW  C9
0B20:  MOVWF  xF8
0B22:  MOVLB  0
0B24:  RCALL  08C0
....................         insere_numero(numero); 
0B26:  MOVLW  01
0B28:  MOVLB  1
0B2A:  MOVWF  xF7
0B2C:  MOVLW  C9
0B2E:  MOVWF  xF6
0B30:  MOVLB  0
0B32:  BRA    0914
....................         get_numero(14,25,numero); 
0B34:  MOVLW  0E
0B36:  MOVLB  1
0B38:  MOVWF  xF6
0B3A:  MOVLW  19
0B3C:  MOVWF  xF7
0B3E:  MOVLW  01
0B40:  MOVWF  xF9
0B42:  MOVLW  C9
0B44:  MOVWF  xF8
0B46:  MOVLB  0
0B48:  RCALL  08C0
....................         Send_SMS(numero,numeros); 
0B4A:  MOVLW  01
0B4C:  MOVLB  1
0B4E:  MOVWF  xF9
0B50:  MOVLW  C9
0B52:  MOVWF  xF8
0B54:  CLRF   xFB
0B56:  MOVLW  1D
0B58:  MOVWF  xFA
0B5A:  MOVLB  0
0B5C:  RCALL  061E
....................         break; 
0B5E:  BRA    0C10
0B60:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMDEL");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+NUMDEL 
0B62:  MOVLW  01
0B64:  MOVWF  FEA
0B66:  MOVLW  BA
0B68:  MOVWF  FE9
0B6A:  MOVFF  FF2,1F6
0B6E:  BCF    FF2.7
0B70:  MOVLW  00
0B72:  MOVLB  0
0B74:  CALL   014A
0B78:  TBLRD*-
0B7A:  TBLRD*+
0B7C:  MOVF   FF5,W
0B7E:  MOVWF  FEE
0B80:  IORLW  00
0B82:  BNZ   0B7A
0B84:  MOVLB  1
0B86:  BTFSC  xF6.7
0B88:  BSF    FF2.7
0B8A:  MOVLB  2
0B8C:  CLRF   x49
0B8E:  MOVLW  E8
0B90:  MOVWF  x48
0B92:  MOVLW  01
0B94:  MOVWF  x4B
0B96:  MOVLW  BA
0B98:  MOVWF  x4A
0B9A:  MOVLB  0
0B9C:  RCALL  0496
0B9E:  MOVFF  02,17F
0BA2:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
0BA6:  MOVLB  1
0BA8:  MOVF   x7E,F
0BAA:  BNZ   0BB0
0BAC:  MOVF   x7F,F
0BAE:  BZ    0C0E
....................           
....................         limpa_numeros();  
0BB0:  MOVLB  0
0BB2:  BRA    09EE
....................         get_numero(14,25,numero); 
0BB4:  MOVLW  0E
0BB6:  MOVLB  1
0BB8:  MOVWF  xF6
0BBA:  MOVLW  19
0BBC:  MOVWF  xF7
0BBE:  MOVLW  01
0BC0:  MOVWF  xF9
0BC2:  MOVLW  C9
0BC4:  MOVWF  xF8
0BC6:  MOVLB  0
0BC8:  RCALL  08C0
....................         Send_SMS(numero,"OK CLEAR ALL"); 
0BCA:  MOVLW  01
0BCC:  MOVWF  FEA
0BCE:  MOVLW  E9
0BD0:  MOVWF  FE9
0BD2:  MOVFF  FF2,1F6
0BD6:  BCF    FF2.7
0BD8:  MOVLW  0D
0BDA:  MOVWF  01
0BDC:  CLRF   FF7
0BDE:  MOVLW  00
0BE0:  CALL   016C
0BE4:  TBLRD*-
0BE6:  TBLRD*+
0BE8:  MOVFF  FF5,FEE
0BEC:  DECFSZ 01,F
0BEE:  BRA    0BE6
0BF0:  MOVLB  1
0BF2:  BTFSC  xF6.7
0BF4:  BSF    FF2.7
0BF6:  MOVLW  01
0BF8:  MOVWF  xF9
0BFA:  MOVLW  C9
0BFC:  MOVWF  xF8
0BFE:  MOVLW  01
0C00:  MOVWF  xFB
0C02:  MOVLW  E9
0C04:  MOVWF  xFA
0C06:  MOVLB  0
0C08:  RCALL  061E
....................         break; 
0C0A:  BRA    0C10
0C0C:  MOVLB  1
....................       } 
....................           
....................     break; 
0C0E:  MOVLB  0
....................  
....................  
....................   } 
....................  
....................   return; 
0C10:  RETURN 0
....................  
.................... } 
....................  
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao) //get_value(posicao_valor_comando,3,6); 
.................... { 
....................   int32 valor = 0; 
....................   int i = 0; 
....................   int32 aux = 1; 
....................   int potencia = 0; 
....................  
....................   while(nro_caracteres > 0) 
....................   { 
....................     if( pointer_to_string[posicao+i] != '.' ) 
....................     { 
....................       nro_caracteres--; 
....................       potencia = nro_caracteres; 
....................       aux = 1; 
....................       while(potencia > 0) 
....................       { 
....................         aux = aux * 10; 
....................         potencia--; 
....................       } 
....................       valor = valor + ((int32)(pointer_to_string[posicao+i]-48)*aux); 
....................     } 
....................     i++; 
....................   } 
....................  
....................   return(valor); 
.................... } 
....................  
.................... void get_numero(int nro_caracteres, int posicao, char *destino){ 
*
08C0:  MOVLB  1
08C2:  CLRF   xFA
....................  
....................   int8 index = 0; 
....................  
....................   for(index = 0;index< nro_caracteres;index++){ 
08C4:  CLRF   xFA
08C6:  MOVF   xF6,W
08C8:  SUBWF  xFA,W
08CA:  BC    0900
....................  
....................     destino[index] = comando_recibido_BUFF[index+posicao]; 
08CC:  CLRF   03
08CE:  MOVF   xFA,W
08D0:  ADDWF  xF8,W
08D2:  MOVWF  01
08D4:  MOVF   xF9,W
08D6:  ADDWFC 03,F
08D8:  MOVFF  03,1FC
08DC:  MOVF   xF7,W
08DE:  ADDWF  xFA,W
08E0:  CLRF   03
08E2:  ADDLW  E8
08E4:  MOVWF  FE9
08E6:  MOVLW  00
08E8:  ADDWFC 03,W
08EA:  MOVWF  FEA
08EC:  MOVFF  FEF,1FD
08F0:  MOVFF  1FC,FEA
08F4:  MOVFF  01,FE9
08F8:  MOVFF  1FD,FEF
08FC:  INCF   xFA,F
08FE:  BRA    08C6
....................  
....................   } 
....................  
....................   destino[index] = '\0'; 
0900:  CLRF   03
0902:  MOVF   xFA,W
0904:  ADDWF  xF8,W
0906:  MOVWF  FE9
0908:  MOVF   xF9,W
090A:  ADDWFC 03,W
090C:  MOVWF  FEA
090E:  CLRF   FEF
....................  
....................   return; 
0910:  MOVLB  0
0912:  RETURN 0
.................... } 
....................  
.................... void clear_command(){ 
....................  
....................   delay_ms(200); 
*
0C12:  MOVLW  C8
0C14:  MOVLB  2
0C16:  MOVWF  x46
0C18:  MOVLB  0
0C1A:  CALL   03D4
....................   memset (comando_recibido_UART, 0x00, sizeof(comando_recibido_UART)); 
0C1E:  CLRF   FEA
0C20:  MOVLW  52
0C22:  MOVWF  FE9
0C24:  CLRF   00
0C26:  CLRF   02
0C28:  MOVLW  96
0C2A:  MOVWF  01
0C2C:  RCALL  09D4
....................   memset (comando_recibido_BUFF, 0x00, sizeof(comando_recibido_BUFF)); 
0C2E:  CLRF   FEA
0C30:  MOVLW  E8
0C32:  MOVWF  FE9
0C34:  CLRF   00
0C36:  CLRF   02
0C38:  MOVLW  96
0C3A:  MOVWF  01
0C3C:  RCALL  09D4
....................  
....................   comando_disponivel_UART = FALSE; 
0C3E:  MOVLB  1
0C40:  BCF    x82.0
....................   enable_interrupts(GLOBAL); 
0C42:  MOVLW  C0
0C44:  IORWF  FF2,F
....................   enable_interrupts(INT_RTCC); 
0C46:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
0C48:  BSF    F9D.5
....................    
....................   return; 
0C4A:  MOVLB  0
0C4C:  GOTO   0CF2 (RETURN)
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... extern int1 resposta_SIM; 
.................... extern comando_disponivel_UART; 
.................... int32 timeout = 7000000; 
....................  
.................... int1 envia_SIM800L(char *send, char *recive){ 
*
052E:  MOVLW  02
0530:  MOVLB  2
0532:  MOVWF  x3F
....................  
....................   int8 tentativas = 2; 
....................  
....................   disable_interrupts(INT_RTCC);  
0534:  BCF    FF2.5
....................   enable_interrupts(INT_RDA);                                               
0536:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
0538:  MOVLW  C0
053A:  IORWF  FF2,F
....................    
....................   do{ 
....................     timeout = 7000000;   
053C:  MOVLB  1
053E:  CLRF   x86
0540:  MOVLW  6A
0542:  MOVWF  x85
0544:  MOVLW  CF
0546:  MOVWF  x84
0548:  MOVLW  C0
054A:  MOVWF  x83
....................     comando_disponivel_UART = 0; 
054C:  BCF    x82.0
....................  
....................     fprintf(SIM800L_SERIAL,send);                                             // Envia comando para o SIM800L  
054E:  MOVFF  23C,FEA
0552:  MOVFF  23B,FE9
0556:  MOVLB  0
0558:  BRA    046E
....................     if(strstr(recive,"+CMGS")!=0){ 
055A:  MOVLW  2B
055C:  MOVLB  2
055E:  MOVWF  x40
0560:  MOVLW  43
0562:  MOVWF  x41
0564:  MOVLW  4D
0566:  MOVWF  x42
0568:  MOVLW  47
056A:  MOVWF  x43
056C:  MOVLW  53
056E:  MOVWF  x44
0570:  CLRF   x45
0572:  MOVFF  23E,249
0576:  MOVFF  23D,248
057A:  MOVLW  02
057C:  MOVWF  x4B
057E:  MOVLW  40
0580:  MOVWF  x4A
0582:  MOVLB  0
0584:  RCALL  0496
0586:  MOVFF  02,249
058A:  MOVFF  01,248
058E:  MOVLB  2
0590:  MOVF   x48,F
0592:  BNZ   0598
0594:  MOVF   x49,F
0596:  BZ    05A6
....................       delay_ms(150); 
0598:  MOVLW  96
059A:  MOVWF  x46
059C:  MOVLB  0
059E:  RCALL  03D4
....................       fputc(0x1A,SIM800L_SERIAL); 
05A0:  MOVLW  1A
05A2:  BRA    0524
05A4:  MOVLB  2
....................     }                                                                                         
....................     while(!comando_disponivel_UART && --timeout > 0);                         // Aguarda o SIM800L responder por ~23 segundos caso nao responda retorna 0 
05A6:  MOVLB  1
05A8:  BTFSC  x82.0
05AA:  BRA    05CC
05AC:  MOVLW  FF
05AE:  ADDWF  x83,F
05B0:  BTFSS  FD8.0
05B2:  ADDWF  x84,F
05B4:  BTFSS  FD8.0
05B6:  ADDWF  x85,F
05B8:  BTFSS  FD8.0
05BA:  ADDWF  x86,F
05BC:  MOVF   x83,F
05BE:  BNZ   05A8
05C0:  MOVF   x84,F
05C2:  BNZ   05A8
05C4:  MOVF   x85,F
05C6:  BNZ   05A8
05C8:  MOVF   x86,F
05CA:  BNZ   05A8
....................                           
....................     if(comando_disponivel_UART){                                              // Caso receba a resposta  
05CC:  BTFSS  x82.0
05CE:  BRA    0606
....................       comando_disponivel_UART = 0;                   
05D0:  BCF    x82.0
....................       posicao_valor_comando = strstr(comando_recibido_UART,recive);           // Procura a palavra recive da funcao na resposta recebida 
05D2:  MOVLB  2
05D4:  CLRF   x49
05D6:  MOVLW  52
05D8:  MOVWF  x48
05DA:  MOVFF  23E,24B
05DE:  MOVFF  23D,24A
05E2:  MOVLB  0
05E4:  RCALL  0496
05E6:  MOVFF  02,17F
05EA:  MOVFF  01,17E
....................                  
....................       if(posicao_valor_comando!= 0){                                          // Caso encontre a resposta esperada 
05EE:  MOVLB  1
05F0:  MOVF   x7E,F
05F2:  BNZ   05F8
05F4:  MOVF   x7F,F
05F6:  BZ    0606
....................         enable_interrupts(INT_RDA); 
05F8:  BSF    F9D.5
....................         enable_interrupts(INT_RTCC); 
05FA:  BSF    FF2.5
....................         enable_interrupts(GLOBAL); 
05FC:  MOVLW  C0
05FE:  IORWF  FF2,F
....................         return 1; 
0600:  MOVLW  01
0602:  MOVWF  01
0604:  BRA    061A
....................       } 
....................     } 
....................   }while(--tentativas>0);                 
0606:  MOVLB  2
0608:  DECFSZ x3F,F
060A:  BRA    053C
....................    
....................   enable_interrupts(GLOBAL); 
060C:  MOVLW  C0
060E:  IORWF  FF2,F
....................   enable_interrupts(INT_RDA); 
0610:  BSF    F9D.5
....................   enable_interrupts(INT_RTCC); 
0612:  BSF    FF2.5
....................  
....................   return 0; 
0614:  MOVLW  00
0616:  MOVWF  01
0618:  MOVLB  1
061A:  MOVLB  0
061C:  RETURN 0
.................... } 
....................  
.................... int1 Send_SMS(char *numero,char *mensagem){ 
....................    
....................   char numero_envio[35]; 
....................  
....................   sprintf(numero_envio,"AT+CMGS=\"%s\"\r\n",numero); 
061E:  MOVLW  01
0620:  MOVLB  1
0622:  MOVWF  x88
0624:  MOVLW  FC
0626:  MOVWF  x87
0628:  MOVLW  84
062A:  MOVWF  FF6
062C:  MOVLW  03
062E:  MOVWF  FF7
0630:  MOVLW  09
0632:  MOVLB  2
0634:  MOVWF  x37
0636:  MOVLB  0
0638:  RCALL  0420
063A:  MOVFF  1F9,FEA
063E:  MOVFF  1F8,FE9
0642:  BRA    0448
0644:  MOVLW  8F
0646:  MOVWF  FF6
0648:  MOVLW  03
064A:  MOVWF  FF7
064C:  MOVLW  03
064E:  MOVLB  2
0650:  MOVWF  x37
0652:  MOVLB  0
0654:  RCALL  0420
....................  
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
0656:  MOVLW  02
0658:  MOVWF  FEA
065A:  MOVLW  1F
065C:  MOVWF  FE9
065E:  MOVFF  FF2,237
0662:  BCF    FF2.7
0664:  MOVLW  0C
0666:  MOVWF  01
0668:  CLRF   FF7
066A:  MOVLW  00
066C:  RCALL  0194
066E:  TBLRD*-
0670:  TBLRD*+
0672:  MOVFF  FF5,FEE
0676:  DECFSZ 01,F
0678:  BRA    0670
067A:  MOVLB  2
067C:  BTFSC  x37.7
067E:  BSF    FF2.7
0680:  MOVLW  4F
0682:  MOVWF  x2B
0684:  MOVLW  4B
0686:  MOVWF  x2C
0688:  CLRF   x2D
068A:  MOVLW  02
068C:  MOVWF  x3C
068E:  MOVLW  1F
0690:  MOVWF  x3B
0692:  MOVLW  02
0694:  MOVWF  x3E
0696:  MOVLW  2B
0698:  MOVWF  x3D
069A:  MOVLB  0
069C:  RCALL  052E
069E:  MOVF   01,F
06A0:  BZ    0756
....................     if(envia_SIM800L("AT+CSMP=17,255,0,0\r\n","OK")) 
06A2:  MOVLW  02
06A4:  MOVWF  FEA
06A6:  MOVLW  1F
06A8:  MOVWF  FE9
06AA:  MOVFF  FF2,237
06AE:  BCF    FF2.7
06B0:  MOVLW  15
06B2:  MOVWF  01
06B4:  CLRF   FF7
06B6:  MOVLW  00
06B8:  RCALL  01BA
06BA:  TBLRD*-
06BC:  TBLRD*+
06BE:  MOVFF  FF5,FEE
06C2:  DECFSZ 01,F
06C4:  BRA    06BC
06C6:  MOVLB  2
06C8:  BTFSC  x37.7
06CA:  BSF    FF2.7
06CC:  MOVLW  4F
06CE:  MOVWF  x34
06D0:  MOVLW  4B
06D2:  MOVWF  x35
06D4:  CLRF   x36
06D6:  MOVLW  02
06D8:  MOVWF  x3C
06DA:  MOVLW  1F
06DC:  MOVWF  x3B
06DE:  MOVLW  02
06E0:  MOVWF  x3E
06E2:  MOVLW  34
06E4:  MOVWF  x3D
06E6:  MOVLB  0
06E8:  RCALL  052E
06EA:  MOVF   01,F
06EC:  BZ    0756
....................       if(envia_SIM800L(numero_envio, ">")) 
06EE:  MOVLW  3E
06F0:  MOVLB  2
06F2:  MOVWF  x1F
06F4:  CLRF   x20
06F6:  MOVLW  01
06F8:  MOVWF  x3C
06FA:  MOVLW  FC
06FC:  MOVWF  x3B
06FE:  MOVLW  02
0700:  MOVWF  x3E
0702:  MOVLW  1F
0704:  MOVWF  x3D
0706:  MOVLB  0
0708:  RCALL  052E
070A:  MOVF   01,F
070C:  BZ    0756
....................         if(envia_SIM800L(mensagem, "+CMGS:")) 
070E:  MOVLW  02
0710:  MOVWF  FEA
0712:  MOVLW  1F
0714:  MOVWF  FE9
0716:  MOVFF  FF2,237
071A:  BCF    FF2.7
071C:  MOVLW  07
071E:  MOVWF  01
0720:  CLRF   FF7
0722:  MOVLW  00
0724:  RCALL  01EA
0726:  TBLRD*-
0728:  TBLRD*+
072A:  MOVFF  FF5,FEE
072E:  DECFSZ 01,F
0730:  BRA    0728
0732:  MOVLB  2
0734:  BTFSC  x37.7
0736:  BSF    FF2.7
0738:  MOVFF  1FB,23C
073C:  MOVFF  1FA,23B
0740:  MOVLW  02
0742:  MOVWF  x3E
0744:  MOVLW  1F
0746:  MOVWF  x3D
0748:  MOVLB  0
074A:  RCALL  052E
074C:  MOVF   01,F
074E:  BZ    0756
....................           return 1; 
0750:  MOVLW  01
0752:  MOVWF  01
0754:  BRA    075A
....................   return 0; 
0756:  MOVLW  00
0758:  MOVWF  01
075A:  RETURN 0
.................... } 
....................  
.................... int1 Read_SMS(){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")){ 
*
081A:  MOVLW  01
081C:  MOVWF  FEA
081E:  MOVLW  F6
0820:  MOVWF  FE9
0822:  MOVFF  FF2,20E
0826:  BCF    FF2.7
0828:  MOVLW  0C
082A:  MOVWF  01
082C:  CLRF   FF7
082E:  MOVLW  00
0830:  RCALL  0194
0832:  TBLRD*-
0834:  TBLRD*+
0836:  MOVFF  FF5,FEE
083A:  DECFSZ 01,F
083C:  BRA    0834
083E:  MOVLB  2
0840:  BTFSC  x0E.7
0842:  BSF    FF2.7
0844:  MOVLW  4F
0846:  MOVWF  x02
0848:  MOVLW  4B
084A:  MOVWF  x03
084C:  CLRF   x04
084E:  MOVLW  01
0850:  MOVWF  x3C
0852:  MOVLW  F6
0854:  MOVWF  x3B
0856:  MOVLW  02
0858:  MOVWF  x3E
085A:  MOVWF  x3D
085C:  MOVLB  0
085E:  RCALL  052E
0860:  MOVF   01,F
0862:  BZ    08B4
....................     if(envia_SIM800L("AT+CMGL=\"REC UNREAD\"\r\n", "")){ 
0864:  MOVLW  01
0866:  MOVWF  FEA
0868:  MOVLW  F6
086A:  MOVWF  FE9
086C:  MOVFF  FF2,20E
0870:  BCF    FF2.7
0872:  MOVLW  17
0874:  MOVWF  01
0876:  CLRF   FF7
0878:  MOVLW  00
087A:  RCALL  020C
087C:  TBLRD*-
087E:  TBLRD*+
0880:  MOVFF  FF5,FEE
0884:  DECFSZ 01,F
0886:  BRA    087E
0888:  MOVLB  2
088A:  BTFSC  x0E.7
088C:  BSF    FF2.7
088E:  CLRF   x0D
0890:  MOVLW  01
0892:  MOVWF  x3C
0894:  MOVLW  F6
0896:  MOVWF  x3B
0898:  MOVLW  02
089A:  MOVWF  x3E
089C:  MOVLW  0D
089E:  MOVWF  x3D
08A0:  MOVLB  0
08A2:  RCALL  052E
08A4:  MOVF   01,F
08A6:  BZ    08B4
....................       resposta_SIM = true; 
08A8:  MOVLB  1
08AA:  BSF    x82.1
....................       return 1;     
08AC:  MOVLW  01
08AE:  MOVWF  01
08B0:  BRA    08BA
08B2:  MOVLB  0
....................     }   
....................   } 
....................   return 0; 
08B4:  MOVLW  00
08B6:  MOVWF  01
08B8:  MOVLB  1
08BA:  MOVLB  0
08BC:  GOTO   0C10 (RETURN)
.................... } 
....................  
....................  
.................... #ENDIF 
....................  
....................  
.................... // Declaração de Variáveis 
....................  
.................... int1 comando_disponivel_UART = FALSE; 
.................... int1 One_Second = FALSE; 
.................... int1 One_Minute = FALSE; 
.................... int16 Miliseconds = 0; 
.................... int16 seconds = 0; 
.................... char comando = 0; 
.................... int1 resposta_SIM = false; 
.................... //Fim declaração de variáveis 
....................  
.................... #INT_RTCC 
.................... void Timer_0(){ 
....................  
....................   set_timer0(6);   
*
0394:  CLRF   FD7
0396:  MOVLW  06
0398:  MOVWF  FD6
....................   Miliseconds++; 
039A:  MOVLB  1
039C:  INCF   x89,F
039E:  BTFSC  FD8.2
03A0:  INCF   x8A,F
....................  
....................   if(Miliseconds == 1000){ 
03A2:  MOVF   x89,W
03A4:  SUBLW  E8
03A6:  BNZ   03CC
03A8:  MOVF   x8A,W
03AA:  SUBLW  03
03AC:  BNZ   03CC
....................     seconds++; 
03AE:  INCF   x8B,F
03B0:  BTFSC  FD8.2
03B2:  INCF   x8C,F
....................     Miliseconds = 0; 
03B4:  CLRF   x8A
03B6:  CLRF   x89
....................     One_Second = TRUE; 
03B8:  BSF    x82.2
....................     output_toggle(PIN_A1); 
03BA:  BTG    F89.1
....................     if(seconds==60){ 
03BC:  MOVF   x8B,W
03BE:  SUBLW  3C
03C0:  BNZ   03CC
03C2:  MOVF   x8C,F
03C4:  BNZ   03CC
....................       seconds = 0; 
03C6:  CLRF   x8C
03C8:  CLRF   x8B
....................       One_Minute = TRUE; 
03CA:  BSF    x82.3
....................     } 
....................   } 
....................   return; 
03CC:  BCF    FF2.2
03CE:  MOVLB  0
03D0:  GOTO   0060
.................... } 
....................  
.................... void main() 
*
0CFA:  CLRF   FF8
0CFC:  BCF    FD0.7
0CFE:  BSF    07.7
0D00:  CLRF   16
0D02:  BSF    FB8.3
0D04:  MOVLW  22
0D06:  MOVWF  FAF
0D08:  MOVLW  00
0D0A:  MOVWF  FB0
0D0C:  MOVLW  A6
0D0E:  MOVWF  FAC
0D10:  MOVLW  90
0D12:  MOVWF  FAB
0D14:  CLRF   4F
0D16:  MOVLB  1
0D18:  CLRF   x7F
0D1A:  CLRF   x7E
0D1C:  MOVLW  86
0D1E:  MOVWF  x81
0D20:  MOVLW  A0
0D22:  MOVWF  x80
0D24:  CLRF   x86
0D26:  MOVLW  6A
0D28:  MOVWF  x85
0D2A:  MOVLW  CF
0D2C:  MOVWF  x84
0D2E:  MOVLW  C0
0D30:  MOVWF  x83
0D32:  CLRF   x88
0D34:  CLRF   x87
0D36:  BCF    x82.0
0D38:  BCF    x82.2
0D3A:  BCF    x82.3
0D3C:  CLRF   x8A
0D3E:  CLRF   x89
0D40:  CLRF   x8C
0D42:  CLRF   x8B
0D44:  CLRF   x8D
0D46:  BCF    x82.1
0D48:  MOVF   FC1,W
0D4A:  ANDLW  C0
0D4C:  IORLW  0F
0D4E:  MOVWF  FC1
0D50:  MOVLW  07
0D52:  MOVWF  FB4
0D54:  CLRF   17
0D56:  CLRF   18
.................... { 
....................   set_tris_a (0b00000000);                                                     //Ra7-Ra6-Ra5-Ra4-Ra3-Ra2-Ra1-Ra0 
0D58:  MOVLW  00
0D5A:  MOVWF  F92
....................   set_tris_b (0b00000000);                                                     //Rb7-Rb6-Rb5-Rb4-Rb3-Rb2-Rb1-Rb0 
0D5C:  MOVWF  F93
....................   set_tris_c (0b10000000);                                                     //Rc7-Rc6-Rc5-Rc4-Rc3-Rc2-Rc1-Rc0 
0D5E:  MOVLW  80
0D60:  MOVWF  F94
....................   set_tris_d (0b00000000);  
0D62:  MOVLW  00
0D64:  MOVWF  F95
....................    
....................   setup_adc_ports(NO_ANALOGS); 
0D66:  MOVF   FC1,W
0D68:  ANDLW  C0
0D6A:  IORLW  0F
0D6C:  MOVWF  FC1
....................   setup_adc(ADC_OFF); 
0D6E:  BCF    FC2.0
....................   setup_wdt(WDT_OFF); 
0D70:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 | RTCC_8_BIT); 
0D72:  MOVLW  C3
0D74:  MOVWF  FD5
....................   set_timer0(6); 
0D76:  CLRF   FD7
0D78:  MOVLW  06
0D7A:  MOVWF  FD6
....................    
....................   enable_interrupts(INT_TIMER0); 
0D7C:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
0D7E:  BSF    F9D.5
....................   enable_interrupts(GLOBAL);  
0D80:  MOVLW  C0
0D82:  IORWF  FF2,F
....................   output_high(PIN_C5); 
0D84:  BSF    F8B.5
....................   delay_ms(2000); 
0D86:  MOVLW  08
0D88:  MOVWF  xA8
0D8A:  MOVLW  FA
0D8C:  MOVLB  2
0D8E:  MOVWF  x46
0D90:  MOVLB  0
0D92:  CALL   03D4
0D96:  MOVLB  1
0D98:  DECFSZ xA8,F
0D9A:  BRA    0D8A
....................   output_low(PIN_C5); 
0D9C:  BCF    F8B.5
....................   delay_ms(5000); 
0D9E:  MOVLW  14
0DA0:  MOVWF  xA8
0DA2:  MOVLW  FA
0DA4:  MOVLB  2
0DA6:  MOVWF  x46
0DA8:  MOVLB  0
0DAA:  CALL   03D4
0DAE:  MOVLB  1
0DB0:  DECFSZ xA8,F
0DB2:  BRA    0DA2
....................   Send_SMS("031995822739","INICIANDO..."); 
0DB4:  MOVLW  01
0DB6:  MOVWF  FEA
0DB8:  MOVLW  8E
0DBA:  MOVWF  FE9
0DBC:  MOVFF  FF2,1A8
0DC0:  BCF    FF2.7
0DC2:  MOVLW  0D
0DC4:  MOVWF  01
0DC6:  CLRF   FF7
0DC8:  MOVLW  00
0DCA:  MOVLB  0
0DCC:  CALL   023E
0DD0:  TBLRD*-
0DD2:  TBLRD*+
0DD4:  MOVFF  FF5,FEE
0DD8:  DECFSZ 01,F
0DDA:  BRA    0DD2
0DDC:  MOVLB  1
0DDE:  BTFSC  xA8.7
0DE0:  BSF    FF2.7
0DE2:  MOVLW  01
0DE4:  MOVWF  FEA
0DE6:  MOVLW  9B
0DE8:  MOVWF  FE9
0DEA:  MOVFF  FF2,1AA
0DEE:  BCF    FF2.7
0DF0:  MOVLW  0D
0DF2:  MOVWF  01
0DF4:  CLRF   FF7
0DF6:  MOVLW  00
0DF8:  MOVLB  0
0DFA:  CALL   0266
0DFE:  TBLRD*-
0E00:  TBLRD*+
0E02:  MOVFF  FF5,FEE
0E06:  DECFSZ 01,F
0E08:  BRA    0E00
0E0A:  MOVLB  1
0E0C:  BTFSC  xAA.7
0E0E:  BSF    FF2.7
0E10:  MOVLW  01
0E12:  MOVWF  xF9
0E14:  MOVLW  8E
0E16:  MOVWF  xF8
0E18:  MOVLW  01
0E1A:  MOVWF  xFB
0E1C:  MOVLW  9B
0E1E:  MOVWF  xFA
0E20:  MOVLB  0
0E22:  CALL   061E
....................    
....................   while(TRUE){ 
....................  
....................     if(One_Second){ 
0E26:  MOVLB  1
0E28:  BTFSS  x82.2
0E2A:  BRA    0E34
....................  
....................       One_Second = FALSE; 
0E2C:  BCF    x82.2
....................       Executar_Cada_Segundo(); 
0E2E:  MOVLB  0
0E30:  BRA    0C50
0E32:  MOVLB  1
....................  
....................     } 
....................  
....................     if(One_Minute){ 
0E34:  BTFSS  x82.3
0E36:  BRA    0E42
....................  
....................       One_Minute = FALSE; 
0E38:  BCF    x82.3
....................       Executar_Cada_Minuto(); 
0E3A:  MOVLB  0
0E3C:  GOTO   0004
0E40:  MOVLB  1
....................  
....................     } 
0E42:  BRA    0E28
....................  
....................   } 
....................  
.................... } 
....................  
0E44:  SLEEP 
.................... void Executar_Cada_Segundo(){ 
....................  
....................   if(comando_disponivel_UART){ 
*
0C50:  MOVLB  1
0C52:  BTFSS  x82.0
0C54:  BRA    0CF4
....................    
....................     disable_interrupts(GLOBAL); 
0C56:  BCF    FF2.6
0C58:  BCF    FF2.7
0C5A:  BTFSC  FF2.7
0C5C:  BRA    0C58
....................     comando = Get_Comando(); 
0C5E:  MOVLB  0
0C60:  RCALL  075C
0C62:  MOVFF  01,18D
....................      
....................     if(comando != 0){ 
0C66:  MOVLB  1
0C68:  MOVF   x8D,F
0C6A:  BZ    0C76
....................  
....................       Executa_Comando(comando); 
0C6C:  MOVFF  18D,1B9
0C70:  MOVLB  0
0C72:  RCALL  0A04
0C74:  MOVLB  1
....................        
....................     } 
....................     if(resposta_SIM == 1){ 
0C76:  BTFSS  x82.1
0C78:  BRA    0CEC
....................       disable_interrupts(GLOBAL); 
0C7A:  BCF    FF2.6
0C7C:  BCF    FF2.7
0C7E:  BTFSC  FF2.7
0C80:  BRA    0C7C
....................       resposta_SIM = 0; 
0C82:  BCF    x82.1
....................       comando = Get_Comando(); 
0C84:  MOVLB  0
0C86:  RCALL  075C
0C88:  MOVFF  01,18D
....................       Executa_Comando(comando); 
0C8C:  MOVFF  18D,1B9
0C90:  RCALL  0A04
....................       delay_ms(100); 
0C92:  MOVLW  64
0C94:  MOVLB  2
0C96:  MOVWF  x46
0C98:  MOVLB  0
0C9A:  CALL   03D4
....................       envia_SIM800L("AT+CMGD=1,1\r\n", "OK"); 
0C9E:  MOVLW  01
0CA0:  MOVWF  FEA
0CA2:  MOVLW  A8
0CA4:  MOVWF  FE9
0CA6:  MOVFF  FF2,1B9
0CAA:  BCF    FF2.7
0CAC:  MOVLW  0E
0CAE:  MOVWF  01
0CB0:  CLRF   FF7
0CB2:  MOVLW  00
0CB4:  CALL   028E
0CB8:  TBLRD*-
0CBA:  TBLRD*+
0CBC:  MOVFF  FF5,FEE
0CC0:  DECFSZ 01,F
0CC2:  BRA    0CBA
0CC4:  MOVLB  1
0CC6:  BTFSC  xB9.7
0CC8:  BSF    FF2.7
0CCA:  MOVLW  4F
0CCC:  MOVWF  xB6
0CCE:  MOVLW  4B
0CD0:  MOVWF  xB7
0CD2:  CLRF   xB8
0CD4:  MOVLW  01
0CD6:  MOVLB  2
0CD8:  MOVWF  x3C
0CDA:  MOVLW  A8
0CDC:  MOVWF  x3B
0CDE:  MOVLW  01
0CE0:  MOVWF  x3E
0CE2:  MOVLW  B6
0CE4:  MOVWF  x3D
0CE6:  MOVLB  0
0CE8:  RCALL  052E
0CEA:  MOVLB  1
....................     } 
....................     comando = 0; 
0CEC:  CLRF   x8D
....................     clear_command(); 
0CEE:  MOVLB  0
0CF0:  BRA    0C12
0CF2:  MOVLB  1
....................   } 
....................    
....................   return; 
0CF4:  MOVLB  0
0CF6:  GOTO   0E32 (RETURN)
.................... } 
....................  
.................... void Executar_Cada_Minuto(){ 
....................   //Send_SMS("031995822739","TESTE"); 
....................  
....................   return; 
*
0004:  GOTO   0E40 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CE3B   PLL4 CPUDIV4 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
