CCS PCH C Compiler, Version 5.015, 5967               15-out-18 17:11

               Filename:   C:\Users\Vitor\Desktop\Monitor_Estado_Baterias\TAI_Bateria.lst

               ROM used:   3618 bytes (11%)
                           Largest free fragment is 29150
               RAM used:   404 (20%) at main() level
                           597 (29%) worst case
               Stack used: 7 locations (5 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   0CD8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   02CC
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   0394
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... // Projeto Monitor do Estado de Baterias - TAI  
.................... // Data: Setembro de 2018 
....................  
....................  
.................... //******************* Interrupção do Timer 0 / RTCC ************************** 
.................... //   
.................... //  Cristal externo = 16 MHz - Uso de PLL*4 -> Frequencia de trabalho = 16MHz  
.................... //  Prescaler = 1:16 
.................... //  Tout =(4*prescaler* (256-TMR0))/fclk   
.................... //  Para interrupção a cada 1 ms 
.................... //  TMR0 = 6  
.................... //  
.................... //**************************************************************************** 
....................  
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00A2:  MOVFF  FF2,0D
00A6:  BCF    FF2.7
00A8:  CLRF   FF7
00AA:  ADDLW  BC
00AC:  MOVWF  FF6
00AE:  MOVLW  00
00B0:  ADDWFC FF7,F
00B2:  TBLRD*+
00B4:  MOVF   FF5,W
00B6:  BTFSC  0D.7
00B8:  BSF    FF2.7
00BA:  RETURN 0
00BC:  DATA 2B,43
00BE:  DATA 4D,54
00C0:  DATA 49,00
00C2:  MOVFF  FF2,0D
00C6:  BCF    FF2.7
00C8:  CLRF   FF7
00CA:  ADDLW  DC
00CC:  MOVWF  FF6
00CE:  MOVLW  00
00D0:  ADDWFC FF7,F
00D2:  TBLRD*+
00D4:  MOVF   FF5,W
00D6:  BTFSC  0D.7
00D8:  BSF    FF2.7
00DA:  RETURN 0
00DC:  DATA 2B,43
00DE:  DATA 4D,47
00E0:  DATA 4C,00
00E2:  MOVFF  FF2,0D
00E6:  BCF    FF2.7
00E8:  CLRF   FF7
00EA:  ADDLW  FC
00EC:  MOVWF  FF6
00EE:  MOVLW  00
00F0:  ADDWFC FF7,F
00F2:  TBLRD*+
00F4:  MOVF   FF5,W
00F6:  BTFSC  0D.7
00F8:  BSF    FF2.7
00FA:  RETURN 0
00FC:  DATA 4F,49
00FE:  DATA 54,41
0100:  DATA 49,00
0102:  MOVFF  FF2,0D
0106:  BCF    FF2.7
0108:  CLRF   FF7
010A:  ADDLW  1C
010C:  MOVWF  FF6
010E:  MOVLW  01
0110:  ADDWFC FF7,F
0112:  TBLRD*+
0114:  MOVF   FF5,W
0116:  BTFSC  0D.7
0118:  BSF    FF2.7
011A:  RETURN 0
011C:  DATA 48,45
011E:  DATA 41,52
0120:  DATA 54,42
0122:  DATA 45,41
0124:  DATA 54,28
0126:  DATA 29,00
0128:  MOVFF  FF2,0D
012C:  BCF    FF2.7
012E:  CLRF   FF7
0130:  ADDLW  42
0132:  MOVWF  FF6
0134:  MOVLW  01
0136:  ADDWFC FF7,F
0138:  TBLRD*+
013A:  MOVF   FF5,W
013C:  BTFSC  0D.7
013E:  BSF    FF2.7
0140:  RETURN 0
0142:  DATA 2B,4E
0144:  DATA 55,4D
0146:  DATA 41,44
0148:  DATA 44,00
014A:  MOVFF  FF2,0D
014E:  BCF    FF2.7
0150:  CLRF   FF7
0152:  ADDLW  64
0154:  MOVWF  FF6
0156:  MOVLW  01
0158:  ADDWFC FF7,F
015A:  TBLRD*+
015C:  MOVF   FF5,W
015E:  BTFSC  0D.7
0160:  BSF    FF2.7
0162:  RETURN 0
0164:  DATA 2B,4E
0166:  DATA 55,4D
0168:  DATA 44,45
016A:  DATA 4C,00
016C:  MOVFF  FF2,0D
0170:  BCF    FF2.7
0172:  CLRF   FF7
0174:  ADDLW  86
0176:  MOVWF  FF6
0178:  MOVLW  01
017A:  ADDWFC FF7,F
017C:  TBLRD*+
017E:  MOVF   FF5,W
0180:  BTFSC  0D.7
0182:  BSF    FF2.7
0184:  RETURN 0
0186:  DATA 4F,4B
0188:  DATA 20,43
018A:  DATA 4C,45
018C:  DATA 41,52
018E:  DATA 20,41
0190:  DATA 4C,4C
0192:  DATA 00,00
0194:  MOVFF  FF2,0D
0198:  BCF    FF2.7
019A:  CLRF   FF7
019C:  ADDLW  AE
019E:  MOVWF  FF6
01A0:  MOVLW  01
01A2:  ADDWFC FF7,F
01A4:  TBLRD*+
01A6:  MOVF   FF5,W
01A8:  BTFSC  0D.7
01AA:  BSF    FF2.7
01AC:  RETURN 0
01AE:  DATA 41,54
01B0:  DATA 2B,43
01B2:  DATA 4D,47
01B4:  DATA 46,3D
01B6:  DATA 31,0D
01B8:  DATA 0A,00
01BA:  MOVFF  FF2,0D
01BE:  BCF    FF2.7
01C0:  CLRF   FF7
01C2:  ADDLW  D4
01C4:  MOVWF  FF6
01C6:  MOVLW  01
01C8:  ADDWFC FF7,F
01CA:  TBLRD*+
01CC:  MOVF   FF5,W
01CE:  BTFSC  0D.7
01D0:  BSF    FF2.7
01D2:  RETURN 0
01D4:  DATA 41,54
01D6:  DATA 2B,43
01D8:  DATA 53,4D
01DA:  DATA 50,3D
01DC:  DATA 31,37
01DE:  DATA 2C,32
01E0:  DATA 35,35
01E2:  DATA 2C,30
01E4:  DATA 2C,30
01E6:  DATA 0D,0A
01E8:  DATA 00,00
01EA:  MOVFF  FF2,0D
01EE:  BCF    FF2.7
01F0:  CLRF   FF7
01F2:  ADDLW  04
01F4:  MOVWF  FF6
01F6:  MOVLW  02
01F8:  ADDWFC FF7,F
01FA:  TBLRD*+
01FC:  MOVF   FF5,W
01FE:  BTFSC  0D.7
0200:  BSF    FF2.7
0202:  RETURN 0
0204:  DATA 2B,43
0206:  DATA 4D,47
0208:  DATA 53,3A
020A:  DATA 00,00
020C:  MOVFF  FF2,0D
0210:  BCF    FF2.7
0212:  CLRF   FF7
0214:  ADDLW  26
0216:  MOVWF  FF6
0218:  MOVLW  02
021A:  ADDWFC FF7,F
021C:  TBLRD*+
021E:  MOVF   FF5,W
0220:  BTFSC  0D.7
0222:  BSF    FF2.7
0224:  RETURN 0
0226:  DATA 41,54
0228:  DATA 2B,43
022A:  DATA 4D,47
022C:  DATA 4C,3D
022E:  DATA 22,52
0230:  DATA 45,43
0232:  DATA 20,55
0234:  DATA 4E,52
0236:  DATA 45,41
0238:  DATA 44,22
023A:  DATA 0D,0A
023C:  DATA 00,00
023E:  MOVFF  FF2,0D
0242:  BCF    FF2.7
0244:  CLRF   FF7
0246:  ADDLW  58
0248:  MOVWF  FF6
024A:  MOVLW  02
024C:  ADDWFC FF7,F
024E:  TBLRD*+
0250:  MOVF   FF5,W
0252:  BTFSC  0D.7
0254:  BSF    FF2.7
0256:  RETURN 0
0258:  DATA 30,33
025A:  DATA 31,39
025C:  DATA 39,35
025E:  DATA 38,32
0260:  DATA 32,37
0262:  DATA 33,39
0264:  DATA 00,00
0266:  MOVFF  FF2,0D
026A:  BCF    FF2.7
026C:  CLRF   FF7
026E:  ADDLW  80
0270:  MOVWF  FF6
0272:  MOVLW  02
0274:  ADDWFC FF7,F
0276:  TBLRD*+
0278:  MOVF   FF5,W
027A:  BTFSC  0D.7
027C:  BSF    FF2.7
027E:  RETURN 0
0280:  DATA 49,4E
0282:  DATA 49,43
0284:  DATA 49,41
0286:  DATA 4E,44
0288:  DATA 4F,2E
028A:  DATA 2E,2E
028C:  DATA 00,00
028E:  MOVFF  FF2,0D
0292:  BCF    FF2.7
0294:  CLRF   FF7
0296:  ADDLW  A8
0298:  MOVWF  FF6
029A:  MOVLW  02
029C:  ADDWFC FF7,F
029E:  TBLRD*+
02A0:  MOVF   FF5,W
02A2:  BTFSC  0D.7
02A4:  BSF    FF2.7
02A6:  RETURN 0
02A8:  DATA 41,54
02AA:  DATA 2B,43
02AC:  DATA 4D,47
02AE:  DATA 44,3D
02B0:  DATA 31,2C
02B2:  DATA 31,0D
02B4:  DATA 0A,00
*
0384:  DATA 41,54
0386:  DATA 2B,43
0388:  DATA 4D,47
038A:  DATA 53,3D
038C:  DATA 22,25
038E:  DATA 73,22
0390:  DATA 0D,0A
0392:  DATA 00,00
*
03FE:  MOVFF  188,FEA
0402:  MOVFF  187,FE9
0406:  MOVLB  2
0408:  MOVFF  23A,FEF
040C:  INCF   FE9,F
040E:  BTFSC  FD8.2
0410:  INCF   FEA,F
0412:  CLRF   FEF
0414:  MOVLB  1
0416:  INCF   x87,F
0418:  BTFSC  FD8.2
041A:  INCF   x88,F
041C:  MOVLB  0
041E:  RETURN 0
0420:  TBLRD*+
0422:  MOVFF  FF6,238
0426:  MOVFF  FF7,239
042A:  MOVFF  FF5,23A
042E:  RCALL  03FE
0430:  MOVFF  238,FF6
0434:  MOVFF  239,FF7
0438:  MOVLB  2
043A:  DECFSZ x37,F
043C:  BRA    0440
043E:  BRA    0444
0440:  MOVLB  0
0442:  BRA    0420
0444:  MOVLB  0
0446:  RETURN 0
0448:  MOVF   FEF,F
044A:  BZ    046A
044C:  MOVFF  FEA,238
0450:  MOVFF  FE9,237
0454:  MOVFF  FEF,23A
0458:  RCALL  03FE
045A:  MOVFF  238,FEA
045E:  MOVFF  237,FE9
0462:  INCF   FE9,F
0464:  BTFSC  FD8.2
0466:  INCF   FEA,F
0468:  BRA    0448
046A:  GOTO   0642 (RETURN)
046E:  MOVF   FEF,F
0470:  BZ    0492
0472:  MOVFF  FEA,247
0476:  MOVFF  FE9,246
047A:  MOVF   FEF,W
047C:  BTFSS  F9E.4
047E:  BRA    047C
0480:  MOVWF  FAD
0482:  MOVFF  247,FEA
0486:  MOVFF  246,FE9
048A:  INCF   FE9,F
048C:  BTFSC  FD8.2
048E:  INCF   FEA,F
0490:  BRA    046E
0492:  GOTO   055A (RETURN)
*
09D2:  TSTFSZ 01
09D4:  BRA    09DC
09D6:  TSTFSZ 02
09D8:  BRA    09DE
09DA:  BRA    09EA
09DC:  INCF   02,F
09DE:  MOVFF  00,FEE
09E2:  DECFSZ 01,F
09E4:  BRA    09DE
09E6:  DECFSZ 02,F
09E8:  BRA    09DE
09EA:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #fuses NOWDT,NOPROTECT,NOLVP,MCLR,HSPLL,PLL4 
.................... #device PASS_STRINGS=IN_RAM 
.................... #use delay(clock=16000000) 
*
03D4:  MOVLW  02
03D6:  MOVWF  FEA
03D8:  MOVLW  46
03DA:  MOVWF  FE9
03DC:  MOVF   FEF,W
03DE:  BZ    03FC
03E0:  MOVLW  05
03E2:  MOVWF  01
03E4:  CLRF   00
03E6:  DECFSZ 00,F
03E8:  BRA    03E6
03EA:  DECFSZ 01,F
03EC:  BRA    03E4
03EE:  MOVLW  2E
03F0:  MOVWF  00
03F2:  DECFSZ 00,F
03F4:  BRA    03F2
03F6:  BRA    03F8
03F8:  DECFSZ FEF,F
03FA:  BRA    03E0
03FC:  RETURN 0
.................... #use rs232(uart1,baud=115200, xmit=PIN_C6, rcv=PIN_C7, stream = SIM800L_SERIAL, ERRORS) 
*
02B6:  BTFSS  F9E.5
02B8:  BRA    02B6
02BA:  MOVFF  FAB,16
02BE:  MOVFF  FAE,01
02C2:  BTFSS  16.1
02C4:  BRA    02CA
02C6:  BCF    FAB.4
02C8:  BSF    FAB.4
02CA:  RETURN 0
*
0524:  BTFSS  F9E.4
0526:  BRA    0524
0528:  MOVWF  FAD
052A:  GOTO   05A4 (RETURN)
.................... #use fast_io (ALL) 
.................... #priority rda, rtcc, 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
0496:  MOVFF  249,03
049A:  MOVLB  2
049C:  MOVFF  248,FE9
04A0:  MOVFF  249,FEA
04A4:  MOVF   FEF,F
04A6:  BZ    051A
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
04A8:  MOVFF  249,24D
04AC:  MOVFF  248,24C
04B0:  MOVFF  24B,24F
04B4:  MOVFF  24A,24E
04B8:  MOVFF  24F,03
04BC:  MOVFF  24E,FE9
04C0:  MOVFF  24F,FEA
04C4:  MOVF   FEF,F
04C6:  BZ    04F4
04C8:  MOVFF  24C,FE9
04CC:  MOVFF  24D,FEA
04D0:  MOVFF  FEF,250
04D4:  MOVFF  24F,03
04D8:  MOVFF  24E,FE9
04DC:  MOVFF  24F,FEA
04E0:  MOVF   FEF,W
04E2:  SUBWF  x50,W
04E4:  BNZ   04F4
04E6:  INCF   x4C,F
04E8:  BTFSC  FD8.2
04EA:  INCF   x4D,F
04EC:  INCF   x4E,F
04EE:  BTFSC  FD8.2
04F0:  INCF   x4F,F
04F2:  BRA    04B8
....................  
....................       if (*t == '\0') 
04F4:  MOVFF  24F,03
04F8:  MOVFF  24E,FE9
04FC:  MOVFF  03,FEA
0500:  MOVF   FEF,F
0502:  BNZ   050E
....................          return s1; 
0504:  MOVFF  248,01
0508:  MOVFF  249,02
050C:  BRA    0520
....................       ++s1; 
050E:  INCF   x48,F
0510:  BTFSC  FD8.2
0512:  INCF   x49,F
....................       #ifdef FASTER_BUT_MORE_ROM 
0514:  MOVLB  0
0516:  BRA    0496
0518:  MOVLB  2
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
051A:  MOVLW  00
051C:  MOVWF  01
051E:  MOVWF  02
0520:  MOVLB  0
0522:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
....................  
.................... #ENDIF 
....................  
.................... #include "SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
....................  
.................... #include "SIM800L.c" 
.................... #include"Serial.h" 
.................... #IFNDEF SERIAL_H 
.................... #DEFINE SERIAL_H 
....................  
.................... #define  SMS_COMMAND             1 
.................... #define  SMS_READ_COMMAND        2            
....................  
.................... void Executa_Comando(char comando); 
.................... char Get_Comando(); 
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao); 
.................... void get_numero(int nro_caracteres, int posicao, char *destino); 
.................... void clear_command(); 
....................  
.................... #include"Serial.c" 
.................... #include"SIM800L.h" 
.................... #IFNDEF SIM800L_H 
.................... #DEFINE SIM800L_H 
....................  
.................... int1 envia_SIM800L(char *send, char *recive); 
.................... int1 Send_SMS(char *numero,char *mensagem); 
.................... int1 Read_SMS(); 
....................  
.................... #include "SIM800L.c" 
....................  
.................... #ENDIF 
....................  
.................... #include"TAI_Bateria.h" 
.................... #IFNDEF TAI_BATERIA_H 
.................... #DEFINE TAI_BATERIA_H 
....................  
.................... //Prottipo de Funes 
....................  
.................... void Executar_Cada_Segundo(); 
.................... void Executar_Cada_Minuto(); 
....................  
.................... #ENDIF 
....................  
.................... #include"numeros.h" 
.................... #IFNDEF NUMEROS_H 
.................... #DEFINE NUMEROS_H 
....................  
.................... int1 insere_numero(char *numero); 
.................... void limpa_numeros(); 
....................  
.................... #include"numeros.c" 
.................... char numeros[50]; 
.................... int8 qtd_numeros=0; 
.................... char *posicao_numero; 
....................  
.................... int1 insere_numero(char *numero){ // >+5531995822739>+5531995822739>+5531995822739 
*
0912:  MOVF   4F,W
0914:  MULLW  0F
0916:  MOVFF  FF3,1F8
091A:  MOVLB  1
091C:  CLRF   xF9
....................   
....................   int8 index = qtd_numeros*15; 
....................   int8 index_2 = 0; 
....................  
....................   if(qtd_numeros == 3){ 
091E:  MOVF   4F,W
0920:  SUBLW  03
0922:  BNZ   092A
....................  
....................     return 0; 
0924:  MOVLW  00
0926:  MOVWF  01
0928:  BRA    09CC
....................  
....................   } 
....................  
....................   posicao_numero = strstr(numeros,numero); 
092A:  MOVLB  2
092C:  CLRF   x49
092E:  MOVLW  1D
0930:  MOVWF  x48
0932:  MOVFF  1F7,24B
0936:  MOVFF  1F6,24A
093A:  MOVLB  0
093C:  RCALL  0496
093E:  MOVFF  02,51
0942:  MOVFF  01,50
....................    
....................   if(posicao_numero == 0){ 
0946:  MOVF   50,F
0948:  BNZ   09C6
094A:  MOVF   51,F
094C:  BNZ   09C6
....................  
....................     numeros[index] ='>'; 
094E:  CLRF   03
0950:  MOVLB  1
0952:  MOVF   xF8,W
0954:  ADDLW  1D
0956:  MOVWF  FE9
0958:  MOVLW  00
095A:  ADDWFC 03,W
095C:  MOVWF  FEA
095E:  MOVLW  3E
0960:  MOVWF  FEF
....................      
....................     for(index = index+1;numero[index_2]!='\0';index++){ 
0962:  MOVLW  01
0964:  ADDWF  xF8,F
0966:  CLRF   03
0968:  MOVF   xF9,W
096A:  ADDWF  xF6,W
096C:  MOVWF  FE9
096E:  MOVF   xF7,W
0970:  ADDWFC 03,W
0972:  MOVWF  FEA
0974:  MOVF   FEF,F
0976:  BZ    09AC
....................       
....................       numeros[index] = numero[index_2]; 
0978:  CLRF   03
097A:  MOVF   xF8,W
097C:  ADDLW  1D
097E:  MOVWF  01
0980:  MOVLW  00
0982:  ADDWFC 03,F
0984:  MOVFF  03,1FB
0988:  CLRF   03
098A:  MOVF   xF9,W
098C:  ADDWF  xF6,W
098E:  MOVWF  FE9
0990:  MOVF   xF7,W
0992:  ADDWFC 03,W
0994:  MOVWF  FEA
0996:  MOVFF  FEF,1FC
099A:  MOVFF  1FB,FEA
099E:  MOVFF  01,FE9
09A2:  MOVFF  1FC,FEF
....................       index_2++; 
09A6:  INCF   xF9,F
09A8:  INCF   xF8,F
09AA:  BRA    0966
....................         
....................     } 
....................     numeros[index]='\0'; 
09AC:  CLRF   03
09AE:  MOVF   xF8,W
09B0:  ADDLW  1D
09B2:  MOVWF  FE9
09B4:  MOVLW  00
09B6:  ADDWFC 03,W
09B8:  MOVWF  FEA
09BA:  CLRF   FEF
....................     qtd_numeros++; 
09BC:  INCF   4F,F
....................     return 1; 
09BE:  MOVLW  01
09C0:  MOVWF  01
09C2:  BRA    09CC
09C4:  MOVLB  0
....................    
....................   } 
....................   return 0; 
09C6:  MOVLW  00
09C8:  MOVWF  01
09CA:  MOVLB  1
09CC:  MOVLB  0
09CE:  GOTO   0B2A (RETURN)
.................... } 
....................  
....................  
.................... void limpa_numeros(){ 
....................  
....................   qtd_numeros = 0; 
*
09EC:  CLRF   4F
....................   memset (numeros, 0x00, sizeof(numeros)); 
09EE:  CLRF   FEA
09F0:  MOVLW  1D
09F2:  MOVWF  FE9
09F4:  CLRF   00
09F6:  CLRF   02
09F8:  MOVLW  32
09FA:  MOVWF  01
09FC:  RCALL  09D2
09FE:  GOTO   0BAA (RETURN)
....................    
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define   UART_BUFFER_SIZE         150 
....................  
.................... char comando_recibido_UART[UART_BUFFER_SIZE]; 
.................... char comando_recibido_BUFF [UART_BUFFER_SIZE]; 
.................... int *posicao_valor_comando = 0; 
.................... int16 timeout_trama_UART = 100000; 
.................... extern int1 comando_disponivel_UART; 
....................  
.................... #INT_RDA  
.................... void recepcao_UART() 
*
02CC:  MOVLW  01
02CE:  MOVLB  2
02D0:  MOVWF  x51
.................... { 
....................  int i = 1; 
....................  int8 caracterRx; 
....................    if(kbhit(SIM800L_SERIAL) && comando_disponivel_UART == 0) { 
02D2:  BTFSS  F9E.5
02D4:  BRA    037C
02D6:  MOVLB  1
02D8:  BTFSS  x82.0
02DA:  BRA    02E0
02DC:  MOVLB  2
02DE:  BRA    037C
....................       caracterRx = getc(SIM800L_SERIAL); 
02E0:  MOVLB  0
02E2:  RCALL  02B6
02E4:  MOVFF  01,252
....................       if(caracterRx == '>'||caracterRx == '+' ||caracterRx =='\n'||caracterRx =='\r') { 
02E8:  MOVLB  2
02EA:  MOVF   x52,W
02EC:  SUBLW  3E
02EE:  BZ    0302
02F0:  MOVF   x52,W
02F2:  SUBLW  2B
02F4:  BZ    0302
02F6:  MOVF   x52,W
02F8:  SUBLW  0A
02FA:  BZ    0302
02FC:  MOVF   x52,W
02FE:  SUBLW  0D
0300:  BNZ   037C
....................         comando_recibido_UART[0] = caracterRx; 
0302:  MOVFF  252,52
....................         while(i < (UART_BUFFER_SIZE-1) && timeout_trama_UART > 0) { 
0306:  MOVF   x51,W
0308:  SUBLW  94
030A:  BNC   035E
030C:  MOVLB  1
030E:  MOVF   x80,F
0310:  BNZ   031C
0312:  MOVF   x81,F
0314:  BTFSS  FD8.2
0316:  BRA    031C
0318:  MOVLB  2
031A:  BRA    035E
....................            if(kbhit(SIM800L_SERIAL)) { 
031C:  BTFSS  F9E.5
031E:  BRA    0352
....................              caracterRx = getc(SIM800L_SERIAL); 
0320:  MOVLB  0
0322:  RCALL  02B6
0324:  MOVFF  01,252
....................              comando_recibido_UART[i] = caracterRx; 
0328:  CLRF   03
032A:  MOVLB  2
032C:  MOVF   x51,W
032E:  ADDLW  52
0330:  MOVWF  FE9
0332:  MOVLW  00
0334:  ADDWFC 03,W
0336:  MOVWF  FEA
0338:  MOVFF  252,FEF
....................              if(caracterRx == ';') {  
033C:  MOVF   x52,W
033E:  SUBLW  3B
0340:  BNZ   0346
....................                i++; 
0342:  INCF   x51,F
....................                break; 
0344:  BRA    035E
....................              } 
....................              i++; 
0346:  INCF   x51,F
....................              timeout_trama_UART = 100000; 
0348:  MOVLW  86
034A:  MOVLB  1
034C:  MOVWF  x81
034E:  MOVLW  A0
0350:  MOVWF  x80
....................            } 
....................            timeout_trama_UART--; 
0352:  MOVF   x80,W
0354:  BTFSC  FD8.2
0356:  DECF   x81,F
0358:  DECF   x80,F
035A:  MOVLB  2
035C:  BRA    0306
....................         } 
....................         comando_disponivel_UART = 1; 
035E:  MOVLB  1
0360:  BSF    x82.0
....................         timeout_trama_UART = 100000; 
0362:  MOVLW  86
0364:  MOVWF  x81
0366:  MOVLW  A0
0368:  MOVWF  x80
....................         comando_recibido_UART[i] = 0; 
036A:  CLRF   03
036C:  MOVLB  2
036E:  MOVF   x51,W
0370:  ADDLW  52
0372:  MOVWF  FE9
0374:  MOVLW  00
0376:  ADDWFC 03,W
0378:  MOVWF  FEA
037A:  CLRF   FEF
....................       } 
....................    } 
....................   return; 
037C:  BCF    F9E.5
037E:  MOVLB  0
0380:  GOTO   0060
.................... } 
....................  
.................... char Get_Comando() 
.................... { 
....................   char CMD[15]; 
....................   strcpy (comando_recibido_BUFF, comando_recibido_UART);                            
*
075A:  CLRF   FEA
075C:  MOVLW  E8
075E:  MOVWF  FE9
0760:  CLRF   FE2
0762:  MOVLW  52
0764:  MOVWF  FE1
0766:  MOVF   FE7,F
0768:  MOVFF  FE6,FEE
076C:  BNZ   0766
....................   strcpy (CMD, "+CMTI"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_COMMAND); 
076E:  MOVLW  01
0770:  MOVWF  FEA
0772:  MOVLW  B9
0774:  MOVWF  FE9
0776:  MOVFF  FF2,1C8
077A:  BCF    FF2.7
077C:  MOVLW  00
077E:  RCALL  00A2
0780:  TBLRD*-
0782:  TBLRD*+
0784:  MOVF   FF5,W
0786:  MOVWF  FEE
0788:  IORLW  00
078A:  BNZ   0782
078C:  MOVLB  1
078E:  BTFSC  xC8.7
0790:  BSF    FF2.7
0792:  MOVLB  2
0794:  CLRF   x49
0796:  MOVLW  E8
0798:  MOVWF  x48
079A:  MOVLW  01
079C:  MOVWF  x4B
079E:  MOVLW  B9
07A0:  MOVWF  x4A
07A2:  MOVLB  0
07A4:  RCALL  0496
07A6:  MOVFF  02,17F
07AA:  MOVFF  01,17E
07AE:  MOVLB  1
07B0:  MOVF   x7E,F
07B2:  BNZ   07B8
07B4:  MOVF   x7F,F
07B6:  BZ    07BE
07B8:  MOVLW  01
07BA:  MOVWF  01
07BC:  BRA    0814
....................   strcpy (CMD, "+CMGL"); posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); if(posicao_valor_comando!= 0)return(SMS_READ_COMMAND); 
07BE:  MOVLW  01
07C0:  MOVWF  FEA
07C2:  MOVLW  B9
07C4:  MOVWF  FE9
07C6:  MOVFF  FF2,1C8
07CA:  BCF    FF2.7
07CC:  MOVLW  00
07CE:  MOVLB  0
07D0:  RCALL  00C2
07D2:  TBLRD*-
07D4:  TBLRD*+
07D6:  MOVF   FF5,W
07D8:  MOVWF  FEE
07DA:  IORLW  00
07DC:  BNZ   07D4
07DE:  MOVLB  1
07E0:  BTFSC  xC8.7
07E2:  BSF    FF2.7
07E4:  MOVLB  2
07E6:  CLRF   x49
07E8:  MOVLW  E8
07EA:  MOVWF  x48
07EC:  MOVLW  01
07EE:  MOVWF  x4B
07F0:  MOVLW  B9
07F2:  MOVWF  x4A
07F4:  MOVLB  0
07F6:  RCALL  0496
07F8:  MOVFF  02,17F
07FC:  MOVFF  01,17E
0800:  MOVLB  1
0802:  MOVF   x7E,F
0804:  BNZ   080A
0806:  MOVF   x7F,F
0808:  BZ    0810
080A:  MOVLW  02
080C:  MOVWF  01
080E:  BRA    0814
....................  
....................   return(0); 
0810:  MOVLW  00
0812:  MOVWF  01
0814:  MOVLB  0
0816:  RETURN 0
.................... } 
....................  
....................  
.................... void Executa_Comando(char comando){ 
....................  
....................   char CMD[15]; 
....................   char numero[20]; 
....................  
....................   switch(comando){ 
*
0A02:  MOVLB  1
0A04:  MOVF   xB9,W
0A06:  XORLW  01
0A08:  MOVLB  0
0A0A:  BZ    0A12
0A0C:  XORLW  03
0A0E:  BZ    0A16
0A10:  BRA    0C06
....................       
....................     case SMS_COMMAND:       //+CMTI: "SM",10<CR><LF> 
....................       Read_SMS(); 
0A12:  BRA    0818
....................     break; 
0A14:  BRA    0C06
....................  
....................     case SMS_READ_COMMAND:  //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/13,21:57:54-12"<CR><LF> 
....................  
....................       strcpy (CMD, "OITAI");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); 
0A16:  MOVLW  01
0A18:  MOVWF  FEA
0A1A:  MOVLW  BA
0A1C:  MOVWF  FE9
0A1E:  MOVFF  FF2,1F6
0A22:  BCF    FF2.7
0A24:  MOVLW  00
0A26:  CALL   00E2
0A2A:  TBLRD*-
0A2C:  TBLRD*+
0A2E:  MOVF   FF5,W
0A30:  MOVWF  FEE
0A32:  IORLW  00
0A34:  BNZ   0A2C
0A36:  MOVLB  1
0A38:  BTFSC  xF6.7
0A3A:  BSF    FF2.7
0A3C:  MOVLB  2
0A3E:  CLRF   x49
0A40:  MOVLW  E8
0A42:  MOVWF  x48
0A44:  MOVLW  01
0A46:  MOVWF  x4B
0A48:  MOVLW  BA
0A4A:  MOVWF  x4A
0A4C:  MOVLB  0
0A4E:  RCALL  0496
0A50:  MOVFF  02,17F
0A54:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
0A58:  MOVLB  1
0A5A:  MOVF   x7E,F
0A5C:  BNZ   0A62
0A5E:  MOVF   x7F,F
0A60:  BZ    0ABA
....................  
....................         get_numero(14,25,numero); 
0A62:  MOVLW  0E
0A64:  MOVWF  xF6
0A66:  MOVLW  19
0A68:  MOVWF  xF7
0A6A:  MOVLW  01
0A6C:  MOVWF  xF9
0A6E:  MOVLW  C9
0A70:  MOVWF  xF8
0A72:  MOVLB  0
0A74:  RCALL  08BE
....................         Send_SMS(numero,"HEARTBEAT()"); 
0A76:  MOVLW  01
0A78:  MOVWF  FEA
0A7A:  MOVLW  DD
0A7C:  MOVWF  FE9
0A7E:  MOVFF  FF2,1F6
0A82:  BCF    FF2.7
0A84:  MOVLW  0C
0A86:  MOVWF  01
0A88:  CLRF   FF7
0A8A:  MOVLW  00
0A8C:  CALL   0102
0A90:  TBLRD*-
0A92:  TBLRD*+
0A94:  MOVFF  FF5,FEE
0A98:  DECFSZ 01,F
0A9A:  BRA    0A92
0A9C:  MOVLB  1
0A9E:  BTFSC  xF6.7
0AA0:  BSF    FF2.7
0AA2:  MOVLW  01
0AA4:  MOVWF  xF9
0AA6:  MOVLW  C9
0AA8:  MOVWF  xF8
0AAA:  MOVLW  01
0AAC:  MOVWF  xFB
0AAE:  MOVLW  DD
0AB0:  MOVWF  xFA
0AB2:  MOVLB  0
0AB4:  RCALL  061C
....................         break; 
0AB6:  BRA    0C06
0AB8:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMADD");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+CMGL: 1,"REC UNREAD","+5531995822739","","18/10/14,00:28:46-12"nr+NUMADD+5531995422738<CR><LF> 
0ABA:  MOVLW  01
0ABC:  MOVWF  FEA
0ABE:  MOVLW  BA
0AC0:  MOVWF  FE9
0AC2:  MOVFF  FF2,1F6
0AC6:  BCF    FF2.7
0AC8:  MOVLW  00
0ACA:  MOVLB  0
0ACC:  CALL   0128
0AD0:  TBLRD*-
0AD2:  TBLRD*+
0AD4:  MOVF   FF5,W
0AD6:  MOVWF  FEE
0AD8:  IORLW  00
0ADA:  BNZ   0AD2
0ADC:  MOVLB  1
0ADE:  BTFSC  xF6.7
0AE0:  BSF    FF2.7
0AE2:  MOVLB  2
0AE4:  CLRF   x49
0AE6:  MOVLW  E8
0AE8:  MOVWF  x48
0AEA:  MOVLW  01
0AEC:  MOVWF  x4B
0AEE:  MOVLW  BA
0AF0:  MOVWF  x4A
0AF2:  MOVLB  0
0AF4:  RCALL  0496
0AF6:  MOVFF  02,17F
0AFA:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
0AFE:  MOVLB  1
0B00:  MOVF   x7E,F
0B02:  BNZ   0B08
0B04:  MOVF   x7F,F
0B06:  BZ    0B58
....................          
....................         get_numero(14,75,numero); 
0B08:  MOVLW  0E
0B0A:  MOVWF  xF6
0B0C:  MOVLW  4B
0B0E:  MOVWF  xF7
0B10:  MOVLW  01
0B12:  MOVWF  xF9
0B14:  MOVLW  C9
0B16:  MOVWF  xF8
0B18:  MOVLB  0
0B1A:  RCALL  08BE
....................         insere_numero(numero); 
0B1C:  MOVLW  01
0B1E:  MOVLB  1
0B20:  MOVWF  xF7
0B22:  MOVLW  C9
0B24:  MOVWF  xF6
0B26:  MOVLB  0
0B28:  BRA    0912
....................         get_numero(14,25,numero); 
0B2A:  MOVLW  0E
0B2C:  MOVLB  1
0B2E:  MOVWF  xF6
0B30:  MOVLW  19
0B32:  MOVWF  xF7
0B34:  MOVLW  01
0B36:  MOVWF  xF9
0B38:  MOVLW  C9
0B3A:  MOVWF  xF8
0B3C:  MOVLB  0
0B3E:  RCALL  08BE
....................         Send_SMS(numero,numeros); 
0B40:  MOVLW  01
0B42:  MOVLB  1
0B44:  MOVWF  xF9
0B46:  MOVLW  C9
0B48:  MOVWF  xF8
0B4A:  CLRF   xFB
0B4C:  MOVLW  1D
0B4E:  MOVWF  xFA
0B50:  MOVLB  0
0B52:  RCALL  061C
....................         break; 
0B54:  BRA    0C06
0B56:  MOVLB  1
....................       } 
....................  
....................       strcpy (CMD, "+NUMDEL");posicao_valor_comando = strstr(comando_recibido_BUFF,CMD); //+NUMDEL 
0B58:  MOVLW  01
0B5A:  MOVWF  FEA
0B5C:  MOVLW  BA
0B5E:  MOVWF  FE9
0B60:  MOVFF  FF2,1F6
0B64:  BCF    FF2.7
0B66:  MOVLW  00
0B68:  MOVLB  0
0B6A:  CALL   014A
0B6E:  TBLRD*-
0B70:  TBLRD*+
0B72:  MOVF   FF5,W
0B74:  MOVWF  FEE
0B76:  IORLW  00
0B78:  BNZ   0B70
0B7A:  MOVLB  1
0B7C:  BTFSC  xF6.7
0B7E:  BSF    FF2.7
0B80:  MOVLB  2
0B82:  CLRF   x49
0B84:  MOVLW  E8
0B86:  MOVWF  x48
0B88:  MOVLW  01
0B8A:  MOVWF  x4B
0B8C:  MOVLW  BA
0B8E:  MOVWF  x4A
0B90:  MOVLB  0
0B92:  RCALL  0496
0B94:  MOVFF  02,17F
0B98:  MOVFF  01,17E
....................       if(posicao_valor_comando!= 0){ 
0B9C:  MOVLB  1
0B9E:  MOVF   x7E,F
0BA0:  BNZ   0BA6
0BA2:  MOVF   x7F,F
0BA4:  BZ    0C04
....................           
....................         limpa_numeros();  
0BA6:  MOVLB  0
0BA8:  BRA    09EC
....................         get_numero(14,25,numero); 
0BAA:  MOVLW  0E
0BAC:  MOVLB  1
0BAE:  MOVWF  xF6
0BB0:  MOVLW  19
0BB2:  MOVWF  xF7
0BB4:  MOVLW  01
0BB6:  MOVWF  xF9
0BB8:  MOVLW  C9
0BBA:  MOVWF  xF8
0BBC:  MOVLB  0
0BBE:  RCALL  08BE
....................         Send_SMS(numero,"OK CLEAR ALL"); 
0BC0:  MOVLW  01
0BC2:  MOVWF  FEA
0BC4:  MOVLW  E9
0BC6:  MOVWF  FE9
0BC8:  MOVFF  FF2,1F6
0BCC:  BCF    FF2.7
0BCE:  MOVLW  0D
0BD0:  MOVWF  01
0BD2:  CLRF   FF7
0BD4:  MOVLW  00
0BD6:  CALL   016C
0BDA:  TBLRD*-
0BDC:  TBLRD*+
0BDE:  MOVFF  FF5,FEE
0BE2:  DECFSZ 01,F
0BE4:  BRA    0BDC
0BE6:  MOVLB  1
0BE8:  BTFSC  xF6.7
0BEA:  BSF    FF2.7
0BEC:  MOVLW  01
0BEE:  MOVWF  xF9
0BF0:  MOVLW  C9
0BF2:  MOVWF  xF8
0BF4:  MOVLW  01
0BF6:  MOVWF  xFB
0BF8:  MOVLW  E9
0BFA:  MOVWF  xFA
0BFC:  MOVLB  0
0BFE:  RCALL  061C
....................         break; 
0C00:  BRA    0C06
0C02:  MOVLB  1
....................       } 
....................           
....................     break; 
0C04:  MOVLB  0
....................  
....................  
....................   } 
....................  
....................   return; 
0C06:  RETURN 0
....................  
.................... } 
....................  
.................... int32 get_value(char *pointer_to_string, int nro_caracteres,int posicao) //get_value(posicao_valor_comando,3,6); 
.................... { 
....................   int32 valor = 0; 
....................   int i = 0; 
....................   int32 aux = 1; 
....................   int potencia = 0; 
....................  
....................   while(nro_caracteres > 0) 
....................   { 
....................     if( pointer_to_string[posicao+i] != '.' ) 
....................     { 
....................       nro_caracteres--; 
....................       potencia = nro_caracteres; 
....................       aux = 1; 
....................       while(potencia > 0) 
....................       { 
....................         aux = aux * 10; 
....................         potencia--; 
....................       } 
....................       valor = valor + ((int32)(pointer_to_string[posicao+i]-48)*aux); 
....................     } 
....................     i++; 
....................   } 
....................  
....................   return(valor); 
.................... } 
....................  
.................... void get_numero(int nro_caracteres, int posicao, char *destino){ 
*
08BE:  MOVLB  1
08C0:  CLRF   xFA
....................  
....................   int8 index = 0; 
....................  
....................   for(index = 0;index< nro_caracteres;index++){ 
08C2:  CLRF   xFA
08C4:  MOVF   xF6,W
08C6:  SUBWF  xFA,W
08C8:  BC    08FE
....................  
....................     destino[index] = comando_recibido_BUFF[index+posicao]; 
08CA:  CLRF   03
08CC:  MOVF   xFA,W
08CE:  ADDWF  xF8,W
08D0:  MOVWF  01
08D2:  MOVF   xF9,W
08D4:  ADDWFC 03,F
08D6:  MOVFF  03,1FC
08DA:  MOVF   xF7,W
08DC:  ADDWF  xFA,W
08DE:  CLRF   03
08E0:  ADDLW  E8
08E2:  MOVWF  FE9
08E4:  MOVLW  00
08E6:  ADDWFC 03,W
08E8:  MOVWF  FEA
08EA:  MOVFF  FEF,1FD
08EE:  MOVFF  1FC,FEA
08F2:  MOVFF  01,FE9
08F6:  MOVFF  1FD,FEF
08FA:  INCF   xFA,F
08FC:  BRA    08C4
....................  
....................   } 
....................  
....................   destino[index] = '\0'; 
08FE:  CLRF   03
0900:  MOVF   xFA,W
0902:  ADDWF  xF8,W
0904:  MOVWF  FE9
0906:  MOVF   xF9,W
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  CLRF   FEF
....................  
....................   return; 
090E:  MOVLB  0
0910:  RETURN 0
.................... } 
....................  
.................... void clear_command(){ 
....................  
....................   delay_ms(200); 
*
0C08:  MOVLW  C8
0C0A:  MOVLB  2
0C0C:  MOVWF  x46
0C0E:  MOVLB  0
0C10:  CALL   03D4
....................   memset (comando_recibido_UART, 0x00, sizeof(comando_recibido_UART)); 
0C14:  CLRF   FEA
0C16:  MOVLW  52
0C18:  MOVWF  FE9
0C1A:  CLRF   00
0C1C:  CLRF   02
0C1E:  MOVLW  96
0C20:  MOVWF  01
0C22:  RCALL  09D2
....................  
....................   comando_disponivel_UART = FALSE; 
0C24:  MOVLB  1
0C26:  BCF    x82.0
....................   enable_interrupts(GLOBAL); 
0C28:  MOVLW  C0
0C2A:  IORWF  FF2,F
....................   enable_interrupts(INT_RTCC); 
0C2C:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
0C2E:  BSF    F9D.5
....................    
....................   return; 
0C30:  MOVLB  0
0C32:  GOTO   0CD0 (RETURN)
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... extern int1 resposta_SIM; 
.................... extern comando_disponivel_UART; 
.................... int32 timeout = 7000000; 
....................  
.................... int1 envia_SIM800L(char *send, char *recive){ 
*
052E:  MOVLW  02
0530:  MOVLB  2
0532:  MOVWF  x3F
....................  
....................   int8 tentativas = 2; 
....................  
....................   disable_interrupts(INT_RTCC);  
0534:  BCF    FF2.5
....................   enable_interrupts(INT_RDA);                                               
0536:  BSF    F9D.5
....................   enable_interrupts(GLOBAL); 
0538:  MOVLW  C0
053A:  IORWF  FF2,F
....................    
....................   do{ 
....................     timeout = 7000000;   
053C:  MOVLB  1
053E:  CLRF   x86
0540:  MOVLW  6A
0542:  MOVWF  x85
0544:  MOVLW  CF
0546:  MOVWF  x84
0548:  MOVLW  C0
054A:  MOVWF  x83
....................     comando_disponivel_UART = 0; 
054C:  BCF    x82.0
....................  
....................     fprintf(SIM800L_SERIAL,send);                                             // Envia comando para o SIM800L  
054E:  MOVFF  23C,FEA
0552:  MOVFF  23B,FE9
0556:  MOVLB  0
0558:  BRA    046E
....................     if(strstr(recive,"+CMGS")!=0){ 
055A:  MOVLW  2B
055C:  MOVLB  2
055E:  MOVWF  x40
0560:  MOVLW  43
0562:  MOVWF  x41
0564:  MOVLW  4D
0566:  MOVWF  x42
0568:  MOVLW  47
056A:  MOVWF  x43
056C:  MOVLW  53
056E:  MOVWF  x44
0570:  CLRF   x45
0572:  MOVFF  23E,249
0576:  MOVFF  23D,248
057A:  MOVLW  02
057C:  MOVWF  x4B
057E:  MOVLW  40
0580:  MOVWF  x4A
0582:  MOVLB  0
0584:  RCALL  0496
0586:  MOVFF  02,249
058A:  MOVFF  01,248
058E:  MOVLB  2
0590:  MOVF   x48,F
0592:  BNZ   0598
0594:  MOVF   x49,F
0596:  BZ    05A6
....................       delay_ms(150); 
0598:  MOVLW  96
059A:  MOVWF  x46
059C:  MOVLB  0
059E:  RCALL  03D4
....................       fputc(0x1A,SIM800L_SERIAL); 
05A0:  MOVLW  1A
05A2:  BRA    0524
05A4:  MOVLB  2
....................     }                                                                                         
....................     while(!comando_disponivel_UART && --timeout > 0);                         // Aguarda o SIM800L responder por ~23 segundos caso nao responda retorna 0 
05A6:  MOVLB  1
05A8:  BTFSC  x82.0
05AA:  BRA    05CC
05AC:  MOVLW  FF
05AE:  ADDWF  x83,F
05B0:  BTFSS  FD8.0
05B2:  ADDWF  x84,F
05B4:  BTFSS  FD8.0
05B6:  ADDWF  x85,F
05B8:  BTFSS  FD8.0
05BA:  ADDWF  x86,F
05BC:  MOVF   x83,F
05BE:  BNZ   05A8
05C0:  MOVF   x84,F
05C2:  BNZ   05A8
05C4:  MOVF   x85,F
05C6:  BNZ   05A8
05C8:  MOVF   x86,F
05CA:  BNZ   05A8
....................                           
....................     if(comando_disponivel_UART){                                              // Caso receba a resposta  
05CC:  BTFSS  x82.0
05CE:  BRA    0604
....................                         
....................       posicao_valor_comando = strstr(comando_recibido_UART,recive);           // Procura a palavra recive da funcao na resposta recebida 
05D0:  MOVLB  2
05D2:  CLRF   x49
05D4:  MOVLW  52
05D6:  MOVWF  x48
05D8:  MOVFF  23E,24B
05DC:  MOVFF  23D,24A
05E0:  MOVLB  0
05E2:  RCALL  0496
05E4:  MOVFF  02,17F
05E8:  MOVFF  01,17E
....................                  
....................       if(posicao_valor_comando!= 0){                                          // Caso encontre a resposta esperada 
05EC:  MOVLB  1
05EE:  MOVF   x7E,F
05F0:  BNZ   05F6
05F2:  MOVF   x7F,F
05F4:  BZ    0604
....................         enable_interrupts(INT_RDA); 
05F6:  BSF    F9D.5
....................         enable_interrupts(INT_RTCC); 
05F8:  BSF    FF2.5
....................         enable_interrupts(GLOBAL); 
05FA:  MOVLW  C0
05FC:  IORWF  FF2,F
....................         return 1; 
05FE:  MOVLW  01
0600:  MOVWF  01
0602:  BRA    0618
....................       } 
....................     } 
....................   }while(--tentativas>0);                 
0604:  MOVLB  2
0606:  DECFSZ x3F,F
0608:  BRA    053C
....................    
....................   enable_interrupts(GLOBAL); 
060A:  MOVLW  C0
060C:  IORWF  FF2,F
....................   enable_interrupts(INT_RDA); 
060E:  BSF    F9D.5
....................   enable_interrupts(INT_RTCC); 
0610:  BSF    FF2.5
....................  
....................   return 0; 
0612:  MOVLW  00
0614:  MOVWF  01
0616:  MOVLB  1
0618:  MOVLB  0
061A:  RETURN 0
.................... } 
....................  
.................... int1 Send_SMS(char *numero,char *mensagem){ 
....................    
....................   char numero_envio[35]; 
....................  
....................   sprintf(numero_envio,"AT+CMGS=\"%s\"\r\n",numero); 
061C:  MOVLW  01
061E:  MOVLB  1
0620:  MOVWF  x88
0622:  MOVLW  FC
0624:  MOVWF  x87
0626:  MOVLW  84
0628:  MOVWF  FF6
062A:  MOVLW  03
062C:  MOVWF  FF7
062E:  MOVLW  09
0630:  MOVLB  2
0632:  MOVWF  x37
0634:  MOVLB  0
0636:  RCALL  0420
0638:  MOVFF  1F9,FEA
063C:  MOVFF  1F8,FE9
0640:  BRA    0448
0642:  MOVLW  8F
0644:  MOVWF  FF6
0646:  MOVLW  03
0648:  MOVWF  FF7
064A:  MOVLW  03
064C:  MOVLB  2
064E:  MOVWF  x37
0650:  MOVLB  0
0652:  RCALL  0420
....................  
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")) 
0654:  MOVLW  02
0656:  MOVWF  FEA
0658:  MOVLW  1F
065A:  MOVWF  FE9
065C:  MOVFF  FF2,237
0660:  BCF    FF2.7
0662:  MOVLW  0C
0664:  MOVWF  01
0666:  CLRF   FF7
0668:  MOVLW  00
066A:  RCALL  0194
066C:  TBLRD*-
066E:  TBLRD*+
0670:  MOVFF  FF5,FEE
0674:  DECFSZ 01,F
0676:  BRA    066E
0678:  MOVLB  2
067A:  BTFSC  x37.7
067C:  BSF    FF2.7
067E:  MOVLW  4F
0680:  MOVWF  x2B
0682:  MOVLW  4B
0684:  MOVWF  x2C
0686:  CLRF   x2D
0688:  MOVLW  02
068A:  MOVWF  x3C
068C:  MOVLW  1F
068E:  MOVWF  x3B
0690:  MOVLW  02
0692:  MOVWF  x3E
0694:  MOVLW  2B
0696:  MOVWF  x3D
0698:  MOVLB  0
069A:  RCALL  052E
069C:  MOVF   01,F
069E:  BZ    0754
....................     if(envia_SIM800L("AT+CSMP=17,255,0,0\r\n","OK")) 
06A0:  MOVLW  02
06A2:  MOVWF  FEA
06A4:  MOVLW  1F
06A6:  MOVWF  FE9
06A8:  MOVFF  FF2,237
06AC:  BCF    FF2.7
06AE:  MOVLW  15
06B0:  MOVWF  01
06B2:  CLRF   FF7
06B4:  MOVLW  00
06B6:  RCALL  01BA
06B8:  TBLRD*-
06BA:  TBLRD*+
06BC:  MOVFF  FF5,FEE
06C0:  DECFSZ 01,F
06C2:  BRA    06BA
06C4:  MOVLB  2
06C6:  BTFSC  x37.7
06C8:  BSF    FF2.7
06CA:  MOVLW  4F
06CC:  MOVWF  x34
06CE:  MOVLW  4B
06D0:  MOVWF  x35
06D2:  CLRF   x36
06D4:  MOVLW  02
06D6:  MOVWF  x3C
06D8:  MOVLW  1F
06DA:  MOVWF  x3B
06DC:  MOVLW  02
06DE:  MOVWF  x3E
06E0:  MOVLW  34
06E2:  MOVWF  x3D
06E4:  MOVLB  0
06E6:  RCALL  052E
06E8:  MOVF   01,F
06EA:  BZ    0754
....................       if(envia_SIM800L(numero_envio, ">")) 
06EC:  MOVLW  3E
06EE:  MOVLB  2
06F0:  MOVWF  x1F
06F2:  CLRF   x20
06F4:  MOVLW  01
06F6:  MOVWF  x3C
06F8:  MOVLW  FC
06FA:  MOVWF  x3B
06FC:  MOVLW  02
06FE:  MOVWF  x3E
0700:  MOVLW  1F
0702:  MOVWF  x3D
0704:  MOVLB  0
0706:  RCALL  052E
0708:  MOVF   01,F
070A:  BZ    0754
....................         if(envia_SIM800L(mensagem, "+CMGS:")) 
070C:  MOVLW  02
070E:  MOVWF  FEA
0710:  MOVLW  1F
0712:  MOVWF  FE9
0714:  MOVFF  FF2,237
0718:  BCF    FF2.7
071A:  MOVLW  07
071C:  MOVWF  01
071E:  CLRF   FF7
0720:  MOVLW  00
0722:  RCALL  01EA
0724:  TBLRD*-
0726:  TBLRD*+
0728:  MOVFF  FF5,FEE
072C:  DECFSZ 01,F
072E:  BRA    0726
0730:  MOVLB  2
0732:  BTFSC  x37.7
0734:  BSF    FF2.7
0736:  MOVFF  1FB,23C
073A:  MOVFF  1FA,23B
073E:  MOVLW  02
0740:  MOVWF  x3E
0742:  MOVLW  1F
0744:  MOVWF  x3D
0746:  MOVLB  0
0748:  RCALL  052E
074A:  MOVF   01,F
074C:  BZ    0754
....................           return 1; 
074E:  MOVLW  01
0750:  MOVWF  01
0752:  BRA    0758
....................   return 0; 
0754:  MOVLW  00
0756:  MOVWF  01
0758:  RETURN 0
.................... } 
....................  
.................... int1 Read_SMS(){ 
....................    
....................   if(envia_SIM800L("AT+CMGF=1\r\n","OK")){ 
*
0818:  MOVLW  01
081A:  MOVWF  FEA
081C:  MOVLW  F6
081E:  MOVWF  FE9
0820:  MOVFF  FF2,20E
0824:  BCF    FF2.7
0826:  MOVLW  0C
0828:  MOVWF  01
082A:  CLRF   FF7
082C:  MOVLW  00
082E:  RCALL  0194
0830:  TBLRD*-
0832:  TBLRD*+
0834:  MOVFF  FF5,FEE
0838:  DECFSZ 01,F
083A:  BRA    0832
083C:  MOVLB  2
083E:  BTFSC  x0E.7
0840:  BSF    FF2.7
0842:  MOVLW  4F
0844:  MOVWF  x02
0846:  MOVLW  4B
0848:  MOVWF  x03
084A:  CLRF   x04
084C:  MOVLW  01
084E:  MOVWF  x3C
0850:  MOVLW  F6
0852:  MOVWF  x3B
0854:  MOVLW  02
0856:  MOVWF  x3E
0858:  MOVWF  x3D
085A:  MOVLB  0
085C:  RCALL  052E
085E:  MOVF   01,F
0860:  BZ    08B2
....................     if(envia_SIM800L("AT+CMGL=\"REC UNREAD\"\r\n", "")){ 
0862:  MOVLW  01
0864:  MOVWF  FEA
0866:  MOVLW  F6
0868:  MOVWF  FE9
086A:  MOVFF  FF2,20E
086E:  BCF    FF2.7
0870:  MOVLW  17
0872:  MOVWF  01
0874:  CLRF   FF7
0876:  MOVLW  00
0878:  RCALL  020C
087A:  TBLRD*-
087C:  TBLRD*+
087E:  MOVFF  FF5,FEE
0882:  DECFSZ 01,F
0884:  BRA    087C
0886:  MOVLB  2
0888:  BTFSC  x0E.7
088A:  BSF    FF2.7
088C:  CLRF   x0D
088E:  MOVLW  01
0890:  MOVWF  x3C
0892:  MOVLW  F6
0894:  MOVWF  x3B
0896:  MOVLW  02
0898:  MOVWF  x3E
089A:  MOVLW  0D
089C:  MOVWF  x3D
089E:  MOVLB  0
08A0:  RCALL  052E
08A2:  MOVF   01,F
08A4:  BZ    08B2
....................       resposta_SIM = true; 
08A6:  MOVLB  1
08A8:  BSF    x82.1
....................       return 1;     
08AA:  MOVLW  01
08AC:  MOVWF  01
08AE:  BRA    08B8
08B0:  MOVLB  0
....................     }   
....................   } 
....................   return 0; 
08B2:  MOVLW  00
08B4:  MOVWF  01
08B6:  MOVLB  1
08B8:  MOVLB  0
08BA:  GOTO   0C06 (RETURN)
.................... } 
....................  
....................  
.................... #ENDIF 
....................  
....................  
.................... // Declaração de Variáveis 
....................  
.................... int1 comando_disponivel_UART = FALSE; 
.................... int1 One_Second = FALSE; 
.................... int1 One_Minute = FALSE; 
.................... int16 Miliseconds = 0; 
.................... int16 seconds = 0; 
.................... char comando = 0; 
.................... int1 resposta_SIM = false; 
.................... //Fim declaração de variáveis 
....................  
.................... #INT_RTCC 
.................... void Timer_0(){ 
....................  
....................   set_timer0(6);   
*
0394:  CLRF   FD7
0396:  MOVLW  06
0398:  MOVWF  FD6
....................   Miliseconds++; 
039A:  MOVLB  1
039C:  INCF   x89,F
039E:  BTFSC  FD8.2
03A0:  INCF   x8A,F
....................  
....................   if(Miliseconds == 1000){ 
03A2:  MOVF   x89,W
03A4:  SUBLW  E8
03A6:  BNZ   03CC
03A8:  MOVF   x8A,W
03AA:  SUBLW  03
03AC:  BNZ   03CC
....................     seconds++; 
03AE:  INCF   x8B,F
03B0:  BTFSC  FD8.2
03B2:  INCF   x8C,F
....................     Miliseconds = 0; 
03B4:  CLRF   x8A
03B6:  CLRF   x89
....................     One_Second = TRUE; 
03B8:  BSF    x82.2
....................     output_toggle(PIN_A1); 
03BA:  BTG    F89.1
....................     if(seconds==60){ 
03BC:  MOVF   x8B,W
03BE:  SUBLW  3C
03C0:  BNZ   03CC
03C2:  MOVF   x8C,F
03C4:  BNZ   03CC
....................       seconds = 0; 
03C6:  CLRF   x8C
03C8:  CLRF   x8B
....................       One_Minute = TRUE; 
03CA:  BSF    x82.3
....................     } 
....................   } 
....................   return; 
03CC:  BCF    FF2.2
03CE:  MOVLB  0
03D0:  GOTO   0060
.................... } 
....................  
.................... void main() 
*
0CD8:  CLRF   FF8
0CDA:  BCF    FD0.7
0CDC:  BSF    07.7
0CDE:  CLRF   16
0CE0:  BSF    FB8.3
0CE2:  MOVLW  22
0CE4:  MOVWF  FAF
0CE6:  MOVLW  00
0CE8:  MOVWF  FB0
0CEA:  MOVLW  A6
0CEC:  MOVWF  FAC
0CEE:  MOVLW  90
0CF0:  MOVWF  FAB
0CF2:  CLRF   4F
0CF4:  MOVLB  1
0CF6:  CLRF   x7F
0CF8:  CLRF   x7E
0CFA:  MOVLW  86
0CFC:  MOVWF  x81
0CFE:  MOVLW  A0
0D00:  MOVWF  x80
0D02:  CLRF   x86
0D04:  MOVLW  6A
0D06:  MOVWF  x85
0D08:  MOVLW  CF
0D0A:  MOVWF  x84
0D0C:  MOVLW  C0
0D0E:  MOVWF  x83
0D10:  CLRF   x88
0D12:  CLRF   x87
0D14:  BCF    x82.0
0D16:  BCF    x82.2
0D18:  BCF    x82.3
0D1A:  CLRF   x8A
0D1C:  CLRF   x89
0D1E:  CLRF   x8C
0D20:  CLRF   x8B
0D22:  CLRF   x8D
0D24:  BCF    x82.1
0D26:  MOVF   FC1,W
0D28:  ANDLW  C0
0D2A:  IORLW  0F
0D2C:  MOVWF  FC1
0D2E:  MOVLW  07
0D30:  MOVWF  FB4
0D32:  CLRF   17
0D34:  CLRF   18
.................... { 
....................   set_tris_a (0b00000000);                                                     //Ra7-Ra6-Ra5-Ra4-Ra3-Ra2-Ra1-Ra0 
0D36:  MOVLW  00
0D38:  MOVWF  F92
....................   set_tris_b (0b00000000);                                                     //Rb7-Rb6-Rb5-Rb4-Rb3-Rb2-Rb1-Rb0 
0D3A:  MOVWF  F93
....................   set_tris_c (0b10000000);                                                     //Rc7-Rc6-Rc5-Rc4-Rc3-Rc2-Rc1-Rc0 
0D3C:  MOVLW  80
0D3E:  MOVWF  F94
....................   set_tris_d (0b00000000);  
0D40:  MOVLW  00
0D42:  MOVWF  F95
....................    
....................   setup_adc_ports(NO_ANALOGS); 
0D44:  MOVF   FC1,W
0D46:  ANDLW  C0
0D48:  IORLW  0F
0D4A:  MOVWF  FC1
....................   setup_adc(ADC_OFF); 
0D4C:  BCF    FC2.0
....................   setup_wdt(WDT_OFF); 
0D4E:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16 | RTCC_8_BIT); 
0D50:  MOVLW  C3
0D52:  MOVWF  FD5
....................   set_timer0(6); 
0D54:  CLRF   FD7
0D56:  MOVLW  06
0D58:  MOVWF  FD6
....................    
....................   enable_interrupts(INT_TIMER0); 
0D5A:  BSF    FF2.5
....................   enable_interrupts(INT_RDA); 
0D5C:  BSF    F9D.5
....................   enable_interrupts(GLOBAL);  
0D5E:  MOVLW  C0
0D60:  IORWF  FF2,F
....................   output_high(PIN_C5); 
0D62:  BSF    F8B.5
....................   delay_ms(2000); 
0D64:  MOVLW  08
0D66:  MOVWF  xA8
0D68:  MOVLW  FA
0D6A:  MOVLB  2
0D6C:  MOVWF  x46
0D6E:  MOVLB  0
0D70:  CALL   03D4
0D74:  MOVLB  1
0D76:  DECFSZ xA8,F
0D78:  BRA    0D68
....................   output_low(PIN_C5); 
0D7A:  BCF    F8B.5
....................   delay_ms(5000); 
0D7C:  MOVLW  14
0D7E:  MOVWF  xA8
0D80:  MOVLW  FA
0D82:  MOVLB  2
0D84:  MOVWF  x46
0D86:  MOVLB  0
0D88:  CALL   03D4
0D8C:  MOVLB  1
0D8E:  DECFSZ xA8,F
0D90:  BRA    0D80
....................   Send_SMS("031995822739","INICIANDO..."); 
0D92:  MOVLW  01
0D94:  MOVWF  FEA
0D96:  MOVLW  8E
0D98:  MOVWF  FE9
0D9A:  MOVFF  FF2,1A8
0D9E:  BCF    FF2.7
0DA0:  MOVLW  0D
0DA2:  MOVWF  01
0DA4:  CLRF   FF7
0DA6:  MOVLW  00
0DA8:  MOVLB  0
0DAA:  CALL   023E
0DAE:  TBLRD*-
0DB0:  TBLRD*+
0DB2:  MOVFF  FF5,FEE
0DB6:  DECFSZ 01,F
0DB8:  BRA    0DB0
0DBA:  MOVLB  1
0DBC:  BTFSC  xA8.7
0DBE:  BSF    FF2.7
0DC0:  MOVLW  01
0DC2:  MOVWF  FEA
0DC4:  MOVLW  9B
0DC6:  MOVWF  FE9
0DC8:  MOVFF  FF2,1AA
0DCC:  BCF    FF2.7
0DCE:  MOVLW  0D
0DD0:  MOVWF  01
0DD2:  CLRF   FF7
0DD4:  MOVLW  00
0DD6:  MOVLB  0
0DD8:  CALL   0266
0DDC:  TBLRD*-
0DDE:  TBLRD*+
0DE0:  MOVFF  FF5,FEE
0DE4:  DECFSZ 01,F
0DE6:  BRA    0DDE
0DE8:  MOVLB  1
0DEA:  BTFSC  xAA.7
0DEC:  BSF    FF2.7
0DEE:  MOVLW  01
0DF0:  MOVWF  xF9
0DF2:  MOVLW  8E
0DF4:  MOVWF  xF8
0DF6:  MOVLW  01
0DF8:  MOVWF  xFB
0DFA:  MOVLW  9B
0DFC:  MOVWF  xFA
0DFE:  MOVLB  0
0E00:  RCALL  061C
....................    
....................   while(TRUE){ 
....................  
....................     if(One_Second){ 
0E02:  MOVLB  1
0E04:  BTFSS  x82.2
0E06:  BRA    0E10
....................  
....................       One_Second = FALSE; 
0E08:  BCF    x82.2
....................       Executar_Cada_Segundo(); 
0E0A:  MOVLB  0
0E0C:  BRA    0C36
0E0E:  MOVLB  1
....................  
....................     } 
....................  
....................     if(One_Minute){ 
0E10:  BTFSS  x82.3
0E12:  BRA    0E1E
....................  
....................       One_Minute = FALSE; 
0E14:  BCF    x82.3
....................       Executar_Cada_Minuto(); 
0E16:  MOVLB  0
0E18:  GOTO   0004
0E1C:  MOVLB  1
....................  
....................     } 
0E1E:  BRA    0E04
....................  
....................   } 
....................  
.................... } 
....................  
0E20:  SLEEP 
.................... void Executar_Cada_Segundo(){ 
....................  
....................   if(comando_disponivel_UART){ 
*
0C36:  MOVLB  1
0C38:  BTFSS  x82.0
0C3A:  BRA    0CD2
....................    
....................     disable_interrupts(GLOBAL); 
0C3C:  BCF    FF2.6
0C3E:  BCF    FF2.7
0C40:  BTFSC  FF2.7
0C42:  BRA    0C3E
....................     comando = Get_Comando(); 
0C44:  MOVLB  0
0C46:  RCALL  075A
0C48:  MOVFF  01,18D
....................      
....................     if(comando != 0){ 
0C4C:  MOVLB  1
0C4E:  MOVF   x8D,F
0C50:  BZ    0C5C
....................  
....................       Executa_Comando(comando); 
0C52:  MOVFF  18D,1B9
0C56:  MOVLB  0
0C58:  RCALL  0A02
0C5A:  MOVLB  1
....................        
....................     } 
....................     if(resposta_SIM == 1){ 
0C5C:  BTFSS  x82.1
0C5E:  BRA    0CCA
....................       resposta_SIM = 0; 
0C60:  BCF    x82.1
....................       comando = Get_Comando(); 
0C62:  MOVLB  0
0C64:  RCALL  075A
0C66:  MOVFF  01,18D
....................       Executa_Comando(comando); 
0C6A:  MOVFF  18D,1B9
0C6E:  RCALL  0A02
....................       delay_ms(100); 
0C70:  MOVLW  64
0C72:  MOVLB  2
0C74:  MOVWF  x46
0C76:  MOVLB  0
0C78:  CALL   03D4
....................       envia_SIM800L("AT+CMGD=1,1\r\n", "OK"); 
0C7C:  MOVLW  01
0C7E:  MOVWF  FEA
0C80:  MOVLW  A8
0C82:  MOVWF  FE9
0C84:  MOVFF  FF2,1B9
0C88:  BCF    FF2.7
0C8A:  MOVLW  0E
0C8C:  MOVWF  01
0C8E:  CLRF   FF7
0C90:  MOVLW  00
0C92:  CALL   028E
0C96:  TBLRD*-
0C98:  TBLRD*+
0C9A:  MOVFF  FF5,FEE
0C9E:  DECFSZ 01,F
0CA0:  BRA    0C98
0CA2:  MOVLB  1
0CA4:  BTFSC  xB9.7
0CA6:  BSF    FF2.7
0CA8:  MOVLW  4F
0CAA:  MOVWF  xB6
0CAC:  MOVLW  4B
0CAE:  MOVWF  xB7
0CB0:  CLRF   xB8
0CB2:  MOVLW  01
0CB4:  MOVLB  2
0CB6:  MOVWF  x3C
0CB8:  MOVLW  A8
0CBA:  MOVWF  x3B
0CBC:  MOVLW  01
0CBE:  MOVWF  x3E
0CC0:  MOVLW  B6
0CC2:  MOVWF  x3D
0CC4:  MOVLB  0
0CC6:  RCALL  052E
0CC8:  MOVLB  1
....................     } 
....................     comando = 0; 
0CCA:  CLRF   x8D
....................     clear_command(); 
0CCC:  MOVLB  0
0CCE:  BRA    0C08
0CD0:  MOVLB  1
....................   } 
....................    
....................   return; 
0CD2:  MOVLB  0
0CD4:  GOTO   0E0E (RETURN)
.................... } 
....................  
.................... void Executar_Cada_Minuto(){ 
....................   //Send_SMS("031995822739","TESTE"); 
....................  
....................   return; 
*
0004:  GOTO   0E1C (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CE3B   PLL4 CPUDIV4 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
